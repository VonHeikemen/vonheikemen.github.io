import{_ as s,c as i,a2 as t,o as a}from"./chunks/framework.DXKzXLg0.js";const u=JSON.parse('{"title":"Treesitter","description":"","frontmatter":{"prev":{"text":"Features","link":"/feature/index"},"next":false},"headers":[],"relativePath":"feature/treesitter.md","filePath":"feature/treesitter.md"}'),n={name:"feature/treesitter.md"};function r(h,e,l,p,o,d){return a(),i("div",null,e[0]||(e[0]=[t(`<h1 id="treesitter" tabindex="-1">Treesitter <a class="header-anchor" href="#treesitter" aria-label="Permalink to &quot;Treesitter&quot;">​</a></h1><p>Neovim&#39;s <strong>treesitter support</strong> has been an experimental feature for a few years now. Even today, on the latest stable (<code>v0.11</code>) is marked as experimental. Since treesitter is a buzzword some people like to shout without any explanation here I&#39;ll try my best to shed a light on this topic.</p><h2 id="what-s-treesitter" tabindex="-1">What&#39;s treesitter? <a class="header-anchor" href="#what-s-treesitter" aria-label="Permalink to &quot;What&#39;s treesitter?&quot;">​</a></h2><p><a href="https://tree-sitter.github.io/tree-sitter/" target="_blank" rel="noreferrer">The official documentation</a> describes treesitter as an incremental parsing library. In other words, treesitter&#39;s main job is to read plain text and transform it into a data structure.</p><p><em>And how is that useful?</em></p><p>It&#39;s easier to extract information from structured data in comparison to plain text. This is the same thing &quot;compiled languages&quot; do. They process plain text and generate an <strong>Abstract Syntax Tree</strong> (AST). And all the fancy analysis a compiler can do is based on the AST.</p><p>To be clear, treesitter only reads plain text and generates an Abstract Syntax Tree. And it&#39;s Neovim&#39;s job to do something useful with this &quot;tree.&quot;</p><p>Treesitter&#39;s other job is to provide tools so the editor and plugin authors can extract data out of the AST.</p><h2 id="syntax-highlight" tabindex="-1">Syntax highlight <a class="header-anchor" href="#syntax-highlight" aria-label="Permalink to &quot;Syntax highlight&quot;">​</a></h2><p>Syntax highlight was one of the first areas where treesitter was used, is <strong>the</strong> feature that made treesitter famous in the Neovim community. Because in many cases treesitter&#39;s AST was more accurate than Vim&#39;s syntax files.</p><p>This new treesitter based highlight has the same purpose as syntax files. All it does is create &quot;highlight groups.&quot; And the colorscheme author is the one that needs to use these new highlight groups.</p><p>And this shows perfectly why treesitter is so hard to explain in simple words. Treesitter by itself is not a feature for casual users. It&#39;s the editor itself and the people that knows how to extend it (plugin authors) the ones creating the features that casual users see and interact with.</p><h2 id="other-use-cases" tabindex="-1">Other use cases <a class="header-anchor" href="#other-use-cases" aria-label="Permalink to &quot;Other use cases&quot;">​</a></h2><p>In Neovim&#39;s lua api we have access to a module called <a href="https://neovim.io/doc/user/treesitter.html#_lua-module:-vim.treesitter" target="_blank" rel="noreferrer">vim.treesitter</a> and this means any user with enough patience can start implementing features based on treesitter. This is what many plugins use internally. For example...</p><p><a href="https://github.com/nvim-mini/mini.nvim/blob/main/readmes/mini-snippets.md" target="_blank" rel="noreferrer">mini.snippets</a> (a module of <a href="https://github.com/echasnovski/mini.nvim" target="_blank" rel="noreferrer">mini.nvim</a>) can use treesitter to help provide context aware snippets. When setup correctly <code>mini.snippets</code> can use treesitter to figure out what is the language of the symbol under the cursor. Then it uses this information to search the user&#39;s personal snippet collection.</p><p><a href="https://github.com/nvim-treesitter/nvim-treesitter-context" target="_blank" rel="noreferrer">nvim-treesitter-context</a> is another interesting plugin. It uses treesitter to figure out where you are in the current function and decide if it should display the context at the top of the window.</p><p>Hopefully these examples showcase the value of Neovim&#39;s treesitter integration. It isn&#39;t just something for colorschemes, it&#39;s a tool that can be used to build cool features.</p><h2 id="language-support" tabindex="-1">Language support <a class="header-anchor" href="#language-support" aria-label="Permalink to &quot;Language support&quot;">​</a></h2><p>This is where things get interesting.</p><p>Treesitter doesn&#39;t have support for any language by default. Is not like the developers of the treesitter have to add support for a specific language. They decided to make it modular in a way. So there are three components to treesitter: parsers, queries and the library.</p><h3 id="treesitter-library" tabindex="-1">Treesitter library <a class="header-anchor" href="#treesitter-library" aria-label="Permalink to &quot;Treesitter library&quot;">​</a></h3><p>The &quot;library&quot; is the part of treesitter that is integrated into Neovim. Is the thing that process the content of a file.</p><h3 id="treesitter-parsers" tabindex="-1">Treesitter parsers <a class="header-anchor" href="#treesitter-parsers" aria-label="Permalink to &quot;Treesitter parsers&quot;">​</a></h3><p>Parsers are language specific. This is the component that knows how to read the code of a programming language and generates the AST.</p><p>I believe parsers are also &quot;libraries&quot; but these are like modules other people can implement. This is how you add support for a language, you install a treesitter parser for the language you want to use.</p><h3 id="treesitter-queries" tabindex="-1">Treesitter queries <a class="header-anchor" href="#treesitter-queries" aria-label="Permalink to &quot;Treesitter queries&quot;">​</a></h3><p>This is the mechanism we use to extract information out of the AST. Queries are written in a lisp-like language and it&#39;s basically how we search within the AST.</p><p>This is an example query for the json parser.</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(object</span></span>
<span class="line"><span>  (pair</span></span>
<span class="line"><span>    key: (string) @some-thing))</span></span></code></pre></div><p>The entire AST treesitter creates can be represented in this syntax and a query is a pattern that can match one or more nodes in the file.</p><p>In some cases the query is the component that powers a specific feature. The syntax highlight for example. In this case Neovim will search the <a href="/learn-nvim/feature/global-plugin.html#the-runtimepath">runtimepath</a> any file that matches the pattern <code>queries/*/highlights.scm</code>. Where <code>*</code> is replaced by the name of a treesitter parser. And so <code>highlight.scm</code> will be the file that contains the queries that assigns the highlight groups.</p><h2 id="about-nvim-treesitter" tabindex="-1">About nvim-treesitter <a class="header-anchor" href="#about-nvim-treesitter" aria-label="Permalink to &quot;About nvim-treesitter&quot;">​</a></h2><p><a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noreferrer">nvim-treesitter</a> is probably the first plugin to ever implement features based on treesitter. And it is actually a multi-purpose plugin:</p><ul><li>It provides commands to install treesitter parsers</li><li>It provides queries for the supported parsers</li><li>It implements experimental features that may land in Neovim in the future</li></ul><p>The overall idea of this plugin is to make it easier to use treesitter within Neovim. Starting with the treesitter parsers, <code>nvim-treesitter</code> provides the command <code>:TSInstall</code> so we can add new treesitter parsers. Additionally, it provides queries for highlights, indents and folds.</p><p>When it comes to features it really depends on our Neovim version.</p><h3 id="on-neovim-v0-11" tabindex="-1">On Neovim v0.11+ <a class="header-anchor" href="#on-neovim-v0-11" aria-label="Permalink to &quot;On Neovim v0.11+&quot;">​</a></h3><p>The most recent version of <code>nvim-treesitter</code> targets Neovim v0.11 and greater. In this case the implementation for highlights and folds lives inside Neovim itself. Indents is still considered experimental so the code that implements the feature is inside <code>nvim-treesitter</code>.</p><p>Here we supposed to enable each feature per language. So we could use either a <a href="./filetype-plugin.html">filetype plugin</a> or an <a href="/learn-nvim/101/from-vimscript-to-lua.html#create-autocommands">autocommand</a>.</p><p>And this is the kind of code we would have to write.</p><div class="language-vim vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vim</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; enable syntax highlight</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lua </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim.treesitter.start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; enable folds</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">setlocal</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foldexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lua.vim.treesitter.foldexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">setlocal</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foldmethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expr</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&quot; enable indents</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">setlocal</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> indentexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v:lua.require</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nvim-treesitter&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.indentexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>I&#39;m writting this in vimscript just to show is possible.</p><p>This is equivalent in lua:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- enable syntax highlight</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">treesitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- enable folds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foldexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;v:lua.vim.treesitter.foldexpr()&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foldmethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;expr&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- enable indents</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indentexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;v:lua.require&#39;nvim-treesitter&#39;.indentexpr()&quot;</span></span></code></pre></div><p>Notice that we are working with lua functions, window options, buffer options, autocommands, and some other details. So you do need to be familiar with how Neovim works in order to use these features.</p><h3 id="on-older-neovim-versions" tabindex="-1">On older Neovim versions <a class="header-anchor" href="#on-older-neovim-versions" aria-label="Permalink to &quot;On older Neovim versions&quot;">​</a></h3><p>On Neovim v0.9 and v0.10 we&#39;ll have to use <a href="https://github.com/nvim-treesitter/nvim-treesitter/tree/v0.10.0" target="_blank" rel="noreferrer">nvim-treesitter v0.10.0</a>.</p><p>On this particular version of <code>nvim-treesitter</code> we enable highlights and indents by calling a function during Neovim&#39;s initialization process.</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;nvim-treesitter.configs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  highlight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  indent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>The folds feature has to be enabled by setting the <code>foldexpr</code> option. This could be in an autocommand or a filetype plugin.</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foldexpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;v:lua.vim.treesitter.foldexpr()&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vim.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foldmethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;expr&#39;</span></span></code></pre></div>`,51)]))}const c=s(n,[["render",r]]);export{u as __pageData,c as default};
