import{_ as t,c as r,a2 as a,o as s}from"./chunks/framework.DXKzXLg0.js";const c=JSON.parse('{"title":"Treesitter","description":"","frontmatter":{"prev":{"text":"Features","link":"/feature/index"},"next":false},"headers":[],"relativePath":"feature/treesitter.md","filePath":"feature/treesitter.md"}'),i={name:"feature/treesitter.md"};function n(o,e,h,l,p,u){return s(),r("div",null,e[0]||(e[0]=[a(`<h1 id="treesitter" tabindex="-1">Treesitter <a class="header-anchor" href="#treesitter" aria-label="Permalink to &quot;Treesitter&quot;">​</a></h1><p>Neovim&#39;s <strong>treesitter support</strong> has been an experimental feature for a few years now. Even today, on the latest stable (<code>v0.11</code>) is marked as experimental. Since treesitter is a buzzword some people like to shout without any explanation here I&#39;ll try my best to shed a light on this topic.</p><h2 id="what-s-treesitter" tabindex="-1">What&#39;s treesitter? <a class="header-anchor" href="#what-s-treesitter" aria-label="Permalink to &quot;What&#39;s treesitter?&quot;">​</a></h2><p><a href="https://tree-sitter.github.io/tree-sitter/" target="_blank" rel="noreferrer">The official documentation</a> describes treesitter as an incremental parsing library. In other words, treesitter&#39;s main job is to read plain text and transform it into a data structure.</p><p><em>And how is that useful?</em></p><p>It&#39;s easier to extract information from structured data in comparison to plain text. This is the same thing &quot;compiled languages&quot; do. They process plain text and generate an <strong>Abstract Syntax Tree</strong> (AST). And all the fancy analysis a compiler can do is based on the AST.</p><p>To be clear, treesitter only reads plain text and generates an Abstract Syntax Tree. And it&#39;s Neovim&#39;s job to do something useful with this &quot;tree.&quot;</p><p>Treesitter&#39;s other job is to provide tools so the editor and plugin authors can extract data out of the AST.</p><h2 id="syntax-highlight" tabindex="-1">Syntax highlight <a class="header-anchor" href="#syntax-highlight" aria-label="Permalink to &quot;Syntax highlight&quot;">​</a></h2><p>Syntax highlight was one of the first areas where treesitter was used, is <strong>the</strong> feature that made treesitter famous in the Neovim community. Because in many cases treesitter&#39;s AST was more accurate than Vim&#39;s syntax files.</p><p>This new treesitter based highlight has the same purpose as syntax files. All it does is create &quot;highlight groups.&quot; And the colorscheme author is the one that needs to use these new highlight groups.</p><p>And this shows perfectly why treesitter is so hard to explain in simple words. Treesitter by itself is not a feature for casual users. It&#39;s the editor itself and the people that knows how to extend it (plugin authors) the ones creating the features that casual users see and interact with.</p><h2 id="other-use-cases" tabindex="-1">Other use cases <a class="header-anchor" href="#other-use-cases" aria-label="Permalink to &quot;Other use cases&quot;">​</a></h2><p>In Neovim&#39;s lua api we have access to a module called <a href="https://neovim.io/doc/user/treesitter.html#_lua-module:-vim.treesitter" target="_blank" rel="noreferrer">vim.treesitter</a> and this means any user with enough patience can start implementing features based on treesitter. This is what many plugins use internally. For example...</p><p><a href="https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-snippets.md" target="_blank" rel="noreferrer">mini.snippets</a> (a module of <a href="https://github.com/echasnovski/mini.nvim" target="_blank" rel="noreferrer">mini.nvim</a>) can use treesitter to help provide context aware snippets. When setup correctly <code>mini.snippets</code> can use treesitter to figure out what is the language of the symbol under the cursor. Then it uses this information to search the user&#39;s personal snippet collection.</p><p><a href="https://github.com/nvim-treesitter/nvim-treesitter-context" target="_blank" rel="noreferrer">nvim-treesitter-context</a> is another interesting plugin. It uses treesitter to figure out where you are in the current function and decide if it should display the context at the top of the window.</p><p>Hopefully these examples showcase the value of Neovim&#39;s treesitter integration. It isn&#39;t just something for colorschemes, it&#39;s a tool that can be used to build cool features.</p><h2 id="language-support" tabindex="-1">Language support <a class="header-anchor" href="#language-support" aria-label="Permalink to &quot;Language support&quot;">​</a></h2><p>This is where things get interesting.</p><p>Treesitter doesn&#39;t have support for any language by default. Is not like the developers of the treesitter have to add support for a specific language. They decided to make it modular in a way. So there are three components to treesitter: parsers, queries and the library.</p><h3 id="treesitter-library" tabindex="-1">Treesitter library <a class="header-anchor" href="#treesitter-library" aria-label="Permalink to &quot;Treesitter library&quot;">​</a></h3><p>The &quot;library&quot; is the part of treesitter that is integrated into Neovim. Is the thing that process the content of a file.</p><h3 id="treesitter-parsers" tabindex="-1">Treesitter parsers <a class="header-anchor" href="#treesitter-parsers" aria-label="Permalink to &quot;Treesitter parsers&quot;">​</a></h3><p>Parsers are language specific. This is the component that knows how to read the code of a programming language and generates the AST.</p><p>I believe parsers are also &quot;libraries&quot; but these are like modules other people can implement. This is how you add support for a language, you install a treesitter parser for the language you want to use.</p><h3 id="treesitter-queries" tabindex="-1">Treesitter queries <a class="header-anchor" href="#treesitter-queries" aria-label="Permalink to &quot;Treesitter queries&quot;">​</a></h3><p>This is the mechanism we use to extract information out of the AST. Queries are written in a lisp-like language and it&#39;s basically how we search within the AST.</p><p>This is an example query for the json parser.</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(object</span></span>
<span class="line"><span>  (pair</span></span>
<span class="line"><span>    key: (string) @some-thing))</span></span></code></pre></div><p>The entire AST treesitter creates can be represented in this syntax and a query is a pattern that can match one or more nodes in the file.</p><p>In some cases the query is the component that powers a specific feature. The syntax highlight for example. In this case Neovim will search the <a href="/learn-nvim/feature/global-plugin.html#the-runtimepath">runtimepath</a> any file that matches the pattern <code>queries/*/highlights.scm</code>. Where <code>*</code> is replaced by the name of a treesitter parser. And so <code>highlight.scm</code> will be the file that contains the queries that assigns the highlight groups.</p><h2 id="about-nvim-treesitter" tabindex="-1">About nvim-treesitter <a class="header-anchor" href="#about-nvim-treesitter" aria-label="Permalink to &quot;About nvim-treesitter&quot;">​</a></h2><p><a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noreferrer">nvim-treesitter</a> is probably the first plugin to ever implement features based on treesitter. And it is actually a multi-purpose plugin:</p><ul><li>It provides commands to install treesitter parsers</li><li>It provides queries for the supported parsers</li><li>It implements experimental features that may land in Neovim in the future</li></ul><p>The overall idea of this plugin is to make it easier to use treesitter within Neovim. Starting with the treesitter parsers, <code>nvim-treesitter</code> provides the command <code>:TSInstall</code> so we can add new treesitter parsers. Additionally, it provides queries for highlights, indents and folds.</p><p>When it comes to features it really depends on which version of <code>nvim-treesitter</code> is being used. There is a new rewrite being developed on the <a href="https://github.com/nvim-treesitter/nvim-treesitter/tree/main" target="_blank" rel="noreferrer">main branch</a>, this one only implements indents. The implementation for highlights and folds are already part of Neovim v0.11.</p><p>The older versions of <code>nvim-treesitter</code> in the <a href="https://github.com/nvim-treesitter/nvim-treesitter/tree/master" target="_blank" rel="noreferrer">master branch</a> had special modules to enable highlights, indents, folds and incremental selection. Is worth mention that the last version in the master branch is compatible with Neovim v0.9 all the way to v0.11. If you are using Neovim v0.7, I recommend using the <a href="https://github.com/nvim-treesitter/nvim-treesitter/tree/v0.7.2" target="_blank" rel="noreferrer">tag v0.7.2</a>.</p><p><strong>IMPORTANT</strong>: If you decide to use this plugin read carefully the instructions on the <code>README.md</code> file, specially the requirements. Right now (July 2025) the <code>master branch</code> is the default. This means third-party plugin managers will probably download the &quot;old version&quot; if you don&#39;t specify a branch. So, whatever method you choose to download this plugin, always specify a branch.</p><p>To recap, <code>nvim-treesitter</code> is a plugin that give us easy access to treesitter parsers and queries. Things that we need to enable &quot;treesitter support&quot; for a given programming language. And it also serves as a testing ground for new features based on treesitter, which may be included in Neovim at some point in the future.</p>`,39)]))}const m=t(i,[["render",n]]);export{c as __pageData,m as default};
