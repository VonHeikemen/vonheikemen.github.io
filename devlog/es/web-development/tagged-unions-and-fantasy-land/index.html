<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Uniones discriminadas y Fantasy Land | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, paradigma-funcional, software, coding, development" name=keywords><meta content="Usaremos las uniones discriminadas para explorar una rama de Fantasy Land" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul> © 2020-2023 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Uniones discriminadas y Fantasy Land</h1><span class=post-date>2020-05-24 | 23 minutos | <a href=https://vonheikemen.github.io/devlog/web-development/tagged-unions-and-fantasy-land/> Read in english </a> </span><p>Vamos a hacer algo divertido, vamos a explorar una de las ramas de la especificación <a href=https://github.com/fantasyland/fantasy-land rel=noopener target=_blank>Fantasy Land</a> usando uniones discriminadas como nuestro medio transporte. Para no extendernos más de lo necesario vamos a enfocarnos más que todo en el cómo funcionan las cosas y dejaremos de lado muchos detalles. Entonces, lo que haremos será crear una estructura y ver si podemos seguir las reglas que aparecen en la especificación.<h2 id=uniones-discriminadas>Uniones Discriminadas</h2><p>También conocidas como <em>variantes</em>, son un tipo de estructura que nos permiten modelar un valor que puede tener diferentes estados. En cualquier punto del tiempo sólo pueden representar uno de sus posibles estados. Otras características importantes incluyen la capacidad de almacenar información sobre ellas mismas así como también una "carga" extra que puede ser cualquier cosa.<p>Todo eso suena bien hasta que nos damos cuenta que no tenemos esas cosas en javascript. Si queremos usarlas tendremos que recrearlas nosotros mismos. Por suerte para nosotros no necesitamos una implementación a prueba de balas. Sólo necesitamos un par de cosas, saber el tipo de variante de una variable y también una forma de llevar información. Podemos con eso.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>Union</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>types</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>target </span><span style=color:#5fb3b3>= {};
</span><span>  
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>const </span><span>type </span><span style=color:#5fb3b3>of </span><span>types) </span><span style=color:#5fb3b3>{
</span><span>    target[type] </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>(</span><span style=color:#5fb3b3>{ </span><span>type</span><span style=color:#5fb3b3>, </span><span>data </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>target</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>¿Qué tenemos aquí? Pueden pensar en <code>Union</code> como una fábrica de constructores. Acepta como argumento una lista de variantes y por cada una creará un constructor. Mejor les muestro. Digamos que queremos modelar los posibles estados de una tarea, usando <code>Union</code> podemos crear algo así.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Status </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>Union</span><span>([</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Success</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>Failed</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>Pending</span><span style=color:#5fb3b3>'</span><span>])</span><span style=color:#5fb3b3>;
</span></code></pre><p>Ahora tenemos una forma de crear variantes de nuestro tipo <code>Status</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Status</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Success</span><span>(</span><span style=color:#5fb3b3>{ </span><span>some</span><span style=color:#5fb3b3>: '</span><span style=color:#99c794>stuff</span><span style=color:#5fb3b3>' }</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Success", "data": { "some": "stuff" } }
</span></code></pre><p>Con la propiedad <code>type</code> podemos saber con qué variante estamos tratando y en <code>data</code> podemos poner cualquier valor que se nos ocurra. Ya habrán notado que sólo usamos el nombre de la variante en <code>type</code>, esto puede causar colisiones con otras variantes de diferente tipo, lo mejor sería agregar más información en la función <code>Union</code> pero vamos a dejarlo así.<p>Si este patrón les parece útil y necesitan algo confiable, consideren usar una librería en lugar de hacer su propia implementación. Pueden usar <a href=https://www.npmjs.com/package/tagmeme rel=noopener target=_blank>tagmeme</a> o <a href=https://www.npmjs.com/package/daggy rel=noopener target=_blank>daggy</a> o cualquier otra.<h2 id=fantasy-land>Fantasy Land</h2><p>La descripción en github dice lo siguiente:<blockquote><p>Especificación de interoperabilidad de estructuras algebraicas comunes en javascript.</blockquote><p>¿Estructuras algebraicas? ¿Qué? Ya sé, los entiendo. Y la definición formal tampoco ayuda mucho. Lo mejor que puedo hacer es ofrecerles una definición vaga que los deje con una mínima cantidad de dudas, aquí voy: Las estructuras algebraicas son la combinación de un conjunto de valores y un conjunto de operaciones que siguen ciertas reglas.<p>En nuestro caso, pueden pensar en las variantes como nuestro "conjunto de valores" y las funciones que crearemos serán nuestras "operaciones," finalmente las reglas que seguiremos serán las de Fantasy Land.<h2 id=la-conexion>La Conexión</h2><p>Bien, sabemos qué son la uniones discriminadas y tenemos una vaga idea para qué sirve Fantasy Land pero queda la pregunta ¿Cómo conectamos esos dos en la práctica? La respuesta a eso es la <em>búsqueda de patrones</em> (pattern matching). Aquellos que están familiarizados con el término saben que tampoco tenemos eso en javascript. Lamentablemente en este caso lo mejor que podemos hacer es intentar imitar algunas de sus características.<p>¿Cómo comenzamos? Vamos a describir lo que queremos. Necesitamos evaluar una variante, poder determinar qué tipo de variante es y por último ejecutar un bloque de instrucciones. Nuestras variantes tienen la propiedad <code>type</code> que es de tipo <code>String</code>, podríamos simplemente usar un <code>switch/case</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>switch</span><span>(status</span><span style=color:#5fb3b3>.</span><span>type) </span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Success</span><span style=color:#5fb3b3>':
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Todo salió bien
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Failed</span><span style=color:#5fb3b3>':
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Algo salió mal
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Pending</span><span style=color:#5fb3b3>':
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Esperando
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>default</span><span style=color:#5fb3b3>:
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Nunca debería pasar
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Esto se acerca bastante a lo que queremos pero hay un problema, no devuelve nada. Queremos hacer lo mismo que hace este <code>switch/case</code> pero en una expresión, algo que nos de un resultado. Para recrear este comportamiento en la forma que queremos usaremos objetos y funciones.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>match</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>patterns</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#5fb3b3>{ </span><span>type </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>null </span><span style=color:#5fb3b3>} = </span><span>value </span><span style=color:#5fb3b3>|| {};
</span><span>  </span><span style=color:#c594c5>const </span><span>_match </span><span style=color:#5fb3b3>= </span><span>patterns[type]</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>if </span><span>(</span><span style=color:#5fb3b3>typeof </span><span>_match </span><span style=color:#5fb3b3>== '</span><span style=color:#99c794>function</span><span style=color:#5fb3b3>'</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#6699cc>_match</span><span>(value</span><span style=color:#5fb3b3>.</span><span>data)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else if </span><span>(</span><span style=color:#5fb3b3>typeof </span><span>patterns</span><span style=color:#5fb3b3>.</span><span>_ </span><span style=color:#5fb3b3>== '</span><span style=color:#99c794>function</span><span style=color:#5fb3b3>'</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>patterns</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>_</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#f99157>null</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Aquí nuevamente aprovechamos el hecho de que <code>type</code> es de tipo <code>String</code> y lo usaremos para "escoger" el patrón que queremos, pero esta vez transportamos nuestros patrones en un objeto. Ahora bien, cada "patrón" será una función asociada a una propiedad del objeto <code>patterns</code> y la función <code>match</code> devolverá cualquier cosa que retorne nuestro patrón. Finalmente si el patrón de la variante actual no se encuentra buscará una propiedad llamada <code>_</code>, eso actuará como el caso <code>default</code> del <code>switch/case</code> y si todo falla sólo retorna <code>null</code>. Con esto podemos ya obtener el comportamiento que queremos.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#6699cc>match</span><span>(status</span><span style=color:#5fb3b3>, {
</span><span>  </span><span style=color:#6699cc>Success</span><span style=color:#5fb3b3>: ({ </span><span style=color:#f99157>some </span><span style=color:#5fb3b3>}) </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>Some: </span><span style=color:#5fb3b3>${</span><span>some</span><span style=color:#5fb3b3>}`,
</span><span>  </span><span style=color:#6699cc>Failed</span><span style=color:#5fb3b3>:  () </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Oops something went wrong</span><span style=color:#5fb3b3>',
</span><span>  </span><span style=color:#6699cc>Pending</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Wait for it</span><span style=color:#5fb3b3>',
</span><span>  </span><span style=color:#6699cc>_</span><span style=color:#5fb3b3>:       () </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>AAAAHHHH</span><span style=color:#5fb3b3>'
</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// "Some: stuff"
</span></code></pre><p>Con esta función a nuestra disposición podemos seguir adelante.<h2 id=la-estructura>La Estructura</h2><p>Ahora toca crear la estructura que usaremos de aquí en adelante. Lo que haremos será recrear un concepto popular, un posible fallo. Crearemos un tipo de dato con dos variantes <code>Ok</code> y <code>Err</code>, a este tipo lo llamaremos <code>Result</code>. La idea es simple, la variante <code>Ok</code> va a representar una operación exitosa y será usada para transportar un valor, todas nuestras operaciones serán basadas en esta variante. Es decir que en caso de que la variante sea de tipo <code>Err</code> queremos ignorar cualquier tipo de transformación, lo único que haremos será "propagar el error."<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Result </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>Union</span><span>([</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Ok</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>Err</span><span style=color:#5fb3b3>'</span><span>])</span><span style=color:#5fb3b3>;
</span></code></pre><h2 id=las-operaciones>Las Operaciones</h2><p>Antes de comenzar a crear nuestras operaciones vamos a crear una función <code>match</code> específica para nuestra estructura.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>match </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>ok</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>match</span><span>(data</span><span style=color:#5fb3b3>, {</span><span>Ok</span><span style=color:#5fb3b3>: </span><span>ok</span><span style=color:#5fb3b3>, </span><span>Err</span><span style=color:#5fb3b3>: </span><span>err</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Ya todo está en su lugar. Como dije antes, solamente nos enfocaremos en una sola rama de la especificación, exploraremos esa que va desde <code>Functor</code> hasta <code>Monad</code>. Por cada una de estas operaciones vamos a implementar un método estático en nuestro objeto <code>Result</code> y además intentaré explicar cómo funciona y para qué sirve.<p>La lógica dicta que deberíamos empezar con Functor pero vamos a tomar otro camino.<h3 id=chain>Chain</h3><p>La operación <code>chain</code> nos permite interactuar con el valor que se encuentra "dentro" de una estructura y transformarla completamente. ¿Suena fácil, verdad? Nosotros hacemos eso todo el tiempo, pero esta vez debemos seguir unas reglas. Les presento la primera ley del día.<ul><li>Asociatividad</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Fx)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Gx)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalent a
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>Fx</span><span>(v)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Gx))</span><span style=color:#5fb3b3>;
</span></code></pre><blockquote><p>Noten que el comentario dice "equivalente a" aunque en muchos casos estas pruebas deben dar resultados idénticos, no necesariamente se trata de una comparación de igualdad, debería interpretarse más como "deben tener el mismo efecto."</blockquote><p>Esta ley nos habla del orden de las operaciones. En la primera sentencia se puede ver como una secuencia, va una función detrás de la otra. En la segunda sentencia vemos cómo una operación "envuelve" a la otra. Y esto es interesante ¿ven esto <code>Fx(value).chain(Gx)</code>? El segundo <code>chain</code> viene directo del resultado de <code>Fx</code>. Tanto <code>Fx</code> como <code>Gx</code> son funciones que retornan estructuras que también siguen esta ley.<p>Vamos a ver esto en la práctica con una estructura que todos conocemos, los arreglos. Resulta que los arreglos siguen esta ley (algo así). Puede que en la clase <code>Array</code> no exista el método <code>chain</code> pero sí tiene <code>flatMap</code> el cual debería comportarse de igual manera.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>exclaim      </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>';
</span><span>
</span><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>Uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>[</span><span style=color:#6699cc>to_uppercase</span><span>(str)]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>Exclaim   </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>[</span><span style=color:#6699cc>exclaim</span><span>(str)]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>flatMap</span><span>(Uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>flatMap</span><span>(Exclaim)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>flatMap</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>Uppercase</span><span>(v)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>flatMap</span><span>(Exclaim))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>length</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>one[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>two[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Entonces <code>flatMap</code> nos dejó interactuar con el texto dentro del arreglo y transformarlo usando una función y no importó si el segundo <code>flatMap</code> estuviera dentro o fuera del primero, el resultado es el mismo.<p>Ahora veamos con nuestra estructura. Como mencioné antes, nosotros haremos todas nuestras operaciones con métodos estáticos, así que nuestro ejemplo se verá algo diferente. Esta sería nuestra implementación de <code>chain</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>chain </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>match</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span>Err)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Gracias al poder de la conveniencia <code>Result.match</code> ya contiene la lógica que necesitamos, sólo tenemos proveer un valor para el parámetro <code>err</code> y lograremos el efecto que queremos. Entonces tenemos que <code>Result.chain</code> es una función que espera por el parámetro <code>ok</code> y <code>data</code>. Si la variante es de tipo <code>Err</code> el error quedará envuelto nuevamente en una variante del mismo tipo, como si nada hubiera pasado. Si la variante es de tipo <code>Ok</code> ejecutará la función que le pasemos como primer argumento.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>Uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#6699cc>to_uppercase</span><span>(str))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>Exclaim   </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#6699cc>exclaim</span><span>(str))</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>Uppercase</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>type </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>type</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>data </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>data</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Ya que nuestra función cumple con la ley tenemos una forma de crear una composición entre funciones que retornan estructuras de este tipo. Esto resulta especialmente útil cuando se está creando una cadena de funciones donde los argumentos de una función son los resultados de la anterior.<p><code>Result.chain</code> no sólo sirve para cumplir esta ley, también podemos usarla para construir otras funciones. Comencemos creando una que nos permita "extraer" el valor de nuestra estructura.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>identity </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>arg</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span>join </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>chain</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>identity)</span><span style=color:#5fb3b3>;
</span></code></pre><p><code>Result.join</code> es una función que sólo espera por el parámetro <code>data</code> (este es el milagro de la <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/partial-application/>aplicación parcial</a>).<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>good_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>join</span><span>(good_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// "Hello"
</span><span>
</span><span style=color:#c594c5>const </span><span>bad_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Err</span><span>(</span><span style=color:#5fb3b3>{ </span><span>message</span><span style=color:#5fb3b3>: '</span><span style=color:#99c794>Ooh noes</span><span style=color:#5fb3b3>' }</span><span>)</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>join</span><span>(bad_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Err", "data": { "message": "Ooh noes" } }
</span></code></pre><p>Esta función se llama <code>join</code> porque se supone que debería usarse para "aplanar" una estructura anidada. Algo como en este caso.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>nested_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Hello</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>join</span><span>(nested_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": "Hello" }
</span></code></pre><p>Pero yo voy a abusar de la naturaleza de esta función para comparar el contenido dentro de las estructuras en nuestras pruebas. Para dejar en claro mis intenciones voy a crear un "alias."<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>unwrap </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>join</span><span style=color:#5fb3b3>;
</span></code></pre><h3 id=functor>Functor</h3><p>Si han estado leyendo otros artículos sobre el paradigma funcional en javascript el nombre tal vez les parezca familiar. Incluso si no lo conocen es probable que los hayan usado sin saber. Esta especificación es la que introduce a nuestro viejo amigo <code>.map</code>. Veamos qué la hace tan especial.<ul><li>Identidad</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>v)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>Aunque no lo parezca esta ley es interesante. Esa función que aparece en la primera sentencia, <code>v => v</code>, ¿Les parece familiar? Ya usamos una de esas antes, se le conoce como la función identidad (<code>identity</code>). Verán, en matemática un elemento identidad es aquel que no tiene ningún efecto sobre una operación, y eso es exactamente lo que hace esta función. Pero lo interesante no es lo que está en la superficie, sino lo que no podemos ver. Si la primera sentencia es igual a la segunda eso quiere decir que <code>.map(v => v)</code> retorna otra estructura del mismo tipo, incluso si le pasamos la función más inútil que nos podemos imaginar. Usemos nuevamente un arreglo para ilustrar esta ley.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>identity </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>arg</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Id  </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(identity)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>isArray</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>isArray</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>Val</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span>Id</span><span style=color:#5fb3b3>.</span><span>length</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>Val[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>Id[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>¿Pero cómo nos ayuda eso? La parte importante es que <code>.map</code> debe "preservar la forma" de nuestra estructura. En el caso de los arreglos, si la ejecutamos en un arreglo de 1 elemento devuelve un arreglo de 1 elemento, si la ejecutamos con un arreglo de 100 elementos devuelve otro arreglo de 100 elementos. Si tenemos la garantía de que el resultado será una estructura del mismo tipo eso nos permite hacer cosas como estas.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(fx)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(gx)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(hx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Sé lo que están pensando. Usar <code>.map</code> de esa manera en un arreglo puede tener un impacto terrible en el desempeño de nuestros programas. No se preocupen, tenemos eso cubierto con nuestra segunda ley.<ul><li>Composición</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(</span><span style=color:#6699cc>gx</span><span>(v)))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(gx)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(fx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Esta ley nos dice que podemos reemplazar llamadas consecutivas a <code>.map</code> si combinamos directamente las funciones que usamos como argumentos. Probemos.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>to_uppercase</span><span>(v)))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(to_uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>two[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p><code>.map</code> nos da la habilidad de combinar funciones en diferentes formas, esto nos da la oportunidad de optimizar nuestro código para la velocidad o legibilidad. La composición de funciones es un tema muy amplio, me gustaría extenderme y decirles muchas cosas pero no tenemos tiempo para eso ahora. Si sienten curiosidad puede leer este artículo: <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/composition-techniques/>técnicas de composición</a>.<p>Es hora de implementar el famoso <code>.map</code> para nuestra estructura. Como habrán notado este método tiene muchas similitudes con <code>.chain</code>, de hecho es casi igual excepto por una cosa, con <code>.map</code> tenemos la garantía de que el resultado será una estructura del mismo tipo.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) { 
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#6699cc>fn</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Si recuerdan, <code>.chain</code> sólo ejecutará la función del primer argumento si <code>data</code> es una variante de tipo <code>Ok</code>, entonces lo único que debemos hacer para mantener la estructura es usar <code>Result.Ok</code> en el resultado <code>fn</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Identidad
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(identity</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span style=color:#5f6364>// Composición
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>to_uppercase</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(to_uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><h3 id=apply>Apply</h3><p>Esta es difícil, es mejor explicarlo después de entender la ley que rige esta operación.<ul><li>Composición</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Gx</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Fx</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>fx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(</span><span style=color:#6699cc>gx</span><span>(v)))))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Gx)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Fx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>"¿Quééé?"<p>Sí, yo pensé lo mismo. Esa primera sentencia es la más confusa que hemos visto hasta ahora. Parece que <code>Fx</code> y <code>Gx</code> no son funciones, son estructuras. <code>Gx</code> tiene un método <code>ap</code> así que debe ser del mismo tipo que <code>Val</code>. Si vemos más allá tenemos que <code>Fx</code> tiene un método llamado <code>map</code>, eso quiere decir que es un Functor. Entonces <code>Val</code>, <code>Fx</code> y <code>Gx</code> deben implementar la especificación Functor y Apply para que esto funcione. La última pieza es esta <code>Fx.map(fx => ... fx(...))</code>, sí hay funciones involucradas en esta ley pero están encerradas dentro de una estructura.<p>El nombre de la ley y la segunda sentencia nos dice que esto se trata de combinar funciones. Estoy pensando que el comportamiento de esto es el mismo que <code>.map</code> pero con un giro en la trama, la función que recibimos como argumento está atrapada dentro un Functor. Ya tenemos suficiente información para intentar implementar nuestro método.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>res</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(v)</span><span style=color:#5fb3b3>, </span><span>res)</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>¿Qué está pasando aquí? Bueno, déjenme explicar. Primero extraemos el valor dentro de <code>data</code> si todo sale bien.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>..., </span><span>data)</span><span style=color:#5fb3b3>;
</span></code></pre><p>En este punto tenemos un problema, <code>.chain</code> no nos da ninguna garantía sobre el resultado, puede retornar cualquier cosa. Pero sabemos que <code>res</code> es un Functor, entonces podemos usar <code>.map</code> para salvar el día.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>..., </span><span>res)</span><span style=color:#5fb3b3>;
</span></code></pre><p><code>.map</code> cumple una doble labor, nos da acceso a la función dentro de <code>res</code> y nos ayuda a "preservar la forma de la estructura." Entonces <code>.chain</code> va a devolver lo que nos de <code>.map</code>, esto nos da la confianza para poder combinar varias llamadas a <code>.ap</code>, lo que crea nuestra composición. Por último tenemos esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#6699cc>fn</span><span>(v)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Es lo que de verdad queremos de <code>.ap</code>. El resultado de esa expresión queda en una variante de tipo <code>Ok</code> gracias a <code>map</code> y esta va al mundo exterior gracias a <code>chain</code>. Ahora vienen las pruebas.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>composition </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(</span><span style=color:#6699cc>gx</span><span>(arg))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Uppercase   </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(to_uppercase)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Exclaim     </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Todo eso es genial ¿pero de qué nos sirve? Poner una función dentro de <code>Result.Ok</code> no parece algo que ocurre con frecuencia. ¿Por qué alguien haría eso? Todas son preguntas válidas. Luce confuso porque el método <code>.ap</code> sólo es la mitad de la historia.<p><code>.ap</code> con frecuencia se usa para crear una función auxiliar llamada <code>liftA2</code>. El objetivo de esta función es tomar una función común y hacer que trabaje con valores que están encerrados dentro de una estructura. Algo como esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Title </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Dr. </span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Name  </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>two</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>concat</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA2</span><span>(concat</span><span style=color:#5fb3b3>, </span><span>Title</span><span style=color:#5fb3b3>, </span><span>Name)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": "Dr. Acula" }
</span></code></pre><p>Pueden pensar en <code>liftA2</code> como la versión extendida de <code>.map</code>. Mientras que <code>.map</code> trabaja con funciones que sólo aceptan un argumento, <code>liftA2</code> trabaja con funciones que aceptan dos argumentos. Pero ahora la pregunta es ¿cómo funciona <code>liftA2</code>? La respuesta está en este fragmento.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>composition </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(</span><span style=color:#6699cc>gx</span><span>(arg))</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Veamos lo que pasa ahí. Todo comienza con <code>.map</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Esta expresión extrae la función dentro de <code>Exclaim</code> y la aplica a <code>composition</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#f99157>fx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(</span><span style=color:#6699cc>gx</span><span>(arg))
</span><span style=color:#5f6364>// se transforma en
</span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>gx</span><span>(arg))
</span></code></pre><p>Esa transformación queda en una variante de tipo <code>Ok</code> que es lo que <code>.ap</code> espera como primer argumento. Entonces lo siguiente que tenemos es esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#f99157>gx </span><span style=color:#c594c5>=> </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>gx</span><span>(arg)))</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Ahora que tenemos una función dentro de una variante <code>.ap</code> tiene todo lo que necesita para continuar. Aquí básicamente ocurre lo mismo (excepto que nuestro primer argumento ahora es una variante), la función del primer argumento es aplicada al valor dentro de la variante que tenemos como segundo argumento. El resultado es este.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>to_uppercase</span><span>(arg)))</span><span style=color:#5fb3b3>;
</span></code></pre><p>¿Ya notaron el patrón? Tenemos otra función dentro una variante, eso es exactamente lo que recibe nuestro último <code>.ap</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#f99157>arg </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#6699cc>to_uppercase</span><span>(arg)))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span></code></pre><p>El ciclo se repite nuevamente y finalmente obtenemos.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>HELLO!!</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Este es el patrón que <code>liftA2</code> sigue. La única diferencia es que en lugar de llevar funciones a un valor, llevamos valores a una función. Ya lo verán.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA2 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R2</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#6699cc>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=> </span><span style=color:#f99157>b </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1)</span><span style=color:#5fb3b3>, </span><span>R2)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>La probamos otra vez.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>two</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>concat</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA2</span><span>(concat</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Dr. </span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": "Dr. Acula" }
</span></code></pre><p>¿Quieren hacer un <code>liftA3</code>? Ya saben qué hacer.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA3 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R3</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#6699cc>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=> </span><span style=color:#f99157>b </span><span style=color:#c594c5>=> </span><span style=color:#f99157>c </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b</span><span style=color:#5fb3b3>, </span><span>c)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1)</span><span style=color:#5fb3b3>, </span><span>R2)</span><span style=color:#5fb3b3>, </span><span>R3)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Esa es la ley de composición actuando a nuestro favor. Mientras <code>Result.ap</code> siga la ley podemos seguir incrementando el número de argumentos que podemos aceptar. Ahora sólo por diversión vamos a crear un <code>liftN</code> que pueda aceptar una cantidad arbitraria de argumentos. En esta ocasión necesitaremos ayuda.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>curry</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arity</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(arity </span><span style=color:#5fb3b3><= </span><span>args</span><span style=color:#5fb3b3>.</span><span>length) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#6699cc>fn</span><span>(</span><span style=color:#5fb3b3>...</span><span>args)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>curry</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>arity</span><span style=color:#5fb3b3>, </span><span>fn</span><span style=color:#5fb3b3>, ...</span><span>args)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>apply </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(arg)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>pipe  </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>fns</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>reduce</span><span>(apply</span><span style=color:#5fb3b3>, </span><span>arg)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftN </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>RN</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>arity   </span><span style=color:#5fb3b3>= </span><span>RN</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>const </span><span>curried </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>curry</span><span>(arity</span><span style=color:#5fb3b3>, </span><span>fn)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#6699cc>flipped </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>data </span><span style=color:#c594c5>=> </span><span style=color:#f99157>R </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(R</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>const </span><span>ap      </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>pipe</span><span>(RN</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(flipped))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1))</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Esa sería la versión "automatizada" de <code>liftA3</code>. Ahora podemos usar todo tipo de funciones.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>rest</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>concat</span><span>(</span><span style=color:#5fb3b3>...</span><span>rest)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftN</span><span>(
</span><span>  concat</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Hello, </span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Dr</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>. </span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>'</span><span>)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": "Hello, Dr. Acula!!" }
</span></code></pre><h3 id=applicative>Applicative</h3><p>Como habrán notado a estas alturas todo lo que construimos es una especie de extensión de lo anterior, esta no es la excepción. Para que una estructura sea un Applicative primero debe cumplir con la especificación Apply, luego debe agregar un pequeño detalle extra.<p>El nuevo aporte será un método que nos ayude a construir la unidad más simple de nuestra estructura a partir de un valor. El concepto es similar al de un constructor de una clase, la idea es tener un método que pueda llevar un valor común al "contexto" de nuestra estructura y poder ejecutar cualquier operación de inmediato.<p>Por ejemplo, con la clase <code>Promise</code> podemos hacer esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(to_uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &LTstate>: "pending" }
</span><span style=color:#5f6364>// HELLO
</span></code></pre><p>Luego de usar <code>Promise.resolve</code> nuestro valor <code>'hello'</code> queda "dentro" de una promesa y podemos ejecutar sus métodos <code>then</code> o <code>catch</code> inmediatamente. Si quisiéramos hacer lo mismo usando el constructor tendríamos que hacer esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>promise </span><span style=color:#5fb3b3>= new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>reject</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>{ </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>; }</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(to_uppercase)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &LTstate>: "pending" }
</span><span style=color:#5f6364>// HELLO
</span></code></pre><p>¿Ven todo el esfuerzo que hay que hacer para lograr el mismo efecto? Es por eso que resulta útil tener un "atajo" para crear una instancia "simple" de nuestra estructura. Es hora de implementarlo en nuestra estructura.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>of </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>Ok</span><span style=color:#5fb3b3>;
</span></code></pre><p>Les aseguro que eso sólo es una coincidencia, no siempre es tan fácil. Pero en serio eso es todo lo que necesitamos y podemos probarlo usando las leyes.<ul><li>Identidad</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>v))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>Nuestro viejo amigo "identidad" vuelve a presentarse para recordarnos que <code>.ap</code> en realidad se parece a <code>.map</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(identity)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><ul><li>Homomorfismo</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(val)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(fx))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#6699cc>fx</span><span>(val))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Okey, aquí tenemos un nuevo concepto qué interpretar. Hasta donde pude entender un homomorfismo es una especie de transformación donde se mantiene las capacidades del valor original. Pienso que aquí lo que se quiere probar es que <code>.of</code> no tiene ninguna influencia cuando se "aplica" una función a un valor.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>value </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>';
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(exclaim)</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#6699cc>exclaim</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Para recapitular, en la primera sentencia estamos aplicando <code>exclaim</code> a <code>value</code> mientras ambos están envueltos en nuestra estructura. En la segunda aplicamos <code>exclaim</code> a <code>value</code> directamente y luego envolvemos el resultado. Ambas sentencias nos dan el mismo resultado. Con esto probamos que <code>.of</code> no tiene nada de especial, que sólo está ahí para crear una instancia de nuestra estructura.<ul><li>Intercambio</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(y)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(U)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>U</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#f99157>fx </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fx</span><span>(y)))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Esta es la más difícil de leer. Honestamente no estoy seguro de entender qué se intenta probar aquí. Si tuviera que adivinar diría que no importa de qué lado de la operación <code>.ap</code> se encuentre <code>.of</code> si podemos tratar su contenido como una constante entonces el resultado será el mismo.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>value   </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>';
</span><span style=color:#c594c5>const </span><span>Exclaim </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(value))</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><h3 id=monad>Monad</h3><p>Para crear un Monad debemos cumplir con la especificación Applicative y Chain. Entonces, lo que debemos hacer ahora es... nada. En serio, ya no hay nada qué hacer. Felicitaciones han creado un Monad ¿Quieren ver unas leyes?<ul><li>Identidad - lado izquierdo</ul><pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(a)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(f)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span style=color:#6699cc>f</span><span>(a)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Verificamos.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>exclaim</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>En este punto se deben estar preguntando ¿No pudimos haber hecho esto después de implementar <code>.chain</code> (ya que <code>.of</code> es un alias de <code>Ok</code>)? La respuesta es sí, pero no sería divertido. Se habrían perdido de todo el contexto.<p>¿Qué problema resuelve esto? ¿Qué ganamos? Por lo que he visto resuelve un problema muy específico, uno que puede ocurrir con mayor frecuencia si usan Functors, y ese es el de las estructuras anidadas.<p>Imaginemos que queremos extraer un objeto <code>config</code> que está guardado en el <code>localStorage</code> de nuestro navegador. Como sabemos que esta operación puede fallar creamos una función que usa nuestra variante <code>Result</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>get_config</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>const </span><span>config </span><span style=color:#5fb3b3>= </span><span>localStorage</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>getItem</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>config</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>if</span><span>(config) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(config)</span><span style=color:#5fb3b3>; 
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Err</span><span>(</span><span style=color:#5fb3b3>{ </span><span>message</span><span style=color:#5fb3b3>: '</span><span style=color:#99c794>Configuración no encontrada</span><span style=color:#5fb3b3>' }</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Eso funciona de maravilla. Ahora el problema es que <code>localStorage.getItem</code> no devuelve un objeto, la información que queremos está en forma de un <code>String</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#5fb3b3>'</span><span style=color:#99c794>{"dark-mode":true}</span><span style=color:#5fb3b3>'
</span></code></pre><p>Por suerte tenemos una función que puede transformar ese texto en un objeto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>safe_parse</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>try </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#f99157>JSON</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>parse</span><span>(data))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>catch</span><span>(e) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Err</span><span>(e)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Sabemos que <code>JSON.parse</code> puede fallar por eso se nos ocurrió la brillante idea de envolverlo en una "función segura" que también usa nuestra variante <code>Result</code>. Ahora intenten unir estas dos funciones usando <code>.map</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_config</span><span>())</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": { "type": "Ok", "data": { "dark-mode": true } } }
</span></code></pre><p>¿No es lo que querían, cierto? Si cerramos los ojos e imaginamos que <code>get_config</code> siempre nos da un resultado positivo podríamos reemplazarlo con esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>{"dark-mode":true}</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": "{\"dark-mode\":true}" }
</span></code></pre><p>Esta ley me dice que si uso <code>.chain</code> para aplicar una función a una estructura, es lo mismo que usar dicha función sobre el contenido dentro de la estructura. Aprovechemos eso, ya tenemos la función ideal para este caso.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(identity</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>{"dark-mode":true}</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>identity</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>{"dark-mode":true}</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Espero que sepan qué haré ahora. Ya lo han visto antes.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>join </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>chain</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>identity)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Sí, <code>.join</code>. Esto ya empieza a parecerse a una precuela. Vamos a abrir nuestros ojos nuevamente y volvamos a nuestro problema con <code>.map</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>join</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_config</span><span>()))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": { "dark-mode": true } }
</span></code></pre><p>Resolvimos nuestro problema. Aquí viene lo gracioso, en teoría podríamos implementar <code>.chain</code> usando <code>.join</code> y <code>.map</code>. Verán, usar <code>.join</code> y <code>.map</code> en conjunto es un patrón tan común que por eso existe <code>.chain</code> (también es la razón por la que algunos lo llaman <code>flatMap</code> en lugar de <code>chain</code>).<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_config</span><span>())</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { "type": "Ok", "data": { "dark-mode": true } }
</span></code></pre><p>¿No es genial cuando todo queda en un bonito ciclo? Pero no se levanten de sus asientos todavía, nos queda la escena post-créditos.<ul><li>Identidad - lado derecho</ul><p>Se veía venir. Bien, ¿Qué dice esta ley?<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(M</span><span style=color:#5fb3b3>.</span><span>of)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// es equivalente a
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>Sabemos que podemos cumplirla pero sólo por si acaso, vamos a verificar.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>Ok</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(Result</span><span style=color:#5fb3b3>.</span><span>of</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>¿Qué podemos hacer con esto? Bueno, lo único que se me ocurre por ahora es hacer una implementación más genérica de <code>.map</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=> </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#6699cc>fn</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Puede que no parezca muy útil en nuestra estructura porque <code>.of</code> y <code>Ok</code> tienen la misma funcionalidad, pero si nuestro constructor y <code>.of</code> tuvieran diferente implementación (como en el caso de la clase <code>Promise</code>) esta puede ser una buena manera de simplificar la implementación de <code>.map</code>.<p>Y con esto completamos el ciclo y terminamos nuestro viaje por Fantasy Land.<h2 id=conclusion>Conclusión</h2><p>Si leyeron todo esto y aún así no pudieron entender todo, no se preocupen, puede ser porque no me expliqué bien. A mí me tomó cerca de dos años acumular el conocimiento necesario para escribir esto. Incluso si les toma un mes entenderlo, van por mejor camino que yo.<p>Un buen ejercicio que pueden hacer para entender mejor es tratar de cumplir con la especificación usando clases. Debería ser más fácil de esa manera.<p>Espero que hayan disfrutado la lectura y no les haya dado dolor de cabeza. Hasta la próxima.<h2 id=fuentes>Fuentes</h2><ul><li><a href=https://github.com/fantasyland/fantasy-land rel=noopener target=_blank>Fantasy Land</a><li><a href=http://www.tomharding.me/fantasy-land/ rel=noopener target=_blank>Fantas, Eel, and Specification</a><li><a href=https://dev.to/macsikora/algebraic-structures-explained-part-1-base-definitions-2576 rel=noopener target=_blank>Algebraic Structures Explained - Part 1 - Base Definitions</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/uniones-discriminadas-y-fantasy-land-1fn6 rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/tagged-unions-and-fantasy-land-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png style=height:60px!important;width:217px!important> </a></div></div>