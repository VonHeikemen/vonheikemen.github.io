<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>¿Qué son los applicative functors? | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="javascript,paradigma-funcional,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Usemos javascript para descubrir qué es un applicative functor"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2021 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>¿Qué son los applicative functors?</h1><span class=post-date>2020-08-13
| 11 minutos
| <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/applicative-functors/>Read in english</a></span><p>Nuestra agenda para hoy será aprender qué son applicative functors (aplicativos de ahora en adelante) usando javascript. Sí, usaremos javascript. No me juzguen, es lo que sé. Al terminar este artículo sabrán cómo crearlos, cómo reconocerlos y les enseñaré un truco que puede o no resultarles útil alguna vez.<p>Bien, empecemos desde el principio.<h2 id=que-es-un-functor>¿Qué es un functor?</h2><p>Desde un punto de vista "técnico" podemos decir que son un tipo de contenedor. Verán, la manera más fácil de implementar un functor es "envolviendo" un valor dentro de una estructura. Para interactuar con el valor dentro del functor se provee un método normalmente llamado <code>map</code>, este nos permite transformar el valor usando una función (un callback) y luego envuelve el nuevo valor otra vez en una estructura del mismo tipo.<p>Veamos qué puede hacer <code>map</code>. Para familiarizarnos con este tipo de estructuras voy a demostrar sus capacidades usando un tipo de dato común en javascript, los arreglos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>numbers </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span>numbers</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// [ 2 ]
</span></code></pre><p>¿Qué pasa aquí?<p>Tenemos un número dentro de un arreglo, luego usamos <code>map</code> para acceder a él y transformarlo usando una función, y después el nuevo valor que obtenemos es puesto nuevamente en un arreglo. Eso es todo. Eso es básicamente el comportamiento que debe tener un functor.<p>Ahora bien, los arreglos no son los únicos que siguen este patrón, en javascript tenemos otra estructura que actúa de la misma manera, la clase <code>Promise</code>. Con las promesas no tenemos un método <code>map</code> pero tenemos uno llamado <code>then</code>, no son exactamente iguales en cuestión de comportamiento pero se acerca lo suficiente.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>number </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>resolve</span><span>(</span><span style=color:#f99157>1</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span>number</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &lt;state&gt;: &quot;pending&quot; }
</span><span style=color:#5f6364>// 2
</span></code></pre><p>Aquí ocurre la misma cosa, tenemos un valor dentro de una estructura (una promesa), tenemos un método que nos da acceso al valor (<code>then</code>) y finalmente el nuevo valor queda atrapado en una nueva instancia de la misma estructura.<p>Y ese es el patrón. Ya hemos cubierto todo lo que necesitamos saber sobre los functors por ahora. Si desean saber más detalles sobre ellos revisen este artículo: <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/the-power-of-map/>El Poder de Map</a>.<p>¿Listos para seguir?<h2 id=applicatives>Applicatives</h2><p>Resulta que los aplicativos son functors con características extras. Ellos nos dan la habilidad de mezclar dos functors. Específicamente, nos permiten aplicar una función dentro de un functor a un valor que también esta dentro de un functor.<p>Espera... ¿qué? ¿Una función dentro de un functor?<p>Sí. Algo así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Y luego
</span><span>
</span><span>[plus_one]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Ó
</span><span>
</span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>resolve</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span></code></pre><p>¿Por qué alguien haría eso?<p>Buena pregunta. La respuesta, nadie lo haría. Si hablamos de patrones comunes en javascript este no es uno de ellos. Eso no significa que los aplicativos no tenga un uso.<p>Volviendo a nuestra definición. Normalmente, si tenemos un valor y una función somos capaces de aplicar dicha función así: <code>una_función(un_valor)</code>. Eso no funcionaría si ambos están encerrados dentro de una estructura. Para "arreglar" eso, los aplicativos tienen un método llamado <code>ap</code> (apply abreviado) que se encarga de sacar la función y el valor de sus respectivas estructuras y aplicar la función.<p>Y es en este punto que me gustaría mostrarles un ejemplo de un tipo de dato que ya sigue las reglas de los aplicativos pero no se me ocurre ninguno. Pero no teman, tomemos esto como una oportunidad para hacer algo más.<h2 id=crear-un-aplicativo-desde-cero>Crear un Aplicativo desde cero</h2><p>Para no complicarnos mucho lo que haremos será crear una pequeña extensión de la clase <code>Promise</code>. Vamos a hacer que una promesa se comporte más como un functor aplicativo.<p>¿Por donde comenzamos?<ul><li>La meta</ul><p>Lo que queremos hacer es retrasar ejecución de una promesa. Normalmente cuando se crea una promesa esta ejecuta la "tarea" asignada inmediatamente pero no queremos eso, esta vez queremos controlar cuando se ejecuta la tarea. Para lograr nuestro objetivo crearemos un método llamado <code>fork</code>, este se encargará de crear la promesa y preparar las funciones en caso de éxito y error.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>Task</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>proc</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#69c>fork</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>success</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>const </span><span>promise </span><span style=color:#5fb3b3>= new </span><span>Promise(proc)</span><span style=color:#5fb3b3>;
</span><span>      </span><span style=color:#c594c5>return </span><span>promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(success)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>catch</span><span>(err)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Genial. Ahora vamos comparar esto con una promesa normal.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>let </span><span>number </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>procedure </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>reject</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>look_ma </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>(</span><span style=color:#5fb3b3>`</span><span style=color:#99c794>IT WORKED </span><span style=color:#5fb3b3>${++</span><span>number</span><span style=color:#5fb3b3>}</span><span style=color:#99c794> times</span><span style=color:#5fb3b3>`</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#69c>resolve</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span>
</span><span>  </span><span style=color:#69c>setTimeout</span><span>(look_ma</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span><span>
</span><span style=color:#5fb3b3>new </span><span>Promise(procedure)</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// Esta se ejecuta inmediatamente
</span><span>
</span><span style=color:#69c>Task</span><span>(procedure)</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// Esta no hace nada
</span><span style=color:#69c>Task</span><span>(procedure)  </span><span style=color:#5f6364>// Esta sí
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>fork</span><span>(
</span><span>    </span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>error</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>AAHHH!</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>AWW</span><span style=color:#5fb3b3>&#39;</span><span>)
</span><span>  )</span><span style=color:#5fb3b3>;
</span></code></pre><p>Si ejecutan ese código deberían ver estos mensajes después de 1 segundo.<pre style=background-color:#2b2c2f;color:#cccece><code><span>IT WORKED 1 times
</span><span>IT WORKED 2 times
</span><span>AWW
</span></code></pre><p>Ahora que tenemos lo que queremos vamos al siguiente paso.<ul><li>Haz un functor</ul><p>Como ya saben los aplicativos son functors, significa que ahora necesitamos un método <code>map</code>.<p>Repasemos una vez más. ¿Cuál es el comportamiento que esperamos de <code>map</code>?<ol><li>Debería darnos acceso al valor almacenado internamente a través de una función.<li>Debería retornar un nuevo contenedor del mismo tipo. En nuestro caso una nueva instancia de <code>Task</code>.</ol><pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function Task(proc) {
</span><span>    return {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     map(fn) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return Task(function(resolve, reject) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const promise = new Promise(proc);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         promise.then(fn).then(resolve).catch(reject);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       });
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>      fork(err, success) {
</span><span>        const promise = new Promise(proc);
</span><span>        return promise.then(success).catch(err);
</span><span>      }
</span><span>    }
</span><span>  }
</span></code></pre><p>¿Qué pasa en <code>map</code>? Bueno, primero recibimos el argumento <code>fn</code> esa será una función. Luego, retornamos una instancia de <code>Task</code>. Dentro de esa nueva instancia construimos la promesa justo como hacemos en <code>fork</code> pero esta vez es más "seguro" porque no se ejecutará inmediatamente. El siguiente paso es colocar las funciones que requiere <code>promise</code> en su respectivo orden, primero <code>fn</code> la cual transformará el valor, luego <code>resolve</code> que marca el "fin" de la tarea actual y finalmente <code>catch</code> que recibirá la función <code>reject</code> de la tarea actual.<p>Podemos probar lo que tenemos hasta ahora.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>&#39;;
</span><span style=color:#c594c5>const </span><span style=color:#69c>ohh </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>OOHH</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(exclaim)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(ohh)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>fork</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>error</span><span style=color:#5fb3b3>, </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Si ejecutan eso tal cual como esta deberían ver esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>OOHH
</span><span>hello!!
</span></code></pre><p>Pero si eliminan <code>fork</code> deberían tener esto.<pre style=background-color:#2b2c2f;color:#cccece><code></code></pre><p>Sí, así es, deberían tener absolutamente nada. Ya hemos terminado con el patrón functor de nuestro <code>Task</code>.<ul><li>Vamos por Apply</ul><p>Ya estamos a medio camino. Lo que haremos ahora será que crear <code>ap</code>.<p>Como yo lo veo <code>ap</code> es <code>map</code> pero con un giro en la trama: la función que queremos aplicar está dentro de una instancia de <code>Task</code> [<em>música dramática suena en el fondo</em>].<p>Con esa idea en la mente podemos implementar <code>ap</code>.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function Task(proc) {
</span><span>    return {
</span><span>      map(fn) {
</span><span>        return Task(function(resolve, reject) {
</span><span>          const promise = new Promise(proc);
</span><span>          promise.then(fn).then(resolve).catch(reject);
</span><span>        });
</span><span>      },
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     ap(Fn) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return Task(function(resolve, reject) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const promise = new Promise(proc);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const success = fn =&gt; promise.then(fn);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         Fn.fork(reject, success).then(resolve);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       });
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>      fork(err, success) {
</span><span>        const promise = new Promise(proc);
</span><span>        return promise.then(success).catch(err);
</span><span>      }
</span><span>    }
</span><span>  }
</span></code></pre><p>¿Notan la diferencia con <code>map</code>? No se preocupen igual les diré, la diferencia es que para aplicar la función en <code>Fn</code> usamos <code>fork</code> en lugar de interactuar con una promesa normal. Eso es todo. Veamos si funciona.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>&#39;;
</span><span>
</span><span style=color:#c594c5>const </span><span>Uppercase </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(to_uppercase))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Exclaim </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(exclaim))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Hello </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Hello</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Exclaim)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>fork</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>error</span><span style=color:#5fb3b3>, </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>¡Lo logramos! Ahora podemos mezclar funciones que se encuentren dentro de aplicativos. Pero <code>Task</code> aún no puede entrar en el club de los aplicativos. Tenemos que ocuparnos de otra cosa primero.<ul><li>El ingrediente olvidado</ul><p>Los aplicativos deben ser capaces de colocar cualquier valor dentro de la unidad más simple de su estructura.<p>La clase <code>Promise</code> tiene algo así. En lugar de hacer esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Usualmente hacemos esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Luego de usar <code>Promise.resolve</code> podemos empezar a usar métodos como <code>then</code> y <code>catch</code>. Eso es lo que le hace falta a nuestro <code>Task</code>.<p>Para esta implementar esto necesitaremos un método estático. Para esto existen varios nombres, algunos lo llaman "pure" otros lo llaman "unit" y también están quienes lo llaman "of".<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#69c>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Y ahora sí, finalmente podemos decir que tenemos un aplicativo.<h2 id=algo-que-puedes-usar-en-tu-desarrollo-diario>Algo que puedes usar en tu desarrollo diario</h2><p>Poder crear tu propio tipo de dato es genial, ¿pero no sería mejor si pudiéramos aplicar estos patrones con las estructuras que ya existen?<p>Tengo buenas y malas noticias. La buena es que definitivamente podemos. La mala es que a veces puede ser incómodo.<p>Sigamos con el ejemplo de <code>Task</code> que hemos usado hasta ahora. Pero ahora digamos que queremos usar <code>map</code> y <code>ap</code> pero no queremos crear una nueva estructura. ¿Qué hacemos? Un par de funciones serán suficientes.<p>Si ya están familiarizados con los patrones que buscan, escribirlos en unas funciones estáticas bastará. Así luciría nuestro <code>Task</code> como funciones simples.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Task </span><span style=color:#5fb3b3>= {
</span><span>  </span><span style=color:#69c>of</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>resolve</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(fn)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#69c>ap</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>Fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span>Fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(value)))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Para usar <code>map</code> sería así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(to_uppercase</span><span style=color:#5fb3b3>, </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Y <code>ap</code> funciona de la misma manera.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>&#39;;
</span><span>
</span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(exclaim)</span><span style=color:#5fb3b3>, </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Puedo percibir su escepticismo desde aquí. Sean pacientes. Ahora, <code>map</code> parece medio útil pero <code>ap</code> no tanto. No se preocupen, aún podemos usar <code>ap</code> para un bien mayor. ¿Y si les digo que podemos tener una versión "mejorada" de <code>map</code>? Nuestro <code>map</code> sólo trabaja con funciones que reciben un argumento y eso es bueno pero puede haber ocasiones en que necesitemos más que eso.<p>Digamos que tenemos una función que recibe dos argumentos pero en su mayoría los argumentos casi siempre vienen de dos promesas diferentes. Así que, en nuestra situación imaginaria tenemos estas funciones.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>get_username</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#69c>fetch_data </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>john doe</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>; 
</span><span>    </span><span style=color:#69c>setTimeout</span><span>(fetch_data</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#69c>get_location</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#69c>fetch_data </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>some place</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>; 
</span><span>    </span><span style=color:#69c>setTimeout</span><span>(fetch_data</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>500</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#69c>format_message</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>name</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>place</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>name: </span><span style=color:#5fb3b3>${</span><span>name</span><span style=color:#5fb3b3>}</span><span style=color:#99c794> | place: </span><span style=color:#5fb3b3>${</span><span>place</span><span style=color:#5fb3b3>}`;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Cuando usamos <code>format_message</code> sus argumentos vienen de las otras dos funciones <code>get_username</code> y <code>get_location</code>. Esas últimas dos son asíncronas, entonces tal vez se vean tentados a usar las palabras clave <code>Async/Await</code> pero esa no sería una buena idea. Verán, esas funciones no depende la una de la otra, estaríamos desperdiciando tiempo si hacemos que se ejecuten en secuencia cuando deberían ejecutarse de manera concurrente. Una solución puede encontrarse en la forma de <code>Promise.all</code> y se ve así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>all</span><span>([</span><span style=color:#69c>get_username</span><span>()</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_location</span><span>()])
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#5fb3b3>([</span><span style=color:#f99157>name</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>place</span><span style=color:#5fb3b3>]) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>format_message</span><span>(name</span><span style=color:#5fb3b3>, </span><span>place))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Ahí lo tienen. Eso funciona. Pero nosotros podemos hacer algo mejor, ya que tenemos los aplicativos de nuestro lado. Además, ya tenemos ese objeto <code>Task</code>. Ahora sólo vamos a agregar una función más, esta hará lo mismo que está haciendo <code>Promise.all</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA2 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>A1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>A2</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>b </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>A1)</span><span style=color:#5fb3b3>, </span><span>A2)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Ya les explico el nombre después. Ahora veamos cómo se usa.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA2</span><span>(format_message</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_username</span><span>()</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_location</span><span>())
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>¿No les parece que esto es un poco mejor?<p>Y sí, es cierto que pueden presentar argumentos contra la implementación de <code>liftA2</code> e incluso todo el objeto <code>Task</code>, pero todos los patrones que he mostrado aquí deberían funcionar para los aplicativos que puedan encontrarse por ahí.<p>Como un ejercicio pueden intentar implementar <code>map</code> y <code>ap</code> para la clase <a rel=noopener target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set>Set</a>. Vean que clase de cosas graciosas descubren en el proceso.<p>En fin, el nombre <code>liftA2</code>. En el paradigma funcional cuando logramos que una función trabaje con un tipo de contenedor como lo son los functors se dice que "levantamos" (<code>lift</code> en inglés) esa función al contexto de ese contenedor. ¿Qué significa eso de contexto? Bueno, en el mundo de los arreglos la función que le proveen a <code>map</code> puede ejecutarse muchas veces (o ninguna), en el contexto de una promesa la función que suministran a <code>then</code> sólo se ejecuta cuando la promesa culmina su tarea de manera exitosa. ¿Ya ven lo que digo? Bien. ¿Y el <code>A2</code>? Ya saben, es porque recibe sólo dos argumentos.<p>Hay otro truco que se puede hacer con los aplicativos pero aún no entiendo completamente cómo funciona así que será en otra ocasión.<h2 id=conclusion>Conclusión</h2><p>¿Qué aprendimos hoy, clase?<ul><li>Aprendimos de los functors:<ul><li>Qué hacen.<li>Qué patrones deben seguir.</ul><li>Aprendimos de los aplicativos<ul><li>Qué son.<li>Qué hacen.<li>Cómo crear uno desde cero.<li>Cómo hacer un método <code>ap</code> aún si la estructura con la trabajamos no tiene soporte para el patrón de los aplicativos.<li>Y esa cosa <code>liftA2</code> que se ve genial.</ul></ul><p>¿Aprendieron todo eso? Dios santo. Ustedes son los mejores.<p>Bueno, mi trabajo aquí ha terminado.<h2 id=fuentes>Fuentes</h2><ul><li><a rel=noopener target=_blank href=https://github.com/fantasyland/fantasy-land>Fantasy Land</a><li><a rel=noopener target=_blank href=https://github.com/fantasyland/static-land>Static Land</a><li><a rel=noopener target=_blank href=http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/>Fantas, Eel, and Specification 8: Apply</a><li><a rel=noopener target=_blank href=http://www.tomharding.me/2017/04/17/fantas-eel-and-specification-9/>Fantas, Eel, and Specification 9: Applicative</a><li><a rel=noopener target=_blank href=https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch10.html>Professor Frisby's Mostly Adecuate Guide to Functional Programming. Chapter 10: Applicative Functors</a><li><a rel=noopener target=_blank href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors>Learn you a Haskell: Functors, Applicative Functors and Monoids</a></ul><hr><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>