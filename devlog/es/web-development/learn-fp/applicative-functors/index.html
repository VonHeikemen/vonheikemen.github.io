<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  ¿Qué son los applicative functors? | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, paradigma-funcional, software, coding, development" name=keywords><meta content="Usemos javascript para descubrir qué es un applicative functor" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>¿Qué son los applicative functors?</h1><span class=post-date>2020-08-13 | 9 minutos | <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/applicative-functors/> Read in english </a> </span><p>Nuestra agenda para hoy será aprender qué son applicative functors (aplicativos de ahora en adelante) usando javascript. Sí, usaremos javascript. No me juzguen, es lo que sé. Al terminar este artículo sabrán cómo crearlos, cómo reconocerlos y les enseñaré un truco que puede o no resultarles útil alguna vez.<p>Bien, empecemos desde el principio.<h2 id=que-es-un-functor>¿Qué es un functor?</h2><p>Desde un punto de vista "técnico" podemos decir que son un tipo de contenedor. Verán, la manera más fácil de implementar un functor es "envolviendo" un valor dentro de una estructura. Para interactuar con el valor dentro del functor se provee un método normalmente llamado <code>map</code>, este nos permite transformar el valor usando una función (un callback) y luego envuelve el nuevo valor otra vez en una estructura del mismo tipo.<p>Veamos qué puede hacer <code>map</code>. Para familiarizarnos con este tipo de estructuras voy a demostrar sus capacidades usando un tipo de dato común en javascript, los arreglos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> numbers</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> plus_one</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>number</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> number</span><span style=color:#e6c384> +</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>numbers</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>plus_one</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// [ 2 ]</span></span></code></pre><p>¿Qué pasa aquí?<p>Tenemos un número dentro de un arreglo, luego usamos <code>map</code> para acceder a él y transformarlo usando una función, y después el nuevo valor que obtenemos es puesto nuevamente en un arreglo. Eso es todo. Eso es básicamente el comportamiento que debe tener un functor.<p>Ahora bien, los arreglos no son los únicos que siguen este patrón, en javascript tenemos otra estructura que actúa de la misma manera, la clase <code>Promise</code>. Con las promesas no tenemos un método <code>map</code> pero tenemos uno llamado <code>then</code>, no son exactamente iguales en cuestión de comportamiento pero se acerca lo suficiente.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> number</span><span style=color:#e6c384> =</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> plus_one</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>number</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> number</span><span style=color:#e6c384> +</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>number</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>plus_one</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// Promise { &lt;state>: "pending" }</span></span>
<span class=giallo-l><span style=color:#727169>// 2</span></span></code></pre><p>Aquí ocurre la misma cosa, tenemos un valor dentro de una estructura (una promesa), tenemos un método que nos da acceso al valor (<code>then</code>) y finalmente el nuevo valor queda atrapado en una nueva instancia de la misma estructura.<p>Y ese es el patrón. Ya hemos cubierto todo lo que necesitamos saber sobre los functors por ahora. Si desean saber más detalles sobre ellos revisen este artículo: <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/the-power-of-map/>El Poder de Map</a>.<p>¿Listos para seguir?<h2 id=applicatives>Applicatives</h2><p>Resulta que los aplicativos son functors con características extras. Ellos nos dan la habilidad de mezclar dos functors. Específicamente, nos permiten aplicar una función dentro de un functor a un valor que también esta dentro de un functor.<p>Espera... ¿qué? ¿Una función dentro de un functor?<p>Sí. Algo así.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> plus_one</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>number</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> number</span><span style=color:#e6c384> +</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Y luego</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#9cabca>[</span><span>plus_one</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Ó</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span>plus_one</span><span style=color:#9cabca>);</span></span></code></pre><p>¿Por qué alguien haría eso?<p>Buena pregunta. La respuesta, nadie lo haría. Si hablamos de patrones comunes en javascript este no es uno de ellos. Eso no significa que los aplicativos no tenga un uso.<p>Volviendo a nuestra definición. Normalmente, si tenemos un valor y una función somos capaces de aplicar dicha función así: <code>una_función(un_valor)</code>. Eso no funcionaría si ambos están encerrados dentro de una estructura. Para "arreglar" eso, los aplicativos tienen un método llamado <code>ap</code> (apply abreviado) que se encarga de sacar la función y el valor de sus respectivas estructuras y aplicar la función.<p>Y es en este punto que me gustaría mostrarles un ejemplo de un tipo de dato que ya sigue las reglas de los aplicativos pero no se me ocurre ninguno. Pero no teman, tomemos esto como una oportunidad para hacer algo más.<h2 id=crear-un-aplicativo-desde-cero>Crear un Aplicativo desde cero</h2><p>Para no complicarnos mucho lo que haremos será crear una pequeña extensión de la clase <code>Promise</code>. Vamos a hacer que una promesa se comporte más como un functor aplicativo.<p>¿Por donde comenzamos?<ul><li>La meta</ul><p>Lo que queremos hacer es retrasar ejecución de una promesa. Normalmente cuando se crea una promesa esta ejecuta la "tarea" asignada inmediatamente pero no queremos eso, esta vez queremos controlar cuando se ejecuta la tarea. Para lograr nuestro objetivo crearemos un método llamado <code>fork</code>, este se encargará de crear la promesa y preparar las funciones en caso de éxito y error.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> Task</span><span style=color:#9cabca>(</span><span>proc</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    fork</span><span style=color:#9cabca>(</span><span>err</span><span style=color:#9cabca>,</span><span> success</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>      const</span><span> promise</span><span style=color:#e6c384> = new</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>(</span><span>proc</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>      return</span><span> promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>success</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>catch</span><span style=color:#9cabca>(</span><span>err</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>    }</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Genial. Ahora vamos comparar esto con una promesa normal.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>let</span><span> number</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 0</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> procedure</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>resolve</span><span style=color:#9cabca>,</span><span> reject</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  const</span><span style=color:#7e9cd8> look_ma</span><span style=color:#e6c384> =</span><span style=color:#9cabca> ()</span><span style=color:#957fb8> =></span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span>    console</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>log</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>`IT WORKED </span><span style=color:#9cabca>${</span><span style=color:#e6c384>++</span><span>number</span><span style=color:#9cabca>}</span><span style=color:#98bb6c> times`</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    resolve</span><span style=color:#9cabca>();</span></span>
<span class=giallo-l><span style=color:#9cabca>  };</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>  setTimeout</span><span style=color:#9cabca>(</span><span>look_ma</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 1000</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#e6c384>new</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>(</span><span>procedure</span><span style=color:#9cabca>);</span><span style=color:#727169> // Esta se ejecuta inmediatamente</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>Task</span><span style=color:#9cabca>(</span><span>procedure</span><span style=color:#9cabca>);</span><span style=color:#727169> // Esta no hace nada</span></span>
<span class=giallo-l><span style=color:#7e9cd8>Task</span><span style=color:#9cabca>(</span><span>procedure</span><span style=color:#9cabca>)</span><span style=color:#727169>  // Esta sí</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>fork</span><span style=color:#9cabca>(</span></span>
<span class=giallo-l><span style=color:#9cabca>    ()</span><span style=color:#957fb8> =></span><span> console</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>error</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'AAHHH!'</span><span style=color:#9cabca>),</span></span>
<span class=giallo-l><span style=color:#9cabca>    ()</span><span style=color:#957fb8> =></span><span> console</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>log</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'AWW'</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#9cabca>  );</span></span></code></pre><p>Si ejecutan ese código deberían ver estos mensajes después de 1 segundo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>IT WORKED 1 times</span></span>
<span class=giallo-l><span>IT WORKED 2 times</span></span>
<span class=giallo-l><span>AWW</span></span></code></pre><p>Ahora que tenemos lo que queremos vamos al siguiente paso.<ul><li>Haz un functor</ul><p>Como ya saben los aplicativos son functors, significa que ahora necesitamos un método <code>map</code>.<p>Repasemos una vez más. ¿Cuál es el comportamiento que esperamos de <code>map</code>?<ol><li>Debería darnos acceso al valor almacenado internamente a través de una función.<li>Debería retornar un nuevo contenedor del mismo tipo. En nuestro caso una nueva instancia de <code>Task</code>.</ol><pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function Task(proc) {</span></span>
<span class=giallo-l><span>    return {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     map(fn) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>       return Task(function(resolve, reject) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>         const promise = new Promise(proc);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>         promise.then(fn).then(resolve).catch(reject);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>       });</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     },</span></span>
<span class=giallo-l><span>      fork(err, success) {</span></span>
<span class=giallo-l><span>        const promise = new Promise(proc);</span></span>
<span class=giallo-l><span>        return promise.then(success).catch(err);</span></span>
<span class=giallo-l><span>      }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>¿Qué pasa en <code>map</code>? Bueno, primero recibimos el argumento <code>fn</code> esa será una función. Luego, retornamos una instancia de <code>Task</code>. Dentro de esa nueva instancia construimos la promesa justo como hacemos en <code>fork</code> pero esta vez es más "seguro" porque no se ejecutará inmediatamente. El siguiente paso es colocar las funciones que requiere <code>promise</code> en su respectivo orden, primero <code>fn</code> la cual transformará el valor, luego <code>resolve</code> que marca el "fin" de la tarea actual y finalmente <code>catch</code> que recibirá la función <code>reject</code> de la tarea actual.<p>Podemos probar lo que tenemos hasta ahora.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> exclaim</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>str</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> str</span><span style=color:#e6c384> +</span><span style=color:#98bb6c> '!!'</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> ohh</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>value</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#9cabca> (</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>log</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'OOHH'</span><span style=color:#9cabca>),</span><span> value</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>Task</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>))</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>exclaim</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>ohh</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>fork</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>error</span><span style=color:#9cabca>,</span><span> console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>Si ejecutan eso tal cual como esta deberían ver esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>OOHH</span></span>
<span class=giallo-l><span>hello!!</span></span></code></pre><p>Pero si eliminan <code>fork</code> deberían tener esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain></code></pre><p>Sí, así es, deberían tener absolutamente nada. Ya hemos terminado con el patrón functor de nuestro <code>Task</code>.<ul><li>Vamos por Apply</ul><p>Ya estamos a medio camino. Lo que haremos ahora será que crear <code>ap</code>.<p>Como yo lo veo <code>ap</code> es <code>map</code> pero con un giro en la trama: la función que queremos aplicar está dentro de una instancia de <code>Task</code> [<em>música dramática suena en el fondo</em>].<p>Con esa idea en la mente podemos implementar <code>ap</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function Task(proc) {</span></span>
<span class=giallo-l><span>    return {</span></span>
<span class=giallo-l><span>      map(fn) {</span></span>
<span class=giallo-l><span>        return Task(function(resolve, reject) {</span></span>
<span class=giallo-l><span>          const promise = new Promise(proc);</span></span>
<span class=giallo-l><span>          promise.then(fn).then(resolve).catch(reject);</span></span>
<span class=giallo-l><span>        });</span></span>
<span class=giallo-l><span>      },</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     ap(Fn) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>       return Task(function(resolve, reject) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>         const promise = new Promise(proc);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>         const success = fn => promise.then(fn);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>         Fn.fork(reject, success).then(resolve);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>       });</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     },</span></span>
<span class=giallo-l><span>      fork(err, success) {</span></span>
<span class=giallo-l><span>        const promise = new Promise(proc);</span></span>
<span class=giallo-l><span>        return promise.then(success).catch(err);</span></span>
<span class=giallo-l><span>      }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>¿Notan la diferencia con <code>map</code>? No se preocupen igual les diré, la diferencia es que para aplicar la función en <code>Fn</code> usamos <code>fork</code> en lugar de interactuar con una promesa normal. Eso es todo. Veamos si funciona.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> to_uppercase</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>str</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> str</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>toUpperCase</span><span style=color:#9cabca>();</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> exclaim</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>str</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> str</span><span style=color:#e6c384> +</span><span style=color:#98bb6c> '!!'</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> Uppercase</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Task</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span>to_uppercase</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> Exclaim</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Task</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span>exclaim</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> Hello</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Task</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Hello</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>ap</span><span style=color:#9cabca>(</span><span>Uppercase</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>ap</span><span style=color:#9cabca>(</span><span>Exclaim</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>fork</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>error</span><span style=color:#9cabca>,</span><span> console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>¡Lo logramos! Ahora podemos mezclar funciones que se encuentren dentro de aplicativos. Pero <code>Task</code> aún no puede entrar en el club de los aplicativos. Tenemos que ocuparnos de otra cosa primero.<ul><li>El ingrediente olvidado</ul><p>Los aplicativos deben ser capaces de colocar cualquier valor dentro de la unidad más simple de su estructura.<p>La clase <code>Promise</code> tiene algo así. En lugar de hacer esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#e6c384>new</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>));</span></span></code></pre><p>Usualmente hacemos esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>);</span></span></code></pre><p>Luego de usar <code>Promise.resolve</code> podemos empezar a usar métodos como <code>then</code> y <code>catch</code>. Eso es lo que le hace falta a nuestro <code>Task</code>.<p>Para esta implementar esto necesitaremos un método estático. Para esto existen varios nombres, algunos lo llaman "pure" otros lo llaman "unit" y también están quienes lo llaman "of".<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>of</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span style=color:#7e9cd8> Task</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span></code></pre><p>Y ahora sí, finalmente podemos decir que tenemos un aplicativo.<h2 id=algo-que-puedes-usar-en-tu-desarrollo-diario>Algo que puedes usar en tu desarrollo diario</h2><p>Poder crear tu propio tipo de dato es genial, ¿pero no sería mejor si pudiéramos aplicar estos patrones con las estructuras que ya existen?<p>Tengo buenas y malas noticias. La buena es que definitivamente podemos. La mala es que a veces puede ser incómodo.<p>Sigamos con el ejemplo de <code>Task</code> que hemos usado hasta ahora. Pero ahora digamos que queremos usar <code>map</code> y <code>ap</code> pero no queremos crear una nueva estructura. ¿Qué hacemos? Un par de funciones serán suficientes.<p>Si ya están familiarizados con los patrones que buscan, escribirlos en unas funciones estáticas bastará. Así luciría nuestro <code>Task</code> como funciones simples.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> Task</span><span style=color:#e6c384> =</span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  of</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>  },</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  map</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>,</span><span> data</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> data</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>  },</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  ap</span><span style=color:#9cabca>(</span><span>Fn</span><span style=color:#9cabca>,</span><span> data</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> Fn</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#957fb8> =></span><span> data</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> fn</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>)));</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span></code></pre><p>Para usar <code>map</code> sería así.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> to_uppercase</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>str</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> str</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>toUpperCase</span><span style=color:#9cabca>();</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>to_uppercase</span><span style=color:#9cabca>,</span><span> Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>of</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>))</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>Y <code>ap</code> funciona de la misma manera.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> exclaim</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>str</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span> str</span><span style=color:#e6c384> +</span><span style=color:#98bb6c> '!!'</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>ap</span><span style=color:#9cabca>(</span><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>of</span><span style=color:#9cabca>(</span><span>exclaim</span><span style=color:#9cabca>),</span><span> Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>of</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>))</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>Puedo percibir su escepticismo desde aquí. Sean pacientes. Ahora, <code>map</code> parece medio útil pero <code>ap</code> no tanto. No se preocupen, aún podemos usar <code>ap</code> para un bien mayor. ¿Y si les digo que podemos tener una versión "mejorada" de <code>map</code>? Nuestro <code>map</code> sólo trabaja con funciones que reciben un argumento y eso es bueno pero puede haber ocasiones en que necesitemos más que eso.<p>Digamos que tenemos una función que recibe dos argumentos pero en su mayoría los argumentos casi siempre vienen de dos promesas diferentes. Así que, en nuestra situación imaginaria tenemos estas funciones.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> get_username</span><span style=color:#9cabca>() {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span style=color:#e6c384> new</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#957fb8>    const</span><span style=color:#7e9cd8> fetch_data</span><span style=color:#e6c384> =</span><span style=color:#9cabca> ()</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'john doe'</span><span style=color:#9cabca>);</span><span> </span></span>
<span class=giallo-l><span style=color:#7e9cd8>    setTimeout</span><span style=color:#9cabca>(</span><span>fetch_data</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 1000</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>  });</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> get_location</span><span style=color:#9cabca>() {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span style=color:#e6c384> new</span><span style=color:#7aa89f> Promise</span><span style=color:#9cabca>((</span><span>resolve</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#957fb8>    const</span><span style=color:#7e9cd8> fetch_data</span><span style=color:#e6c384> =</span><span style=color:#9cabca> ()</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> resolve</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'some place'</span><span style=color:#9cabca>);</span><span> </span></span>
<span class=giallo-l><span style=color:#7e9cd8>    setTimeout</span><span style=color:#9cabca>(</span><span>fetch_data</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 500</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>  });</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> format_message</span><span style=color:#9cabca>(</span><span>name</span><span style=color:#9cabca>,</span><span> place</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span style=color:#98bb6c> `name: </span><span style=color:#9cabca>${</span><span>name</span><span style=color:#9cabca>}</span><span style=color:#98bb6c> | place: </span><span style=color:#9cabca>${</span><span>place</span><span style=color:#9cabca>}</span><span style=color:#98bb6c>`</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Cuando usamos <code>format_message</code> sus argumentos vienen de las otras dos funciones <code>get_username</code> y <code>get_location</code>. Esas últimas dos son asíncronas, entonces tal vez se vean tentados a usar las palabras clave <code>Async/Await</code> pero esa no sería una buena idea. Verán, esas funciones no depende la una de la otra, estaríamos desperdiciando tiempo si hacemos que se ejecuten en secuencia cuando deberían ejecutarse de manera concurrente. Una solución puede encontrarse en la forma de <code>Promise.all</code> y se ve así.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>all</span><span style=color:#9cabca>([</span><span style=color:#7e9cd8>get_username</span><span style=color:#9cabca>(),</span><span style=color:#7e9cd8> get_location</span><span style=color:#9cabca>()])</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(([</span><span>name</span><span style=color:#9cabca>,</span><span> place</span><span style=color:#9cabca>])</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> format_message</span><span style=color:#9cabca>(</span><span>name</span><span style=color:#9cabca>,</span><span> place</span><span style=color:#9cabca>))</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>Ahí lo tienen. Eso funciona. Pero nosotros podemos hacer algo mejor, ya que tenemos los aplicativos de nuestro lado. Además, ya tenemos ese objeto <code>Task</code>. Ahora sólo vamos a agregar una función más, esta hará lo mismo que está haciendo <code>Promise.all</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>liftA2</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>,</span><span> A1</span><span style=color:#9cabca>,</span><span> A2</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  const</span><span style=color:#7e9cd8> curried</span><span style=color:#e6c384> =</span><span> a</span><span style=color:#957fb8> =></span><span> b</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> fn</span><span style=color:#9cabca>(</span><span>a</span><span style=color:#9cabca>,</span><span> b</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>ap</span><span style=color:#9cabca>(</span><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>curried</span><span style=color:#9cabca>,</span><span> A1</span><span style=color:#9cabca>),</span><span> A2</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span></code></pre><p>Ya les explico el nombre después. Ahora veamos cómo se usa.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span>Task</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>liftA2</span><span style=color:#9cabca>(</span><span>format_message</span><span style=color:#9cabca>,</span><span style=color:#7e9cd8> get_username</span><span style=color:#9cabca>(),</span><span style=color:#7e9cd8> get_location</span><span style=color:#9cabca>())</span></span>
<span class=giallo-l><span style=color:#9cabca>  .</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span></code></pre><p>¿No les parece que esto es un poco mejor?<p>Y sí, es cierto que pueden presentar argumentos contra la implementación de <code>liftA2</code> e incluso todo el objeto <code>Task</code>, pero todos los patrones que he mostrado aquí deberían funcionar para los aplicativos que puedan encontrarse por ahí.<p>Como un ejercicio pueden intentar implementar <code>map</code> y <code>ap</code> para la clase <a rel="noopener external" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set target=_blank>Set</a>. Vean que clase de cosas graciosas descubren en el proceso.<p>En fin, el nombre <code>liftA2</code>. En el paradigma funcional cuando logramos que una función trabaje con un tipo de contenedor como lo son los functors se dice que "levantamos" (<code>lift</code> en inglés) esa función al contexto de ese contenedor. ¿Qué significa eso de contexto? Bueno, en el mundo de los arreglos la función que le proveen a <code>map</code> puede ejecutarse muchas veces (o ninguna), en el contexto de una promesa la función que suministran a <code>then</code> sólo se ejecuta cuando la promesa culmina su tarea de manera exitosa. ¿Ya ven lo que digo? Bien. ¿Y el <code>A2</code>? Ya saben, es porque recibe sólo dos argumentos.<p>Hay otro truco que se puede hacer con los aplicativos pero aún no entiendo completamente cómo funciona así que será en otra ocasión.<h2 id=conclusion>Conclusión</h2><p>¿Qué aprendimos hoy, clase?<ul><li>Aprendimos de los functors: <ul><li>Qué hacen.<li>Qué patrones deben seguir.</ul><li>Aprendimos de los aplicativos <ul><li>Qué son.<li>Qué hacen.<li>Cómo crear uno desde cero.<li>Cómo hacer un método <code>ap</code> aún si la estructura con la trabajamos no tiene soporte para el patrón de los aplicativos.<li>Y esa cosa <code>liftA2</code> que se ve genial.</ul></ul><p>¿Aprendieron todo eso? Dios santo. Ustedes son los mejores.<p>Bueno, mi trabajo aquí ha terminado.<h2 id=fuentes>Fuentes</h2><ul><li><a rel="noopener external" href=https://github.com/fantasyland/fantasy-land target=_blank>Fantasy Land</a><li><a rel="noopener external" href=https://github.com/fantasyland/static-land target=_blank>Static Land</a><li><a rel="noopener external" href=http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/ target=_blank>Fantas, Eel, and Specification 8: Apply</a><li><a rel="noopener external" href=http://www.tomharding.me/2017/04/17/fantas-eel-and-specification-9/ target=_blank>Fantas, Eel, and Specification 9: Applicative</a><li><a rel="noopener external" href=https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch10.html target=_blank>Professor Frisby's Mostly Adecuate Guide to Functional Programming. Chapter 10: Applicative Functors</a><li><a rel="noopener external" href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors target=_blank>Learn you a Haskell: Functors, Applicative Functors and Monoids</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/que-son-los-applicative-functors-1cnn rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/applicative-functors-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>