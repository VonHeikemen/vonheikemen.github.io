<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Un poco del paradigma funcional en tu javascript: Los poderes de map | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, paradigma-funcional, aprendizaje, software, coding, development" name=keywords><meta content="Vamos a ver qué hace a map tan especial" name=description><link href=https://dev.to/vonheikemen/un-poco-del-paradigma-funcional-en-tu-javascript-los-poderes-de-map-473i rel=canonical><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Un poco del paradigma funcional en tu javascript: Los poderes de map</h1><span class=post-date>2020-02-22 | Originalmente publicado en <a href=https://dev.to/vonheikemen/un-poco-del-paradigma-funcional-en-tu-javascript-los-poderes-de-map-473i> dev.to </a> | 7 minutos | <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/the-power-of-map/> Read in english </a> </span><p>En esta ocasión vamos a dar un vistazo dentro del mundo de los <code>functors</code> y descubrir qué los hace tan especiales. Functor es uno de esos términos que aparece cuando la gente a habla del paradigma funcional en la programación pero cuando llega el momento de explicar qué es, lo que ocurre es que mencionan otros términos abstractos o sólo cuantan los detalles necesarios que necesitan saber. Ya que no tengo ningún conocimiento formal de teoría de categorías no voy a fingir qué sé exactamente lo que son, lo que haré será dicerles lo suficiente para que puedan reconocerlos y cómo pueden usarlos.<h2 id=que-es-un-functor>¿Qué es un functor?</h2><p>Estoy convencido de qué el término es difícil de entender porque se necesita conocimientos de otro tipo de estructura para poder comprenderlos en su totalidad. Otra cosa que contribuye a la confusión es el hecho de que la teoría no sé traduce de la manera más clara en código. Pero bueno, aún así intentaré responder la pregunta, empezando con lo abstracto.<p>Pueden pensar en ellos como la relación que existe entre dos conjuntos. Tengan paciencia, esto empezará a tener sentido en un momento. Imaginen dos arreglos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> favorite_numbers</span><span style=color:#e6c384>  =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>42</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 69</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 73</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> increased_numbers</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>43</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 70</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 74</span><span style=color:#9cabca>];</span></span></code></pre><p>Bien, tenemos el conjunto <code>favorite_numbers</code> y el conjunto <code>increased_numbers</code>, son dos arreglos diferentes almacenados en dos variables separadas pero todos sabemos que hay una conexión entre ellos, lo que debemos tener en cuenta es que podemos expresar esa relación con código. Imaginen que el arreglo <code>increased_numbers</code> no existe pero aún necesitamos esos números, para hacer que aparezcan nuevamente sólo necesitamos la ayuda de nuestro viejo amigo <code>map</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> increased_numbers</span><span style=color:#e6c384> =</span><span> favorite_numbers</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span> num</span><span style=color:#e6c384> +</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>);</span></span></code></pre><p><code>map</code> va a recorrer todo el arreglo y por cada número va a incrementarlo y colocarlo en nuevo arreglo, lo que trae a <code>increased_numbers</code> devuelta. Aunque hemos creado este arreglo nuevamente, este no salió de la nada, nosotros no inventamos los números <code>43</code>, <code>70</code> y <code>74</code>. Lo que hicimos fue describir la relación que hay entre esos números y <code>favorite_numbers</code>.<p>¿Eso es todo? ¿Un functor es un arreglo? La respuesta a eso es un rotundo no. Los arreglos son simplemente una manera muy conveniente de representar un uso común. Esto deja una pregunta en el aire.<h2 id=como-los-reconocemos>¿Cómo los reconocemos?</h2><p>A menudo veo que otras personas los describen como cajas. No creo que estén totalmente errados porque utilizar un contenedor es una de las maneras más simples en las que se puede implementar un functor. La analogía de la caja es especialmente curiosa en javascript porque podemos usar corchetes para crear un arreglo. Vean.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Un valor</span></span>
<span class=giallo-l><span style=color:#d27e99>1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Una caja</span></span>
<span class=giallo-l><span style=color:#9cabca>[];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Miren, un valor en una caja</span></span>
<span class=giallo-l><span style=color:#9cabca>[</span><span style=color:#d27e99>1</span><span style=color:#9cabca>];</span></span></code></pre><p>Volviendo a la pregunta, ¿Cómo los reconocemos? Okey, resulta pasa y acontece que hay reglas.<h3 id=las-reglas>Las reglas</h3><p>De nuevo usaré arreglos con números sólo por lo conveniente pero estas reglas deben aplicar a todas aquellas estructuras que deseen ser parte del club functor.<h4 id=identidad>Identidad</h4><p>Dada la función <code>identity</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> identity</span><span style=color:#9cabca>(</span><span>x</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> x</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p><code>value</code> and <code>value.map(identity)</code> deben ser equivalentes.<p>Por ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#9cabca>[</span><span style=color:#d27e99>1</span><span style=color:#9cabca>,</span><span style=color:#d27e99>2</span><span style=color:#9cabca>,</span><span style=color:#d27e99>3</span><span style=color:#9cabca>];</span><span style=color:#727169>               // => [1,2,3]</span></span>
<span class=giallo-l><span style=color:#9cabca>[</span><span style=color:#d27e99>1</span><span style=color:#9cabca>,</span><span style=color:#d27e99>2</span><span style=color:#9cabca>,</span><span style=color:#d27e99>3</span><span style=color:#9cabca>].</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>identity</span><span style=color:#9cabca>);</span><span style=color:#727169> // => [1,2,3]</span></span></code></pre><p>¿Qué? ¿Qué importancia tiene eso? ¿Qué nos dice?<p>Buenas preguntas. Esto nos dice que la función <code>map</code> debe preservar la forma de la estructura. En nuestro ejemplo si aplicamos <code>map</code> a un arreglo de tres elementos debemos recibir un nuevo arreglo con tres elementos. Si fuera un arreglo con cien elementos deberíamos recibir un nuevo arreglo con cien elementos. Ya entienden.<h4 id=composicion>Composición</h4><p>Dadas dos funciones <code>fx</code> y <code>gx</code> lo siguiente debe ser cierto.<p><code>value.map(fx).map(gx)</code> y <code>value.map(arg => gx(fx(arg)))</code> deben ser equivalentes.<p>Otro ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> num</span><span style=color:#e6c384> +</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> num</span><span style=color:#e6c384> *</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#9cabca>[</span><span style=color:#d27e99>1</span><span style=color:#9cabca>].</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>times_two</span><span style=color:#9cabca>);</span><span style=color:#727169>         // => [4]</span></span>
<span class=giallo-l><span style=color:#9cabca>[</span><span style=color:#d27e99>1</span><span style=color:#9cabca>].</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>)));</span><span style=color:#727169> // => [4]</span></span></code></pre><p>Si ya saben como funciona <code>Array.map</code> esto debería ser obvio. Aquí se presenta la oportunidad de optimizar el código para el desempeño o legibilidad. En el caso de los arreglos, múltiples llamadas a <code>map</code> puede tener un gran impacto en el desempeño a medida que vaya creaciendo el número de elementos en la lista.<p>Eso es todo. Esas dos reglas son lo único que deben tener en cuenta para reconocer un functor.<h2 id=tiene-que-ser-map>¿Tiene que ser .map?</h2><p>Supongo que ahora desean saber qué otro tipo de cosas siguen estas reglas que mencioné. Resulta que hay otra estructura bastante popular que sigue estas reglas y esa es <code>Promise</code>. Vean.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Un valor</span></span>
<span class=giallo-l><span style=color:#d27e99>1</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Una caja</span></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#e6c384>resolve</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Miren, un valor en una caja</span></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Identidad</span></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>identity</span><span style=color:#9cabca>);</span><span style=color:#727169> // => 1 (eventualmente)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Composición</span></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>times_two</span><span style=color:#9cabca>);</span><span style=color:#727169>        // => 4</span></span>
<span class=giallo-l><span style=color:#7aa89f>Promise</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>resolve</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>then</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>)));</span><span style=color:#727169> // => 4</span></span></code></pre><p>Si somos honestos aquí, <code>Promise.then</code> se comporta más como <code>Array.flatMap</code> y no como <code>.map</code> pero ignoremos eso.<p>Bien, tenemos <code>Array</code> y tenemos <code>Promise</code> ambos actúan como contenedores y tienen métodos que siguen las reglas. ¿Pero qué pasaría si no existiera <code>Array.map</code>? ¿Significa que <code>Array</code> no es un functor? ¿Perdemos todos los beneficios?<p>Vamos a dar un paso atrás. ¿Si <code>Array.map</code> no existe <code>Array</code> no es un <code>functor</code>? No lo sé. ¿Perdemos todos los beneficios? No, aún podemos tratar los arreglos como un functor, lo que perdemos es la conviniencia de la sintaxis <code>.map</code>. Aún podemos crear nuestro propio <code>map</code> fuera de la estructura.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> List</span><span style=color:#e6c384> =</span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  map</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>,</span><span> arr</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>    let</span><span> result</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [];</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    for</span><span style=color:#9cabca> (</span><span style=color:#957fb8>let</span><span> data</span><span style=color:#e6c384> of</span><span> arr</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span>      result</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>push</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>fn</span><span style=color:#9cabca>(</span><span>data</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l><span style=color:#9cabca>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> result</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span></code></pre><p>¿Ven? No está tan mal. Y funciona.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Identidad</span></span>
<span class=giallo-l><span>List</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>identity</span><span style=color:#9cabca>, [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>]);</span><span style=color:#727169> // => [1]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Composición</span></span>
<span class=giallo-l><span>List</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>times_two</span><span style=color:#9cabca>,</span><span> List</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>, [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>]));</span><span style=color:#727169>   // => [4]</span></span>
<span class=giallo-l><span>List</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>)), [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>]);</span><span style=color:#727169> // => [4]</span></span></code></pre><p>¿Están pensando lo que yo? Probablemente no. Esto es lo que estoy pensando, si podemos crear <code>map</code> para los arreglos entonces nada evita que hagamos uno para los objetos, después de todo, los objetos también son un conjunto de valores.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> Obj</span><span style=color:#e6c384> =</span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  map</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>,</span><span> ob</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>    let</span><span> result</span><span style=color:#e6c384> =</span><span style=color:#9cabca> {};</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    for</span><span style=color:#9cabca> (</span><span style=color:#957fb8>let</span><span style=color:#9cabca> [</span><span>key</span><span style=color:#9cabca>,</span><span> value</span><span style=color:#9cabca>]</span><span style=color:#e6c384> of</span><span> Object</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>entries</span><span style=color:#9cabca>(</span><span>ob</span><span style=color:#9cabca>)) {</span></span>
<span class=giallo-l><span>      result</span><span style=color:#9cabca>[</span><span>key</span><span style=color:#9cabca>]</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> fn</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> result</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// ¿Por qué solo map? </span></span>
<span class=giallo-l><span style=color:#727169>// Basado en esto ya pueden ver cómo crear `filter` y `reduce`</span></span></code></pre><p>Vamos a probar.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Identidad</span></span>
<span class=giallo-l><span>Obj</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>identity</span><span style=color:#9cabca>, {</span><span>some</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>,</span><span> prop</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>});</span><span style=color:#727169> // => {some: 1, prop: 2}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Composición</span></span>
<span class=giallo-l><span>Obj</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>times_two</span><span style=color:#9cabca>,</span><span> Obj</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>, {</span><span>some</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>,</span><span> prop</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>}));</span><span style=color:#727169> // => {some: 4, prop: 6}</span></span>
<span class=giallo-l><span>Obj</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>)), {</span><span>some</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 1</span><span style=color:#9cabca>,</span><span> prop</span><span style=color:#9cabca>:</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>});</span><span style=color:#727169> // => {some: 4, prop: 6}</span></span></code></pre><h2 id=hazlo-tu-mismo>Hazlo tú mismo</h2><p>Toda esta charla de arreglos y objetos es útil pero ahora pienso que sabemos lo suficiente para crear nuestro propio functor, las reglas parecen ser bastante sencillas. Vamos a hacer algo vagamente útil. ¿Alguna vez han escuchado de los Observables? Bien, vamos a hacer algo parecido. Vamos a crear una versión más simple de <a rel="noopener external" href=https://mithril.js.org/stream.html target=_blank>mithril-stream</a>, será divertido.<p>Lo que queremos hacer es manejar un flujo de datos a través del tiempo. La interfaz de nuestra función será esta.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Crear instancia con valor inicial</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> num_stream</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>0</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Crear un flujo dependendiente</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> increased</span><span style=color:#e6c384> =</span><span> num_stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Obtener el valor actual</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 0</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Colocar un nuevo valor en el flujo</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>42</span><span style=color:#9cabca>);</span><span style=color:#727169> // => 42</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// La fuente se actualiza</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 42</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// El dependiente se actualiza</span></span>
<span class=giallo-l><span style=color:#7e9cd8>increased</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 43</span></span></code></pre><p>Empecemos con la función que obtiene y actualiza el valor.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span>state</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  let</span><span style=color:#7e9cd8> stream</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#727169>    // Si tenemos un parametro actualizamos el estado</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    if</span><span style=color:#9cabca>(</span><span style=color:#ff5d62>arguments</span><span style=color:#9cabca>.</span><span>length</span><span style=color:#e6c384> ></span><span style=color:#d27e99> 0</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span>      state</span><span style=color:#e6c384> =</span><span> value</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>    // retorna el estado actual</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> state</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> stream</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Ahora esto debería funcionar.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Inicializamos</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> num_stream</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>42</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Obtenemos el valor</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 42</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Actualizamos</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>73</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Revisamos</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 73</span></span></code></pre><p>Ya sabemos que queremos un método <code>map</code> pero ¿Cuál es el efecto que debe tener? Lo que queremos es que la función (el callback) escuche los cambios de la fuente. Empecemos con eso, lo que haremos será almacenar las funciones proporcionadas a <code>map</code> en un arreglo y las ejecutaremos justo después de que se produzca el cambio.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function Stream(state) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   let listeners = [];</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span></span>
<span class=giallo-l><span>    let stream = function(value) {</span></span>
<span class=giallo-l><span>      if(arguments.length > 0) {</span></span>
<span class=giallo-l><span>        state = value;</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>       listeners.forEach(fn => fn(value));</span></span>
<span class=giallo-l><span>      }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>      return state;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    return stream;</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>Ahora creamos el método <code>map</code>, pero no debe ser un método cualquiera, debemos seguir las reglas.<ul><li><p>Identidad: Cuando <code>map</code> es ejecutado necesita preservar la forma de la estructura. Esto significa que debemos retornar otro <code>stream</code>.</p><li><p>Composición: Ejecutar <code>map</code> varias veces debe ser equivalente a la composición de funciones proporciondas a esas llamadas.</p></ul><pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span>state</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  let</span><span> listeners</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>  let</span><span style=color:#7e9cd8> stream</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    if</span><span style=color:#9cabca>(</span><span style=color:#ff5d62>arguments</span><span style=color:#9cabca>.</span><span>length</span><span style=color:#e6c384> ></span><span style=color:#d27e99> 0</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span>      state</span><span style=color:#e6c384> =</span><span> value</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span>      listeners</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>forEach</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> fn</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l><span style=color:#9cabca>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> state</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>fn</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#727169>    // Crea una nueva instancia con el valor transformado.</span></span>
<span class=giallo-l><span style=color:#727169>    // Esto ejecutara `fn` cuando se llame a `map`</span></span>
<span class=giallo-l><span style=color:#727169>    // esto no siempre será lo mejor si `fn` tiene algún </span></span>
<span class=giallo-l><span style=color:#727169>    // efecto fuera de su ámbito. Tengan cuidado.</span></span>
<span class=giallo-l><span style=color:#957fb8>    let</span><span> target</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>fn</span><span style=color:#9cabca>(</span><span>state</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>    // Transforma el valor y actualiza el nuevo flujo</span></span>
<span class=giallo-l><span style=color:#957fb8>    const</span><span style=color:#7e9cd8> listener</span><span style=color:#e6c384> =</span><span> value</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> target</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>fn</span><span style=color:#9cabca>(</span><span>value</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>    // Actualiza los dependientes de la fuente</span></span>
<span class=giallo-l><span>    listeners</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>push</span><span style=color:#9cabca>(</span><span>listener</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> target</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> stream</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Probemos las reglas. Comenzamos con identidad.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Los `Stream` son como una cascada</span></span>
<span class=giallo-l><span style=color:#727169>// el primero es el más importante</span></span>
<span class=giallo-l><span style=color:#727169>// este es el que activa los demás</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> num_stream</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>0</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Crea el dependendiente</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> identity_stream</span><span style=color:#e6c384> =</span><span> num_stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>identity</span><span style=color:#9cabca>);</span><span> </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Actualiza la fuente</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>42</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Revisa</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>();</span><span style=color:#727169>      // => 42</span></span>
<span class=giallo-l><span style=color:#7e9cd8>identity_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 42</span></span></code></pre><p>Ahora la composición.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Crea la fuente</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> num_stream</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>0</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Crea los dependientes</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> map_stream</span><span style=color:#e6c384> =</span><span> num_stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>add_one</span><span style=color:#9cabca>).</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>times_two</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> composed_stream</span><span style=color:#e6c384> =</span><span> num_stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#957fb8> =></span><span style=color:#7e9cd8> times_two</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>add_one</span><span style=color:#9cabca>(</span><span>num</span><span style=color:#9cabca>)));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Actualiza</span></span>
<span class=giallo-l><span style=color:#7e9cd8>num_stream</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Revisa</span></span>
<span class=giallo-l><span style=color:#7e9cd8>map_stream</span><span style=color:#9cabca>();</span><span style=color:#727169>      // => 4</span></span>
<span class=giallo-l><span style=color:#7e9cd8>composed_stream</span><span style=color:#9cabca>();</span><span style=color:#727169> // => 4</span></span></code></pre><p>Nuestro trabajo está hecho. ¿Pero de verdad sirve? ¿Se puede hacer algo con eso? Bueno, sí, pueden usarlo para manejar eventos. Así.<p data-pen-title="an fmap example" style="box-sizing:border-box;border:2px solid;justify-content:center;align-items:center;height:600px;margin:1em 0;padding:1em;display:flex" class=codepen data-default-tab=js,result data-height=600 data-preview=true data-slug-hash=dyoMJRw data-theme-id=dark data-user=VonHeikemen><span> See the Pen <a href=https://codepen.io/VonHeikemen/pen/dyoMJRw>an fmap example</a> by Heiker (<a href=https://codepen.io/VonHeikemen>@VonHeikemen</a>) on <a href=https://codepen.io>CodePen</a>. </span></p><script async src=https://static.codepen.io/assets/embed/ei.js></script><h3 id=mas-ejemplos>Más ejemplos</h3><p>Ahora ya deben tener un buen entendimiento de los functors, pero si quieren seguir viendo más pueden revisar estos artículos.<ul><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/using-a-maybe/>Manejar ausencia de valores</a><li><a rel="noopener external" href=https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/ target=_blank>Manejo de efectos secundarios</a> (inglés)</ul><h2 id=conclusion>Conclusión</h2><p>Lo único que queda por responser es "¿Qué beneficios tienen los functors?"<ul><li><p>Este patrón nos permite enfocarnos en un problema a la vez. La función <code>map</code> se encarga de obtener los datos necesarios y en el <code>callback</code> nos podemos enfocar en cómo procesarlos.</p><li><p>Reutilización. Este estilo de programación promueve el uso y creación de funciones de generales que sólo se encargan de una tarea, en muchos casos estas pueden ser compartidas incluso entre proyectos.</p><li><p>Extensión a través de la composición. Hay gente que tiene sentimientos encontrados en este caso, especialmente si hablamos de aplicarlo a los arreglos. Pero lo que quiero decir es que los functors promueven el uso de cadenas de funciones para implementar un procedimiento.</p></ul><h2 id=fuentes>Fuentes</h2><ul><li><a rel="noopener external" href=https://dev.to/techgirl1908/why-is-map-called-map-2l03 target=_blank>Why is map called map?</a><li><a rel="noopener external" href=https://github.com/fantasyland/fantasy-land target=_blank>Fantasy land</a><li><a rel="noopener external" href=https://github.com/fantasyland/static-land target=_blank>Static land</a><li><a rel="noopener external" href=https://github.com/thefrontside/funcadelic.js target=_blank>funcadelic.js</a><li><a rel="noopener external" href=https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/ target=_blank>How to deal with dirty side effects in your pure functional JavaScript</a><li><a rel="noopener external" href=https://jrsinclair.com/articles/2020/whats-more-fantastic-than-fantasy-land-static-land/ target=_blank>What’s more fantastic than fantasy land? An Introduction to Static land</a><li><a rel="noopener external" href=https://medium.com/@lettier/your-easy-guide-to-monads-applicatives-functors-862048d61610 target=_blank>Your easy guide to Monads, Applicatives, & Functors</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/un-poco-del-paradigma-funcional-en-tu-javascript-los-poderes-de-map-473i rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/the-power-of-map-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>