<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Devlog | Un poco del paradigma funcional en tu javascript: Técnicas de composición</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="javascript,paradigma-funcional,aprendizaje,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Una introducción a los patrones comúnes usados en la programación funcional"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>Whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2021 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Un poco del paradigma funcional en tu javascript: Técnicas de composición</h1><span class=post-date>2020-03-29
| <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/composition-techniques/>Read in english</a></span><p>Hoy el tema será la composición de funciones. El arte de crear cosas complejas con piezas "simples". Si no saben nada del paradigma funcional en la programación incluso mejor, esta será una introducción a conceptos y patrones de ese paradigma que pueden implementarse en javascript. Lo que voy a presentar no será una fórmula mágica que hará su código más legible, simple y sin errores; así no funcionan las cosas. Sí creo que ayuda en la solución de problemas pero para sacarle el mayor provecho deben tener en cuenta ciertas cosas. Así que antes de mostrar cualquier implementación vamos a hablar de algunos conceptos y filosofía.<h2 id=lo-que-deben-saber>Lo que deben saber</h2><h3 id=que-es-la-composicion-de-funciones>¿Qué es la composición de funciones?</h3><p>Es un mecanismo que nos permite combinar dos o más funciones en una nueva función.<p>Parece una idea simple, ciertamente todos en algún momento hemos combinado un par de funciones ¿De verdad pensamos en la composición cuando creamos una función? ¿Qué nos ayudaría a crear funciones diseñadas para ser combinadas?<h3 id=filosofia>Filosofía</h3><p>Repito, la composición de funciones es más efectiva si siguen ciertos principios.<ul><li>La función tiene un sólo propósito, una sola responsabilidad.<li>Asume que el resultado de la función será consumido por otra.</ul><p>Probablemente han escuchado eso en algún otro lado, es parte de la <a href=https://en.wikipedia.org/wiki/Unix_philosophy#Origin>filosofía unix</a>. ¿Alguna vez se han preguntado cómo un lenguage como <code>bash</code>, que tiene una sintaxis un tanto extraña y muchas limitaciones, puede ser tan popular? Esos dos principios son parte de la razón. Una gran parte de los programas que se ejecutan en este ambiente están diseñados para ser componentes reusables y cuando "conectas" dos o más, el resultado es un programa que también puede ser conectado con otros programas aún no conocidos.<p>Para algunos puede parecer tonto o incluso exagerado tener muchas funciones que solo hacen una cosa, especialmente si esas funciones hacen algo que parece inútil, pero puedo demostrarles que cada función puede ser valiosa en el contexto adecuado.<p>Intentemos ilustrar una situación donde estos principios se ponen en práctica.<blockquote><p>Nota: De antemano me disculpo por el uso indebido de los comandos <code>cat</code> y <code>grep</code>, esto lo hago para demostrar el valor de la composición.</blockquote><p>Digamos que queremos extraer el valor de la variable <code>HOST</code> que está en un archivo <code>.env</code>, vamos a hacerlo usando <code>bash</code>.<p>Este sería el archivo.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>ENV=development
HOST=http://locahost:5000
</span></code></pre><p>Para mostrar el contenido de ese archivo usamos <code>cat</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cat .env
</span></code></pre><p>Para filtrar el contenido del archivo y buscar la línea que queremos usamos <code>grep</code>, le proveemos el patrón que buscamos y el contenido del archivo.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cat .env </span><span style=color:#5fb3b3>| </span><span style=color:#69c>grep </span><span style=color:#5fb3b3>&quot;</span><span style=color:#99c794>HOST=.*</span><span style=color:#5fb3b3>&quot;
</span></code></pre><p>Para obtener el valor que queremos usamos <code>cut</code>. El comando <code>cut</code> va a tomar el resultado de <code>grep</code> y lo va a dividir usando un delimitador, luego le decimos qué sección de la cadena queremos.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cat .env </span><span style=color:#5fb3b3>| </span><span style=color:#69c>grep </span><span style=color:#5fb3b3>&quot;</span><span style=color:#99c794>HOST=.*</span><span style=color:#5fb3b3>&quot; | </span><span style=color:#69c>cut</span><span style=color:#5fb3b3> --</span><span style=color:#f99157>delimiter</span><span style=color:#5fb3b3>=&quot;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&quot; --</span><span style=color:#f99157>fields</span><span style=color:#5fb3b3>=</span><span style=color:#69c>2
</span></code></pre><p>Eso debería mostrarnos.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>http://locahost:5000
</span></code></pre><p>Si colocamos esa cadena de comandos en un script o una función en nuestro <code>.bashrc</code> efectivamente tendremos un comando que puede ser usado de la misma manera por otros programas que aún no conocemos. Este es el tipo de flexibilidad y poder que queremos lograr.<p>Espero que en este punto sepan qué tipo de mentalidad debemos tener al momento de crear una función pero aún hay una cosa que deben recordar.<h3 id=las-funciones-son-cosas>Las funciones son cosas</h3><p>Pongamos nuestra atención en javascript. ¿Han escuchado la frase "funciones de primera clase"? Significa que las funciones pueden ser tratadas como cualquier otro valor. Vamos a compararlos con los arreglos.<ul><li>Pueden asignarlos a una variable.</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>numbers </span><span style=color:#5fb3b3>= [&#39;</span><span style=color:#99c794>99</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>104</span><span style=color:#5fb3b3>&#39;];
</span><span style=color:#c594c5>const </span><span style=color:#cccece>repeat_twice </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>repeat</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>);
};
</span></code></pre><ul><li>Pasarlos como argumento a una función.</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>array</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>);
}

</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>repeat_twice</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>numbers</span><span style=color:#5fb3b3>);
</span></code></pre><ul><li>Pueden ser retornados por una función</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>unary</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) {
    </span><span style=color:#c594c5>return </span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>arg</span><span style=color:#5fb3b3>);
  }
}

</span><span style=color:#c594c5>const </span><span style=color:#cccece>safer_parseint </span><span style=color:#5fb3b3>= </span><span style=color:#69c>unary</span><span style=color:#5fb3b3>(</span><span style=color:#69c>parseInt</span><span style=color:#5fb3b3>);

</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>safer_parseint</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>numbers</span><span style=color:#5fb3b3>);
</span></code></pre><p>¿Por qué les muestro esto? Deben estar conscientes de esta característica de javascript porque vamos a usarla crear funciones auxiliares, como <code>unary</code>, que manipulan otras funciones. Puede que tome un tiempo acostumbrarse a la idea de tratar las funciones como un dato pero definitivamente vale la pena practicarlo ya que es clave para entender muchos de los patrones que se pueden ver en el paradigma funcional.<h2 id=composicion-en-la-practica>Composición en la práctica</h2><p>Vamos a retomar el ejemplo del archivo <code>.env</code>. Recrearemos lo que hicimos en <code>bash</code>. Primero vamos a intentar un enfoque muy directo, luego exploraremos los defectos de nuestra implementación e intentaremos solucionarlos.<p>Ya hemos hecho esto antes, sabemos lo que debemos hacer. Empecemos por crear una función por cada paso.<ul><li>Extraer el contenido del archivo.</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>fs </span><span style=color:#5fb3b3>= </span><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>fs</span><span style=color:#5fb3b3>&#39;);

</span><span style=color:#c594c5>function </span><span style=color:#69c>get_env</span><span style=color:#5fb3b3>() {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>fs</span><span style=color:#5fb3b3>.</span><span style=color:#69c>readFileSync</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>utf-8</span><span style=color:#5fb3b3>&#39;);
}
</span></code></pre><ul><li>Filtrar el contenido basados en un patrón.</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>search_host</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>content</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>const </span><span style=color:#cccece>exp </span><span style=color:#5fb3b3>= new </span><span style=color:#fac863>RegExp</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;);
  </span><span style=color:#c594c5>const </span><span style=color:#cccece>lines </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split</span><span style=color:#5fb3b3>(&#39;\n&#39;);

  </span><span style=color:#c594c5>return </span><span style=color:#cccece>lines</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>line </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>exp</span><span style=color:#5fb3b3>.</span><span style=color:#69c>test</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>line</span><span style=color:#5fb3b3>));
}
</span></code></pre><ul><li>Extraer el valor.</ul><pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>get_value</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;)[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>];
}
</span></code></pre><p>Ya estamos listos. Veamos qué podemos hacer para que estas funciones trabajen juntas.<h3 id=composicion-natural>Composición natural</h3><p>Mencioné que el primer intento sería un enfoque directo, las funciones ya están listas y lo que queda por hacer es ejecutarlas en secuencia.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>get_value</span><span style=color:#5fb3b3>(</span><span style=color:#69c>search_host</span><span style=color:#5fb3b3>(</span><span style=color:#69c>get_env</span><span style=color:#5fb3b3>()));
</span></code></pre><p>Digamos que este es el escenario perfecto de una composición de funciones, aquí el resultado de una función se convierte en la entrada de la siguiente, es el mismo efecto que tiene el símbolo <code>|</code> en <code>bash</code>. A diferencia de <code>bash</code> aquí el flujo de datos va de derecha a izquierda.<p>Ahora imaginemos que tenemos dos funciones más que hacen algo con el valor de <code>HOST</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>test</span><span style=color:#5fb3b3>(</span><span style=color:#69c>ping</span><span style=color:#5fb3b3>(</span><span style=color:#69c>get_value</span><span style=color:#5fb3b3>(</span><span style=color:#69c>search_host</span><span style=color:#5fb3b3>(</span><span style=color:#69c>get_env</span><span style=color:#5fb3b3>()))));
</span></code></pre><p>Las cosas se ponen algo incómodas, todavía esta en un nivel manejable pero la cantidad de paréntesis involucrados ya empieza a molestar. Este sería el momento perfecto para crear una función que agrupe esta cadena en una manera más legible, pero no haremos eso aún, primero buscaremos ayuda.<h3 id=composicion-automatica>Composición automática</h3><p>Es aquí donde nuestros conocimientos de las funciones empieza a dar frutos. Lo que haremos para resolver el problema de los paréntesis será "automatizar" las llamadas de las funciones. Crearemos una función que acepte una lista de funciones, las ejecute una por una y se asegure de pasar el resultado de la función anterior como parémetro a la siguiente.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>compose</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return function </span><span style=color:#69c>_composed</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
    </span><span style=color:#5f6364>// Posición de la última función
    </span><span style=color:#c594c5>let </span><span style=color:#cccece>last </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>length </span><span style=color:#5fb3b3>- </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;

    </span><span style=color:#5f6364>// Se ejecuta la última función
    // con los parámetros de `_composed`
    </span><span style=color:#c594c5>let </span><span style=color:#cccece>current_value </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>[</span><span style=color:#cccece>last</span><span style=color:#5fb3b3>--](...</span><span style=color:#cccece>args</span><span style=color:#5fb3b3>);

    </span><span style=color:#5f6364>// recorremos las funciones restantes en orden inverso
    </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>let </span><span style=color:#cccece>i </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>last</span><span style=color:#5fb3b3>; </span><span style=color:#cccece>i </span><span style=color:#5fb3b3>&gt;= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>; </span><span style=color:#cccece>i</span><span style=color:#5fb3b3>--) {
      </span><span style=color:#cccece>current_value </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>[</span><span style=color:#cccece>i</span><span style=color:#5fb3b3>](</span><span style=color:#cccece>current_value</span><span style=color:#5fb3b3>);
    }

    </span><span style=color:#c594c5>return </span><span style=color:#cccece>current_value</span><span style=color:#5fb3b3>;
  };
}
</span></code></pre><p>Ahora podremos hacer esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>get_value</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>search_host</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>get_env</span><span style=color:#5fb3b3>);

</span><span style=color:#5f6364>// get_host en realidad es `_composed`
</span><span style=color:#69c>get_host</span><span style=color:#5fb3b3>();
</span></code></pre><p>Ya no tenemos el problema de los paréntesis, podemos agregar más funciones de manera más fácil y sin entorpecer la legilibilidad.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span style=color:#5fb3b3>(
  </span><span style=color:#cccece>test</span><span style=color:#5fb3b3>,
  </span><span style=color:#cccece>ping</span><span style=color:#5fb3b3>,
  </span><span style=color:#cccece>get_value</span><span style=color:#5fb3b3>,
  </span><span style=color:#cccece>search_host</span><span style=color:#5fb3b3>,
  </span><span style=color:#cccece>get_env
</span><span style=color:#5fb3b3>);

</span><span style=color:#69c>get_host</span><span style=color:#5fb3b3>();
</span></code></pre><p>Como en nuestro primer intento el flujo de ejecución va de derecha a izquierda. Si prefieren invertir el orden sería así.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return function </span><span style=color:#69c>_piped</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
    </span><span style=color:#5f6364>// Se ejecuta la primera función
    // con los parámetros de `_piped`
    </span><span style=color:#c594c5>let </span><span style=color:#cccece>current_value </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>0</span><span style=color:#5fb3b3>](...</span><span style=color:#cccece>args</span><span style=color:#5fb3b3>);

    </span><span style=color:#5f6364>// recorremos las funciones restantes en el orden original
    </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>let </span><span style=color:#cccece>i </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>; </span><span style=color:#cccece>i </span><span style=color:#5fb3b3>&lt; </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>length</span><span style=color:#5fb3b3>; </span><span style=color:#cccece>i</span><span style=color:#5fb3b3>++) {
      </span><span style=color:#cccece>current_value </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>fns</span><span style=color:#5fb3b3>[</span><span style=color:#cccece>i</span><span style=color:#5fb3b3>](</span><span style=color:#cccece>current_value</span><span style=color:#5fb3b3>);
    }

    </span><span style=color:#c594c5>return </span><span style=color:#cccece>current_value</span><span style=color:#5fb3b3>;
  };
}
</span></code></pre><p>Ahora pueden leerlo así.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>get_env</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>search_host</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>get_value</span><span style=color:#5fb3b3>);

</span><span style=color:#69c>get_host</span><span style=color:#5fb3b3>();
</span></code></pre><p>Todo esto es genial, pero como dije antes lo que tenemos aquí es un escenario ideal. Nuestra composición sólo puede manejar funciones que tienen un parámetro de entrada y una sola línea de ejecución (no necesita controlar el flujo de ejecución). Eso no es malo, todos deberíamos diseñar nuestro código para facilitar ese tipo de situaciones pero como todos sabemos...<h3 id=no-siempre-es-tan-facil>No siempre es tan fácil</h3><p>Incluso en nuestro ejemplo la única razón por la que logramos combinar las funciones fue porque incluimos en el código todos los parámetros necesarios e ignoramos el manejo de errores. Pero no todo está perdido, hay formas de sobrepasar las limitaciones que tenemos.<p>Antes de continuar modificaremos el ejemplo, haremos que sea más parecido a la implementación en <code>bash</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>fs </span><span style=color:#5fb3b3>= </span><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>fs</span><span style=color:#5fb3b3>&#39;);

</span><span style=color:#c594c5>function </span><span style=color:#69c>cat</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>filepath</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>fs</span><span style=color:#5fb3b3>.</span><span style=color:#69c>readFileSync</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>filepath</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>utf-8</span><span style=color:#5fb3b3>&#39;);
}

</span><span style=color:#c594c5>function </span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>pattern</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>content</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>const </span><span style=color:#cccece>exp </span><span style=color:#5fb3b3>= new </span><span style=color:#fac863>RegExp</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>pattern</span><span style=color:#5fb3b3>);
  </span><span style=color:#c594c5>const </span><span style=color:#cccece>lines </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split</span><span style=color:#5fb3b3>(&#39;\n&#39;);

  </span><span style=color:#c594c5>return </span><span style=color:#cccece>lines</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>line </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>exp</span><span style=color:#5fb3b3>.</span><span style=color:#69c>test</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>line</span><span style=color:#5fb3b3>));
}

</span><span style=color:#c594c5>function </span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#f99157>delimiter</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fields </span><span style=color:#5fb3b3>}, </span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>delimiter</span><span style=color:#5fb3b3>)[</span><span style=color:#cccece>fields </span><span style=color:#5fb3b3>- </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>];
}
</span></code></pre><p>No es exactamente lo mismo que sus contrapartes en <code>bash</code> pero servirá. Ahora, si quisieramos combinar estas nuevas funciones tendríamos que hacerlo de esta manera.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cut</span><span style=color:#5fb3b3>({</span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>}, </span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)));
</span></code></pre><p>Funciona pero yo diría que está al borde de lo aceptable, aún puedo entender lo que está pasando pero no querría agregar otra cosa a esa cadena. Si queremos usar <code>pipe</code> tendremos que superar nuestro primer obstáculo.<h4 id=funciones-con-multiples-entradas>Funciones con múltiples entradas</h4><p>La solución a esto es <strong>aplicación parcial</strong> y por suerte para nosotros javascript tiene un buen soporte incluido para lo que queremos hacer. Nuestro objetivo es simple, pasarle a una función una parte de sus parámetros sin ejecutarla. Queremos ser capaces de hacer algo así.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(
  </span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>,
  </span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;), 
  </span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>})
);

</span><span style=color:#69c>get_host</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;);
</span></code></pre><p>Para replicar este resultado tendremos que recurrir a una técnica llamada <strong>currying</strong>, esta consiste en convertir una función de múltiples parámetros en varias funciones de un parámetro. Bien, para lograrlo lo que debemos hacer es aceptar un parámetro a la vez devolviendo una función por cada parámetro que necesitamos. Haremos esto con <code>grep</code> y <code>cut</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> function grep(pattern, content) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> function grep(pattern) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   return function(content) {
</span><span style=color:#cccece>      const exp = new RegExp(pattern);
      const lines = content.split(&#39;\n&#39;);
 
      return lines.find(line =&gt; exp.test(line));
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span style=color:#cccece>  }

</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> function cut({ delimiter, fields }, str) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> function cut({ delimiter, fields }) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   return function(str) {
</span><span style=color:#cccece>      return str.split(delimiter)[fields - 1];
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span style=color:#cccece>  }
</span></code></pre><p>En situaciones donde no es posible convertir una función normal a una que soporte currying lo que podemos hacer es usar el método <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind>bind</a> que se encuentra en el prototipo de la funciones.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(
  </span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>,
  </span><span style=color:#cccece>grep</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;), 
  </span><span style=color:#cccece>cut</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, { </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>})
);
</span></code></pre><p>Por último, si todo lo demás parece muy complicado siempre tenemos la opción de crear una función anónima justo en el lugar.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(
  </span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>,
  </span><span style=color:#f99157>content </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#cccece>content</span><span style=color:#5fb3b3>), 
  </span><span style=color:#f99157>str </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>}, </span><span style=color:#cccece>str</span><span style=color:#5fb3b3>)
);
</span></code></pre><p>Eso será suficiente para resolver cualquier tipo de problema con funciones que aceptan múltiples parámetros. Sigamos.<h4 id=funciones-con-multiples-salidas>Funciones con múltiples salidas</h4><p>¿Múltiples salidas? Con eso me refiero a funciones que retornan dos (tal vez más) tipos de resultados. Esto pasa en funciones que tienen distintos tipos de respuesta dependiendo de cómo las usemos o el contexto donde las usamos. Tenemos ese tipo de funciones en nuestro ejemplo, veamos <code>cat</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>cat</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>filepath</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>fs</span><span style=color:#5fb3b3>.</span><span style=color:#69c>readFileSync</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>filepath</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>utf-8</span><span style=color:#5fb3b3>&#39;);
}
</span></code></pre><p>Dentro de <code>cat</code> está la función <code>readFileSync</code>, es la que se encarga de leer el archivo en nuestro sistema, la cual es una operación que puede fallar por muchas razones. Entonces <code>cat</code> puede devolver un <code>String</code> si todo sale bien pero también puede arrojar un error si algo malo ocurre. Tenemos que manejar estos dos casos.<p>Desafortunadamente para nosotros las excepciones no son lo único con lo que tenemos que lidiar, también tenemos que manejar la ausencia de valores. En la función <code>grep</code> tenemos esta línea.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>lines</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>line </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>exp</span><span style=color:#5fb3b3>.</span><span style=color:#69c>test</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>line</span><span style=color:#5fb3b3>));
</span></code></pre><p>El método <code>find</code> se encarga de evaluar cada línea del contenido del archivo. Como pueden imaginar esta operación también puede fallar, simplemente puede darse el caso de que no encuentre el valor que buscamos. A diferencia de <code>readFileSync</code> el método <code>find</code> no arroja un error, lo que hace es retornar <code>undefined</code>. De por sí <code>undefined</code> no es malo, es sólo que no tenemos ninguna utilidad para él. Asumir que el resultado siempre será de tipo <code>String</code> es lo que en definitiva causará un error.<p>¿Cúal es la solución?<p><strong>Functors</strong> && <strong>Monads</strong> (me disculpan las palabrotas). Dar una explicación apropiada de esos conceptos toma tiempo así que sólo vamos a enfocarnos en lo que nos interesa. Por los momentos pueden pensar en ellos como estructuras que siguen ciertas reglas (pueden encontrar algunas de ellas aquí: <a href=https://github.com/fantasyland/fantasy-land#fantasy-land-specification>Fantasy land</a>).<p>¿Cómo empezamos? Empecemos con los functors.<ul><li>Functors</ul><p>Vamos a crear una estructura que sea capaz de ejecutar una función en el momento adecuado. Ya se han encontrado con una que puede hacer eso: los arreglos. Intenten esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>add_one </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>num </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>num </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#cccece>number </span><span style=color:#5fb3b3>= [</span><span style=color:#f99157>41</span><span style=color:#5fb3b3>];
</span><span style=color:#c594c5>const </span><span style=color:#cccece>empty </span><span style=color:#5fb3b3>= [];

</span><span style=color:#cccece>number</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>add_one</span><span style=color:#5fb3b3>); </span><span style=color:#5f6364>// =&gt; [42]
</span><span style=color:#cccece>empty</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>add_one</span><span style=color:#5fb3b3>);  </span><span style=color:#5f6364>// =&gt; []
</span></code></pre><p>¿Se dieron cuenta? <code>map</code> ejecutó <code>add_one</code> sólo una vez, con el arreglo <code>number</code>. No hizo nada en el arreglo vacío, no detuvo la ejecución del programa arrojando un error, sólo devolvió un arreglo. Ese es el tipo de comportamiento que queremos.<p>Repliquemos esto por nuestra cuenta. Vamos a crear una estructura llamada <code>Result</code>, esta representará una operación que puede o no tener éxito. Tendrá un método <code>map</code> que sólo ejecutará la función que recibe como parámetro si la operación resulta exitosa.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>Result </span><span style=color:#5fb3b3>= {};

</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>Ok </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
    </span><span style=color:#69c>map</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span style=color:#5fb3b3>(</span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>)),
  };
}

</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>Err </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
    </span><span style=color:#69c>map</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>),
  };
}
</span></code></pre><p>Tenemos nuestro functor pero ahora se podrían estar preguntando ¿Es todo, cómo nos ayuda eso? Lo estamos haciendo un paso a la vez. Usemos lo que tenemos en <code>cat</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>function </span><span style=color:#69c>cat</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>filepath</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>try </span><span style=color:#5fb3b3>{
    </span><span style=color:#c594c5>return </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>fs</span><span style=color:#5fb3b3>.</span><span style=color:#69c>readFileSync</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>filepath</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>utf-8</span><span style=color:#5fb3b3>&#39;));
  } </span><span style=color:#c594c5>catch</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>e</span><span style=color:#5fb3b3>) {
    </span><span style=color:#c594c5>return </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>e</span><span style=color:#5fb3b3>);
  }
}
</span></code></pre><p>¿Qué ganamos? Intenten esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;).</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>);
</span></code></pre><p>Todavía tienen la misma pregunta en su mente, puedo verlo. Ahora intenten incorporar el resto de las funciones.<blockquote><p>Nota: Voy a asumir que pueden usar currying para lograr la aplicación parcial de los parámetros.</blockquote><pre style=background-color:#2b2c2f>
<code><span style=color:#69c>cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>}))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>);
</span></code></pre><p>¿Vieron? Esa cadena de <code>map</code>s se parece mucho a <code>compose</code> y <code>pipe</code>. Logramos recuperar la composición y le incorporamos manejo de errores (casi).<p>Quiero hacer algo. Ese patrón que hicimos en el <code>try/catch</code> parece útil, podríamos extraerlo a una función.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>make_safe </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return function</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
    </span><span style=color:#c594c5>try </span><span style=color:#5fb3b3>{
      </span><span style=color:#c594c5>return </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span style=color:#5fb3b3>(</span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(...</span><span style=color:#cccece>args</span><span style=color:#5fb3b3>));
    } </span><span style=color:#c594c5>catch</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>e</span><span style=color:#5fb3b3>) {
      </span><span style=color:#c594c5>return </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>e</span><span style=color:#5fb3b3>);
    }
  }
 }
</span></code></pre><p>Ahora podemos transformar <code>cat</code> sin siquiera tocar su código.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>safer_cat </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>make_safe</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>);

</span><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>}))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>);
</span></code></pre><p>Tal vez quieran hacer algo en caso de error, ¿cierto? Hagamos que sea posible.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>  const Result = {};
 
  Result.Ok = function(value) {
    return {
      map: fn =&gt; Result.Ok(fn(value)),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     catchMap: () =&gt; Result.Ok(value),
</span><span style=color:#cccece>    };
  }
 
  Result.Err = function(value) {
    return {
      map: () =&gt; Result.Err(value),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     catchMap: fn =&gt; Result.Err(fn(value)),
</span><span style=color:#cccece>    };
  }
</span></code></pre><p>Ahora podemos equivocarnos con confianza.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>safer_cat </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>make_safe</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>const </span><span style=color:#cccece>show_error </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>e </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>error</span><span style=color:#5fb3b3>(`</span><span style=color:#99c794>Whoops:</span><span style=color:#5fb3b3>\n${</span><span style=color:#cccece>e</span><span style=color:#5fb3b3>.</span><span style=color:#69c>message</span><span style=color:#5fb3b3>}`);

</span><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>what?</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>}))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>show_error</span><span style=color:#5fb3b3>);
</span></code></pre><p>Sí, lo sé, todo es muy bonito y útil pero en algún momento van a querer sacar el valor del <code>Result</code>. Entiendo, javascript no es un lenguaje hecho para este tipo de cosas, van a querer "volver a la normalidad". Agregaremos una función que nos de la libertad de extraer el valor en cualquier caso.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>  const Result = {};
 
  Result.Ok = function(value) {
    return {
      map: fn =&gt; Result.Ok(fn(value)),
      catchMap: () =&gt; Result.Ok(value),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     cata: (error, success) =&gt; success(value)
</span><span style=color:#cccece>    };
  }
 
  Result.Err = function(value) {
    return {
      map: () =&gt; Result.Err(value),
      catchMap: fn =&gt; Result.Err(fn(value)),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     cata: (error, success) =&gt; error(value)
</span><span style=color:#cccece>    };
  }
</span></code></pre><p>Con esto podremos elegir qué hacer al final de la operación.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>constant </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>arg</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#cccece>identity </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>arg</span><span style=color:#5fb3b3>;

</span><span style=color:#c594c5>const </span><span style=color:#cccece>host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>what?</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({ </span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>}))
  .</span><span style=color:#69c>cata</span><span style=color:#5fb3b3>(</span><span style=color:#69c>constant</span><span style=color:#5fb3b3>(&quot;</span><span style=color:#99c794>This ain&#39;t right</span><span style=color:#5fb3b3>&quot;), </span><span style=color:#cccece>identity</span><span style=color:#5fb3b3>)

</span><span style=color:#5f6364>// ....
</span></code></pre><blockquote><p>Nota: Si se preguntan por qué <code>cata</code>, viene de la palabra <strong>catamorfismo</strong>, otro de esos términos de teoría de categoría que algunos usan en el paradigma funcional.</blockquote><p>Ahora vamos a crear una estructura que nos permita resolver el problema que tenemos con <code>grep</code>. En este caso lo que tenemos que hacer es manejar la ausencia de un valor.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>Maybe </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>if</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value </span><span style=color:#5fb3b3>== </span><span style=color:#f99157>null</span><span style=color:#5fb3b3>) {
    </span><span style=color:#c594c5>return </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Nothing</span><span style=color:#5fb3b3>();
  }

  </span><span style=color:#c594c5>return </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Just</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>);
}

</span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>Just </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
    </span><span style=color:#69c>map</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Just</span><span style=color:#5fb3b3>(</span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>)),
    </span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Just</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>),
    </span><span style=color:#69c>cata</span><span style=color:#5fb3b3>: (</span><span style=color:#f99157>nothing</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>just</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>just</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>value</span><span style=color:#5fb3b3>)
  };
}

</span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>Nothing </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() {
  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
    </span><span style=color:#69c>map</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Nothing</span><span style=color:#5fb3b3>(),
    </span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(),
    </span><span style=color:#69c>cata</span><span style=color:#5fb3b3>: (</span><span style=color:#f99157>nothing</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>just</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>nothing</span><span style=color:#5fb3b3>()
  };
}

</span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>wrap_fun </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) {
  </span><span style=color:#c594c5>return function</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
    </span><span style=color:#c594c5>return </span><span style=color:#69c>Maybe</span><span style=color:#5fb3b3>(</span><span style=color:#69c>fn</span><span style=color:#5fb3b3>(...</span><span style=color:#cccece>args</span><span style=color:#5fb3b3>));
  }
}
</span></code></pre><p>Vamos a envolver <code>grep</code> con un <code>Maybe</code> y probaremos si funciona usando el <code>cat</code> original para extraer el contenido del archivo.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>maybe_host </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>wrap_fun</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;));

</span><span style=color:#69c>maybe_host</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;))
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>(() </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>Nothing()</span><span style=color:#5fb3b3>&#39;));
</span></code></pre><p>Eso debería mostrar <code>http://locahost:5000</code>. Y si cambian el patrón <code>^HOST=</code> debería mostrar <code>Nothing()</code>.<p>Tenemos versiones más seguras de <code>cat</code> y <code>grep</code> pero vean lo que pasa cuando se juntan.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>maybe_host</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>res </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>({ </span><span style=color:#cccece>res </span><span style=color:#5fb3b3>}));
  .</span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>(() </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>what?</span><span style=color:#5fb3b3>&#39;))
</span></code></pre><p>Obtienen esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>{
  res: {
    map: [Function: map],
    catchMap: [Function: catchMap],
    cata: [Function: cata]
  }
}
</span></code></pre><p>¿Qué está pasando? Bueno, hay un <code>Maybe</code> atrapado dentro de un <code>Result</code>. Tal vez ustedes no esperaban eso pero otras personas sí, y ellas ya tienen las solución.<ul><li>Monads</ul><p>Resulta que los monads son functors con poderes extra. Lo que nos interesa saber por el momento es que resuelven el problema de las estructuras anidadas. Hagamos los ajustes pertinentes.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>  Result.Ok = function(value) {
    return {
      map: fn =&gt; Result.Ok(fn(value)),
      catchMap: () =&gt; Result.Ok(value),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     flatMap: fn =&gt; fn(value),
</span><span style=color:#cccece>      cata: (error, success) =&gt; success(value)
    };
  }

  Result.Err = function(value) {
    return {
      map: () =&gt; Result.Err(value),
      catchMap: fn =&gt; Result.Err(fn(value)),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     flatMap: () =&gt; Result.Err(value),
</span><span style=color:#cccece>      cata: (error, success) =&gt; error(value)
    };
  }
</span></code></pre><pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>  Maybe.Just = function(value) {
    return {
      map: fn =&gt; Maybe.Just(fn(value)),
      catchMap: () =&gt; Maybe.Just(value),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     flatMap: fn =&gt; fn(value),
</span><span style=color:#cccece>      cata: (nothing, just) =&gt; just(value),
    };
  }

  Maybe.Nothing = function() {
    return {
      map: () =&gt; Maybe.Nothing(),
      catchMap: fn =&gt; fn(),
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     flatMap: () =&gt; Maybe.Nothing(),
</span><span style=color:#cccece>      cata: (nothing, just) =&gt; nothing(),
    };
  }
</span></code></pre><p>El método <code>flatMap</code> además de comportarse como <code>map</code> nos permite deshacernos de "capas" extras que pueden complicar la composición más adelante. Asegúrense de usar <code>flatMap</code> sólo con funciones que retornen otros monads ya que esta no es la implementación más segura.<blockquote><p>Nota: Sí, los arreglos también son monads. Tienen los métodos <code>map</code> y <code>flatMap</code> que siguen todas las leyes.</blockquote><p>Probamos otra vez con <code>maybe_host</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece> </span><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>flatMap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>maybe_host</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>res </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>({ </span><span style=color:#cccece>res </span><span style=color:#5fb3b3>}));
  .</span><span style=color:#69c>catchMap</span><span style=color:#5fb3b3>(() </span><span style=color:#c594c5>=&gt; </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>what?</span><span style=color:#5fb3b3>&#39;))
</span></code></pre><p>Eso debería darnos.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>{ res: &#39;HOST=http://localhost:5000&#39; }
</span></code></pre><p>Estamos listos para combinar todo nuevamente.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>safer_cat </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>make_safe</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>const </span><span style=color:#cccece>maybe_host </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>wrap_fun</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;));
</span><span style=color:#c594c5>const </span><span style=color:#cccece>get_value </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>wrap_fun</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({</span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>}));

</span><span style=color:#c594c5>const </span><span style=color:#cccece>host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>safer_cat</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;)
  .</span><span style=color:#69c>flatMap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>maybe_host</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>flatMap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>get_value</span><span style=color:#5fb3b3>)
  .</span><span style=color:#69c>cata</span><span style=color:#5fb3b3>(
    () </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>http://127.0.0.1:3000</span><span style=color:#5fb3b3>&#39;,
    </span><span style=color:#f99157>host </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>host
  </span><span style=color:#5fb3b3>);

</span><span style=color:#5f6364>// ....
</span></code></pre><p>¿Y cómo sería si quisiéramos usar <code>pipe</code> o <code>compose</code>?<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>const </span><span style=color:#cccece>chain </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>m </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>m</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>const </span><span style=color:#cccece>unwrap_or </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fallback </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>fm </span><span style=color:#c594c5>=&gt; 
  </span><span style=color:#cccece>fm</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cata</span><span style=color:#5fb3b3>(() </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>fallback</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value </span><span style=color:#c594c5>=&gt; </span><span style=color:#cccece>value</span><span style=color:#5fb3b3>);


</span><span style=color:#c594c5>const </span><span style=color:#cccece>safer_cat </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>make_safe</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>cat</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>const </span><span style=color:#cccece>maybe_host </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>wrap_fun</span><span style=color:#5fb3b3>(</span><span style=color:#69c>grep</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>^HOST=</span><span style=color:#5fb3b3>&#39;));
</span><span style=color:#c594c5>const </span><span style=color:#cccece>get_value </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Maybe</span><span style=color:#5fb3b3>.</span><span style=color:#69c>wrap_fun</span><span style=color:#5fb3b3>(</span><span style=color:#69c>cut</span><span style=color:#5fb3b3>({</span><span style=color:#69c>delimiter</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>=</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#69c>fields</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>}));

</span><span style=color:#c594c5>const </span><span style=color:#cccece>get_host </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span style=color:#5fb3b3>(
  </span><span style=color:#cccece>safer_cat</span><span style=color:#5fb3b3>,
  </span><span style=color:#69c>chain</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>maybe_host</span><span style=color:#5fb3b3>),
  </span><span style=color:#69c>chain</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>get_value</span><span style=color:#5fb3b3>),
  </span><span style=color:#69c>unwrap_or</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>http://127.0.0.1:3000</span><span style=color:#5fb3b3>&#39;)
);

</span><span style=color:#69c>get_host</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>.env</span><span style=color:#5fb3b3>&#39;);
</span></code></pre><p>Pueden ver todo el código aquí: <a href=https://gist.github.com/VonHeikemen/0e6d4950bfe91229ee06eee2e3c74515>link</a>.<h2 id=todavia-quieren-saber-mas>¿Todavía quieren saber más?</h2><p>Hay muchas cosas que no mencioné para no tomar mucho de su tiempo. Si quieren indagar un poco más aquí les dejo más material que he preparado.<ul><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/partial-application/>Aplicacion parcial</a><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/the-power-of-map/>Más sobre Functors</a><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/using-a-maybe/>Usando un Maybe</a><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/dealing-with-side-effects-and-pure-functions/>Funciones puras y efectos</a></ul><h2 id=conclusion>Conclusión</h2><p>Muchas personas hablan de lo lindo que es la composición y cómo hace tu código más declarativo y limpio, pero nunca te muestran el lado difícil. Espero haber logrado eso, enseñarles un poco del lado difícil y cómo se puede superar. Combinar funciones en realidad es un arte, se requiere de práctica y tiempo para acostumbrarse a ciertas cosas (como que las funciones son cosas).<h2 id=fuentes>Fuentes</h2><ul><li><a href="https://www.youtube.com/watch?v=vDe-4o8Uwl8">The Power of Composition (video)</a><li><a href="https://www.youtube.com/watch?v=SfWR3dKnFIo">Oh Composable World! (video)</a><li><a href="https://www.youtube.com/watch?v=7BsfMMYvGaU">Mary had a little lambda (video)</a><li><a href=https://dev.to/joelnet/functional-javascript---functors-monads-and-promises-1pol>Functional JavaScript - Functors, Monads, and Promises</a></ul><hr><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>