<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Reduce: cómo y cuando | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, paradigma-funcional, aprendizaje, software, coding, development" name=keywords><meta content="Vamos a identificar cual es el caso ideal para usar reduce y aprenderemos algo en el camino" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Reduce: cómo y cuando</h1><span class=post-date>2020-04-19 | 10 minutos | <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/reduce-how-and-when/> Read in english </a> </span><p>Vamos a hablar del elefante rosa en el prototipo <code>Array</code>, me refiero al a veces odiado método <a rel="noopener external" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce target=_blank>reduce</a> pero no vamos a discutir sobre si esta función es buena o mala. Vamos a descubrir qué es lo que hace internamente, luego intentaremos descubrir las situaciones en las que puede ser una solución efectiva.<p>Para asegurarnos de entender su funcionamiento vamos a empezar implementando nuestra versión.<h2 id=como-funciona>¿Cómo funciona?</h2><p><code>reduce</code> es una función que toma una lista de valores y la transforma en otra cosa. La palabra clave aquí es <strong>transformación</strong>. Esta transformación la determina el "usuario" de nuestra función, son ellos los que deciden qué pasará ¿Qué quiere decir eso? Significa que aparte del arreglo que vamos a procesar necesitamos aceptar una función (un callback) como parámetro. Así que la firma de la función sería esta.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> reduce</span><span style=color:#9cabca>(</span><span>arr</span><span style=color:#9cabca>,</span><span> callback</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#727169>  // código...</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Ya tenemos algunos valores, y ahora ¿Qué hacemos con ellos? Sabemos que los métodos del prototipo <code>Array</code> aplican una función a cada uno de sus elementos. Hagamos eso.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> reduce</span><span style=color:#9cabca>(</span><span>arr</span><span style=color:#9cabca>,</span><span> callback</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  for</span><span style=color:#9cabca>(</span><span style=color:#957fb8>const</span><span> valor</span><span style=color:#e6c384> of</span><span> arr</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    callback</span><span style=color:#9cabca>(</span><span>valor</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Todavía no hace lo que queremos pero se acerca. Ahora falta el ingrediente secreto, el acumulador. Esta será una variable que crearemos para recordar el <strong>estado actual</strong> de nuestra transformación. Cada vez que apliquemos la función <code>callback</code> a un valor guardamos el resultado en el acumulador. Como bono extra, antes de guardar el nuevo estado en el acumulador le pasamos a <code>callback</code> el estado actual para que nuestro "usuario" no tenga que hacer ningún esfuerzo extra.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function reduce(arr, callback) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   let estado;</span></span>
<span class=giallo-l><span>    for(const valor of arr) {</span></span>
<span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043>     callback(valor);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     estado = callback(estado, valor);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   return estado;</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>Recuerden bien esas líneas que están verde. Por muy complicado que se vea <code>reduce</code> en el exterior, sin importar cuantos trucos raros vean por ahí, esas tres líneas son lo único que importa.<p>Aunque no sea una replica exacta de <code>Array.reduce</code> será suficiente para nuestros propósitos. Vamos a probarla.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array1</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 3</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 4</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> callback</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>estado</span><span style=color:#9cabca>,</span><span> valor</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  if</span><span style=color:#9cabca>(</span><span>estado</span><span style=color:#e6c384> ==</span><span style=color:#ffa066> null</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> valor</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> estado</span><span style=color:#e6c384> +</span><span> valor</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// 1 + 2 + 3 + 4</span></span>
<span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array1</span><span style=color:#9cabca>,</span><span> callback</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: 10</span></span></code></pre><p>¿Ven ese <code>if</code>? Está ahí porque en la primera iteración <code>estado</code> no tiene un valor, eso parece innecesario. Nosotros como autores de <code>reduce</code> podemos ayudar a reducir la cantidad de código que necesita <code>callback</code>. Al disminuir la carga de responsabilidad que necesita <code>callback</code> podemos hacer que <code>reduce</code> sea mucho más flexible. Lo que haremos será tomar el primer valor del arreglo y ese se convertirá en el <code>estado</code> para nuestra primera iteración.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function reduce(arr, callback) {</span></span>
<span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043>   let estado;</span></span>
<span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043>   for(const valor of arr) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   let estado = arr[0];</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   let resto = arr.slice(1);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   for(const valor of resto) {</span></span>
<span class=giallo-l><span>      estado = callback(estado, valor);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    return estado;</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>Vamos otra vez.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array1</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>1</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 2</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 3</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 4</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span style=color:#7e9cd8> callback</span><span style=color:#e6c384> =</span><span style=color:#9cabca> (</span><span>estado</span><span style=color:#9cabca>,</span><span> valor</span><span style=color:#9cabca>)</span><span style=color:#957fb8> =></span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> estado</span><span style=color:#e6c384> +</span><span> valor</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// 1 + 2 + 3 + 4</span></span>
<span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array1</span><span style=color:#9cabca>,</span><span> callback</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: 10</span></span></code></pre><p>Si aún les cuesta un poco descifrar lo que está pasando, puedo ayudarles con eso. Si sacamos <code>callback</code> de la ecuación esto es lo que sucede.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> reduce</span><span style=color:#9cabca>(</span><span>arr</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  let</span><span> estado</span><span style=color:#e6c384> =</span><span> arr</span><span style=color:#9cabca>[</span><span style=color:#d27e99>0</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l><span style=color:#957fb8>  let</span><span> resto</span><span style=color:#e6c384> =</span><span> arr</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>slice</span><span style=color:#9cabca>(</span><span style=color:#d27e99>1</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  for</span><span style=color:#9cabca>(</span><span style=color:#957fb8>const</span><span> valor</span><span style=color:#e6c384> of</span><span> resto</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span>   estado</span><span style=color:#e6c384> =</span><span> estado</span><span style=color:#e6c384> +</span><span> valor</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> estado</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>¿Recuerdan las tres líneas verdes?<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span>  function reduce(arr) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   let estado = arr[0];</span></span>
<span class=giallo-l><span>    let resto = arr.slice(1);</span></span>
<span class=giallo-l><span>    for(const valor of resto) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>    estado = estado + valor;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   return estado;</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>¿Lo notaron? Eso es todo lo que necesitan recordar. Básicamente,<code>reduce</code> nos da la habilidad de transformar una <strong>operación</strong> que actúa sobre dos valores a una que actúa sobre una cantidad variada.<h2 id=cuando-es-util>¿Cuando es útil?</h2><p><code>reduce</code> es una de esas funciones que pueden utilizarse en muchas ocasiones pero no en todas es la mejor solución. Ahora que sabemos cómo funciona veamos en qué tipo de situaciones puede ser la mejor opción.<h3 id=un-caso-ideal>Un caso ideal</h3><p>El ejemplo anterior ya debería darles una pista. Nuestra función es más efectiva cuando seguimos ciertos patrones. Pensemos un momento en lo que hace <code>callback</code> en nuestro ejemplo. Sabemos que necesita dos números, ejecuta una operación matemática y nos devuelve otro número. Entonces hace esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>Número + Número -> Número</span></span></code></pre><p>Bien, pero si damos un paso atrás y pensamos en términos más generales lo que tenemos es esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>TipoA + TipoA -> TipoA</span></span></code></pre><p>Hay dos valores del mismo tipo (TipoA) y una operación (el signo +) que nos devuelve otro valor del mismo tipo (TipoA). Cuando lo vemos de esa manera podemos darnos cuenta de un patrón que puede ser útil más allá de las operaciones matemáticas. Hagamos otro ejemplo con números pero esta vez lo que haremos será una comparación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> max</span><span style=color:#9cabca>(</span><span>un_numero</span><span style=color:#9cabca>,</span><span> otro_numero</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  if</span><span style=color:#9cabca>(</span><span>un_numero</span><span style=color:#e6c384> ></span><span> otro_numero</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> un_numero</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span><span style=color:#957fb8;font-weight:700> else</span><span style=color:#9cabca> {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>    return</span><span> otro_numero</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#9cabca>  }</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p><code>max</code> es una operación que actúa sobre dos números, los compara y devuelve el mayor. Es muy general y con una capacidad limitada. Si volvemos a pensar en lo abstracto vemos ese patrón otra vez.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>TipoA + TipoA -> TipoA</span></span></code></pre><p>O si somos más específicos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>Número + Número -> Número</span></span></code></pre><p>Ya saben lo que significa, podemos usar <code>reduce</code> para ampliar su capacidad.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array2</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 42</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 39</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 38</span><span style=color:#9cabca>];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// 40 > 41 > 42 > 39 > 38</span></span>
<span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array2</span><span style=color:#9cabca>,</span><span> max</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: 42</span></span></code></pre><p>Resulta que el patrón que hemos estado siguiendo para crear el <code>callback</code> que necesita <code>reduce</code> tiene un nombre en el paradigma funcional, a este lo llaman <strong>Semigrupo</strong>. En cualquier ocasión en la tengan dos valores de un mismo tipo y puedan combinarlos para crear otra instancia, están en la presencia de un semigrupo. En otras palabras, <em>dos valores</em> + <em>forma de combinarlos</em> = <em>Semigrupo</em>.<p>Una manera de probar que tienen una operación que sigue las reglas de un semigrupo es asegurarse de que la función cumple con la propiedad asociativa. Nuestra función <code>max</code> por ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> max_1</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> max</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>max</span><span style=color:#9cabca>(</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 42</span><span style=color:#9cabca>),</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> max_2</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> max</span><span style=color:#9cabca>(</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#7e9cd8> max</span><span style=color:#9cabca>(</span><span style=color:#d27e99>42</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>max_1</span><span style=color:#e6c384> ===</span><span> max_2</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: true</span></span></code></pre><p>¿Ven? Ejecutarla con el tipo de dato adecuado en diferente orden no afecta su resultado. Esto nos da la garantía de que funcionará si la combinamos con <code>reduce</code> y un arreglo de números.<p>¿Pero podríamos aplicar estas reglas a una estructura más compleja? Claro que sí. En javascript ya tenemos un par que las cumplen. Piensen en los arreglos, en el prototipo <code>Array</code> tenemos el método <code>concat</code>, este nos permite mezclar dos arreglos y crear uno nuevo con los elementos de ambos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> concat</span><span style=color:#9cabca>(</span><span>uno</span><span style=color:#9cabca>,</span><span> otro</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> uno</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>concat</span><span style=color:#9cabca>(</span><span>otro</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Con esto tenemos que.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>Array + Array -> Array</span></span></code></pre><p>Okey, el segundo parámetro de <code>concat</code> no tiene que ser un arreglo pero ignoraremos eso por el momento. Entonces si combinamos <code>concat</code> con <code>reduce</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array3</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [[</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>], [</span><span style=color:#d27e99>42</span><span style=color:#9cabca>], [</span><span style=color:#d27e99>39</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 38</span><span style=color:#9cabca>]];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// [40, 41] + [42] + [39, 38]</span></span>
<span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array3</span><span style=color:#9cabca>,</span><span> concat</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: [40, 41, 42, 39, 38]</span></span></code></pre><p>Ahora si quisieramos podríamos crear una función que "aplana" un nivel de un arreglo multidimensional, ¿No es genial? Y al igual que con los números, con los arreglos no tenemos porque limitarnos a operaciones que nos provee javascript. Si tenemos alguna función auxiliar que trabaje con dos arreglos y cumpla con la propiedad asociativa podemos combinarla con <code>reduce</code>.<p>Digamos que tenemos una función que une los elementos únicos de dos arreglos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>(</span><span>uno</span><span style=color:#9cabca>,</span><span> otro</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  const</span><span> set</span><span style=color:#e6c384> = new</span><span style=color:#7e9cd8> Set</span><span style=color:#9cabca>([</span><span style=color:#e6c384>...</span><span>uno</span><span style=color:#9cabca>,</span><span style=color:#e6c384> ...</span><span>otro</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> Array</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>from</span><span style=color:#9cabca>(</span><span>set</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span></code></pre><p>Bien, tenemos una función que trabaja con dos valores de un mismo tipo ahora veamos si cumple con la propiedad asociativa.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> union_1</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>union</span><span style=color:#9cabca>([</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>], [</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 42</span><span style=color:#9cabca>]), [</span><span style=color:#d27e99>39</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> union_2</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>([</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>],</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>([</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 42</span><span style=color:#9cabca>], [</span><span style=color:#d27e99>39</span><span style=color:#9cabca>]));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>union_1</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>)</span><span style=color:#e6c384> ==</span><span> union_2</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: true</span></span></code></pre><p>Sí cumple con las reglas, eso quiere decir que es posible procesar una cantidad variada de arreglos si usamos <code>reduce</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array4</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span></span>
<span class=giallo-l><span style=color:#9cabca>  [</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>],</span></span>
<span class=giallo-l><span style=color:#9cabca>  [</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> 'awesome'</span><span style=color:#9cabca>],</span></span>
<span class=giallo-l><span style=color:#9cabca>  [</span><span style=color:#98bb6c>'world'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> '!'</span><span style=color:#9cabca>],</span></span>
<span class=giallo-l><span style=color:#9cabca>  [</span><span style=color:#98bb6c>'!!!!'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> 'world'</span><span style=color:#9cabca>]</span></span>
<span class=giallo-l><span style=color:#9cabca>];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array4</span><span style=color:#9cabca>,</span><span> union</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: [ "hello", "awesome", "world", "!", "!!" ]</span></span></code></pre><h3 id=algo-de-resistencia>Algo de resistencia</h3><p>Habrán notado que en todos los ejemplos nuestros arreglos de datos son todos del tipo correcto, esto no siempre es así en el "mundo real". Podemos encontrarnos situaciones en las que el primer elemento de un arreglo no es un dato válido para nuestra operación.<p>Imaginemos que queremos usar <code>concat</code> otra vez pero el arreglo que tenemos para procesar es el siguiente.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array5</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span><span style=color:#d27e99>40</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 41</span><span style=color:#9cabca>, [</span><span style=color:#d27e99>42</span><span style=color:#9cabca>], [</span><span style=color:#d27e99>39</span><span style=color:#9cabca>,</span><span style=color:#d27e99> 38</span><span style=color:#9cabca>]];</span></span></code></pre><p>Si intentamos usar <code>reduce</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array5</span><span style=color:#9cabca>,</span><span> concat</span><span style=color:#9cabca>);</span></span></code></pre><p>Obtenemos esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>TypeError: uno.concat is not a function</span></span></code></pre><p>Esto ocurre porque en la primera iteración el valor de <code>uno</code> es el número <code>40</code>, el cual no posee un método <code>concat</code>. ¿Qué debemos hacer? Por lo general se considera una buena práctica utilizar un valor inicial fijo para evitar este tipo de errores. Pero tenemos un problema, nuestro <code>reduce</code> no acepta un valor inicial, así que deberíamos corregir eso.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=diff><span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043> function reduce(arr, callback) {</span></span>
<span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043>   let estado = arr[0];</span></span>
<span class=giallo-l><span style=color:#9cabca>-</span><span style=color:#c34043>   let resto = arr.slice(1);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a> function reduce(arr, ...args) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   if(args.length === 1) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     var [callback] = args;</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     var estado = arr[0];</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     var resto = arr.slice(1);</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   } else if(args.length >= 2) {</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     var [estado, callback] = args;</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>     var resto = arr;</span></span>
<span class=giallo-l><span style=color:#9cabca>+</span><span style=color:#76946a>   }</span></span>
<span class=giallo-l><span>    for(const valor of resto) {</span></span>
<span class=giallo-l><span>     estado = callback(estado, valor);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    return estado;</span></span>
<span class=giallo-l><span>  }</span></span></code></pre><p>Ahora para evitar el error anterior lo que haremos será pasarle a <code>reduce</code> un arreglo vacío como valor inicial.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array5</span><span style=color:#9cabca>, [],</span><span> concat</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: [ 40, 41, 42, 39, 38 ]</span></span></code></pre><p>Ya no hay error y pudimos obtener el arreglo que queríamos. Pero fíjense en una cosa, el arreglo vacío no sólo logró evitar el error sino que también dejó intacto el resultado de la operación. Al igual que con los números, con los arreglos tenemos la noción de un elemento vacío que podemos usar en nuestras operaciones sin causar un error en nuestro programa.<p>El arreglo vacío puede considerarse como un <strong>elemento identidad</strong>, un valor neutro que al aplicarlo a una operación no tiene ningún efecto en el resultado final. Adivinen qué, este comportamiento también tiene un nombre en el paradigma funcional, se le conoce como <strong>Monoid</strong>. Cuando tenemos un semigrupo con un elemento identidad estamos en presencia de un monoid. Entonces, <em>semigrupo</em> + <em>elemento identidad</em> = <em>Monoid</em>.<p>Podemos probar que los arreglos siguen las reglas de un monoid para nuestras operaciones.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#727169>// Concat</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> concat_1</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> concat</span><span style=color:#9cabca>([], [</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>])</span><span style=color:#727169> // => ["hello"]</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> concat_2</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> concat</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>], [])</span><span style=color:#727169> // => ["hello"]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>concat_1</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>)</span><span style=color:#e6c384> ==</span><span> concat_2</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: true</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>// Union</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> union_3</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>([], [</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>]);</span><span style=color:#727169> // => ["hello"]</span></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> union_4</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'hello'</span><span style=color:#9cabca>], []);</span><span style=color:#727169> // => ["hello"]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>union_3</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>)</span><span style=color:#e6c384> ==</span><span> union_4</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>join</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>','</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// valor esperado: true</span></span></code></pre><p>¿Por qué es importante? Piensen en esto: ¿Cuantas veces han tenido que escribir un <code>if</code> para resguardar una operación de un valor <code>null</code> o <code>undefined</code>? Si podemos representar un "valor vacío" de una manera más segura podemos eliminar toda una categoría de errores en nuestros programas.<p>Otra situación donde los monoids son útiles es cuando queremos ejecutar una operación "insegura" sobre un valor. Podríamos aplicar esa operación sobre una referencia a un valor vacío y así dejar el resto de los elementos intactos.<p>Imaginen que tienen fragmentos de información esparcidos en varios objectos y queremos unirlos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#957fb8>const</span><span> array6</span><span style=color:#e6c384> =</span><span style=color:#9cabca> [</span></span>
<span class=giallo-l><span style=color:#9cabca>  {</span><span>name</span><span style=color:#9cabca>:</span><span style=color:#98bb6c> 'Harold'</span><span style=color:#9cabca>},</span></span>
<span class=giallo-l><span style=color:#9cabca>  {</span><span>lastname</span><span style=color:#9cabca>:</span><span style=color:#98bb6c> 'Cooper'</span><span style=color:#9cabca>},</span></span>
<span class=giallo-l><span style=color:#9cabca>  {</span><span>state</span><span style=color:#9cabca>:</span><span style=color:#98bb6c> 'wrong'</span><span style=color:#9cabca>}</span></span>
<span class=giallo-l><span style=color:#9cabca>];</span></span></code></pre><p>Normalmente usarían la <a rel="noopener external" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax target=_blank>sintaxis de extensión</a> para mezclar todo eso, pero digamos que vivimos en un mundo donde eso no es posible. No teman, tenemos una función que puede hacer el trabajo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span>Object</span><span style=color:#9cabca>.</span><span style=color:#e6c384>assign</span><span style=color:#9cabca>;</span></span></code></pre><p>Si lo piensan <code>Object.assign</code> también sigue el patrón.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>TipoA + TipoA -> TipoA</span></span></code></pre><p>Si le pasamos dos objetos nos devuelve un nuevo objecto. Pero hay algo que deben saber, <code>Object.assign</code> modifica el objeto que le pasamos como primer parámetro. Entonces si hacemos esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array6</span><span style=color:#9cabca>,</span><span> Object</span><span style=color:#9cabca>.</span><span style=color:#e6c384>assign</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// Valor esperado: { "name": "Harold", "lastname": "Cooper", "state": "wrong" }</span></span></code></pre><p>Parecería que todo está bien, pero no es así. Si revisan <code>array6[0]</code> verán que ha cambiado, definitivamente no quieren eso. Por suerte para nosotros los objetos en javascript se comportan como monoids, así que podemos usar un "valor vacío". Entonces la manera correcta de usar <code>reduce</code> en este caso sería esta.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#7e9cd8>reduce</span><span style=color:#9cabca>(</span><span>array6</span><span style=color:#9cabca>, {},</span><span> Object</span><span style=color:#9cabca>.</span><span style=color:#e6c384>assign</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#727169>// Valor esperado: </span></span>
<span class=giallo-l><span style=color:#727169>// { "name": "Harold", "lastname": "Cooper", "state": "wrong" }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>array6</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l><span style=color:#727169>// Valor esperado: </span></span>
<span class=giallo-l><span style=color:#727169>// [ { "name": "Harold" }, { "lastname": "Cooper" }, { "state": "wrong" } ]</span></span></code></pre><p>Podemos decir que cuando trabajamos con un arreglo de estructuras que siguen las reglas de los monoid podemos estar seguros que <code>reduce</code> será una buena opción para procesarlo.<h2 id=mas-alla-de-los-arreglos>Más allá de los arreglos</h2><p>Si nosotros pudimos implementar una versión de <code>reduce</code> para los arreglos entonces no sería del todo extraño pensar que otras personas hayan incorporado algo similar a otras estructuras. Saber cómo funciona <code>reduce</code> puede ser muy útil si utilizan una librería que tenga un método parecido.<p>Por ejemplo, la librería <a rel="noopener external" href=https://mithril.js.org/stream.html target=_blank>mithril-stream</a> tiene un método llamado <code>scan</code> que tiene la siguiente forma.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>Stream.scan(fn, accumulator, stream)</span></span></code></pre><p>Esa variable <code>fn</code> debe ser una función que debe tener la siguiente firma.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>(accumulator, value) -> result | SKIP</span></span></code></pre><p>¿Reconocen eso? Espero que sí. Son los mismos requerimientos de <code>reduce</code>. ¿Pero qué hace esa función? Bueno, ejecuta la función <code>fn</code> cuando la fuente (<code>stream</code>) produce un nuevo dato. Cuando la función <code>fn</code> es ejecutada recibe como parámetro el estado actual del acumulador y el nuevo dato producido, luego el resultado retornado por <code>fn</code> se convierte en el nuevo estado del acumulador. ¿Les suena familiar ese comportamiento?<p>Pueden probar el método <code>scan</code> con nuestra función <code>union</code> y ver cómo se comporta.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=javascript><span class=giallo-l><span style=color:#ffa066>import</span><span> Stream</span><span style=color:#957fb8> from</span><span style=color:#98bb6c> 'https://cdn.pika.dev/mithril-stream@^2.0.0'</span><span style=color:#9cabca>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> union</span><span style=color:#9cabca>(</span><span>one</span><span style=color:#9cabca>,</span><span> another</span><span style=color:#9cabca>) {</span></span>
<span class=giallo-l><span style=color:#957fb8>  const</span><span> set</span><span style=color:#e6c384> = new</span><span style=color:#7e9cd8> Set</span><span style=color:#9cabca>([</span><span style=color:#e6c384>...</span><span>one</span><span style=color:#9cabca>,</span><span style=color:#e6c384> ...</span><span>another</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l><span style=color:#957fb8;font-weight:700>  return</span><span> Array</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>from</span><span style=color:#9cabca>(</span><span>set</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span style=color:#9cabca>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> list</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> Stream</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'node'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> 'js'</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>const</span><span> state</span><span style=color:#e6c384> =</span><span> Stream</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>scan</span><span style=color:#9cabca>(</span><span>union</span><span style=color:#9cabca>, [],</span><span> list</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l><span>state</span><span style=color:#9cabca>.</span><span style=color:#7e9cd8>map</span><span style=color:#9cabca>(</span><span>console</span><span style=color:#9cabca>.</span><span style=color:#e6c384>log</span><span style=color:#9cabca>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>list</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'node'</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l><span style=color:#7e9cd8>list</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'js'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> 'deno'</span><span style=color:#9cabca>]);</span></span>
<span class=giallo-l><span style=color:#7e9cd8>list</span><span style=color:#9cabca>([</span><span style=color:#98bb6c>'node'</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> 'javascript'</span><span style=color:#9cabca>]);</span></span></code></pre><p>Deberían observar cómo la lista sólo agrega elementos que no han sido agregados antes.<p>Pueden ver en acción una versión modificada de ese fragmento en codepen.<p data-pen-title="A different reduce" style="box-sizing:border-box;border:2px solid;justify-content:center;align-items:center;height:600px;margin:1em 0;padding:1em;display:flex" class=codepen data-default-tab=js,result data-height=600 data-preview=true data-slug-hash=NWGrozo data-theme-id=dark data-user=VonHeikemen><span> See the Pen <a href=https://codepen.io/VonHeikemen/pen/NWGrozo>A different reduce</a> by Heiker (<a href=https://codepen.io/VonHeikemen>@VonHeikemen</a>) on <a href=https://codepen.io>CodePen</a>. </span></p><script async src=https://static.codepen.io/assets/embed/ei.js></script><p>¿Vieron? nuestro conocimiento de <code>reduce</code> (y tal vez algo de semigrupos y monoids) nos puede ayudar a crear funciones auxiliares que podemos reusar con diferentes estructuras. ¿No es genial?<h2 id=conclusion>Conclusión</h2><p>Aunque no mencioné todas las cosas que pueden hacer con <code>reduce</code> ahora tienen las herramientas para poder identificar los casos en lo que puede ser utilizado efectivamente, incluso si no están seguros pueden hacer las pruebas necesarias para garantizar que la operación que quieren ejecutar tiene las características adecuadas.<h2 id=fuentes>Fuentes</h2><ul><li><a href="https://www.youtube.com/watch?v=Qnkn4612ZIQ" rel="noopener external" target=_blank>Practical Category Theory: Monoids (video)</a><li><a rel="noopener external" href=https://github.com/thefrontside/funcadelic.js target=_blank>Funcadelic.js</a><li><a rel="noopener external" href=https://jrsinclair.com/articles/2019/functional-js-do-more-with-reduce/ target=_blank>Functional JavaScript: How to use array reduce for more than just numbers</a><li><a rel="noopener external" href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce target=_blank>Array.prototype.reduce (MDN)</a><li><a rel="noopener external" href=https://github.com/fantasyland/fantasy-land#fantasy-land-specification target=_blank>Fantasy Land</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/reduce-como-y-cuando-18a1 rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/reduce-how-and-when-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>