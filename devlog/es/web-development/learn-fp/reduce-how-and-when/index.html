<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Reduce: cómo y cuando | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=me href=https://hachyderm.io/@vonheikemen><link rel=me href=https://twitter.com/VonHeikemen_><meta name=keywords content="javascript,paradigma-funcional,aprendizaje,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Vamos a identificar cual es el caso ideal para usar reduce y aprenderemos algo en el camino"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2023 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Reduce: cómo y cuando</h1><span class=post-date>2020-04-19
| 12 minutos
| <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/reduce-how-and-when/>Read in english</a></span><p>Vamos a hablar del elefante rosa en el prototipo <code>Array</code>, me refiero al a veces odiado método <a rel=noopener target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce>reduce</a> pero no vamos a discutir sobre si esta función es buena o mala. Vamos a descubrir qué es lo que hace internamente, luego intentaremos descubrir las situaciones en las que puede ser una solución efectiva.<p>Para asegurarnos de entender su funcionamiento vamos a empezar implementando nuestra versión.<h2 id=como-funciona>¿Cómo funciona?</h2><p><code>reduce</code> es una función que toma una lista de valores y la transforma en otra cosa. La palabra clave aquí es <strong>transformación</strong>. Esta transformación la determina el "usuario" de nuestra función, son ellos los que deciden qué pasará ¿Qué quiere decir eso? Significa que aparte del arreglo que vamos a procesar necesitamos aceptar una función (un callback) como parámetro. Así que la firma de la función sería esta.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>reduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arr</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>callback</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>  </span><span style=color:#5f6364>// código...
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ya tenemos algunos valores, y ahora ¿Qué hacemos con ellos? Sabemos que los métodos del prototipo <code>Array</code> aplican una función a cada uno de sus elementos. Hagamos eso.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>reduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arr</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>callback</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>const </span><span>valor </span><span style=color:#5fb3b3>of </span><span>arr) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#69c>callback</span><span>(valor)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Todavía no hace lo que queremos pero se acerca. Ahora falta el ingrediente secreto, el acumulador. Esta será una variable que crearemos para recordar el <strong>estado actual</strong> de nuestra transformación. Cada vez que apliquemos la función <code>callback</code> a un valor guardamos el resultado en el acumulador. Como bono extra, antes de guardar el nuevo estado en el acumulador le pasamos a <code>callback</code> el estado actual para que nuestro "usuario" no tenga que hacer ningún esfuerzo extra.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(arr, callback) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   let estado;
</span><span>    for(const valor of arr) {
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>     callback(valor);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     estado = callback(estado, valor);
</span><span>    }
</span><span>
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   return estado;
</span><span>  }
</span></code></pre><p>Recuerden bien esas líneas que están verde. Por muy complicado que se vea <code>reduce</code> en el exterior, sin importar cuantos trucos raros vean por ahí, esas tres líneas son lo único que importa.<p>Aunque no sea una replica exacta de <code>Array.reduce</code> será suficiente para nuestros propósitos. Vamos a probarla.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array1 </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>4</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>callback </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>estado</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>valor</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#c594c5>if</span><span>(estado </span><span style=color:#5fb3b3>== </span><span style=color:#f99157>null</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>valor</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>estado </span><span style=color:#5fb3b3>+ </span><span>valor</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span><span>
</span><span style=color:#5f6364>// 1 + 2 + 3 + 4
</span><span style=color:#69c>reduce</span><span>(array1</span><span style=color:#5fb3b3>, </span><span>callback)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: 10
</span></code></pre><p>¿Ven ese <code>if</code>? Está ahí porque en la primera iteración <code>estado</code> no tiene un valor, eso parece innecesario. Nosotros como autores de <code>reduce</code> podemos ayudar a reducir la cantidad de código que necesita <code>callback</code>. Al disminuir la carga de responsabilidad que necesita <code>callback</code> podemos hacer que <code>reduce</code> sea mucho más flexible. Lo que haremos será tomar el primer valor del arreglo y ese se convertirá en el <code>estado</code> para nuestra primera iteración.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(arr, callback) {
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>   let estado;
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>   for(const valor of arr) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   let estado = arr[0];
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   let resto = arr.slice(1);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   for(const valor of resto) {
</span><span>      estado = callback(estado, valor);
</span><span>    }
</span><span>
</span><span>    return estado;
</span><span>  }
</span></code></pre><p>Vamos otra vez.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array1 </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>4</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>callback </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>estado</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>valor</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#c594c5>return </span><span>estado </span><span style=color:#5fb3b3>+ </span><span>valor</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span><span>
</span><span style=color:#5f6364>// 1 + 2 + 3 + 4
</span><span style=color:#69c>reduce</span><span>(array1</span><span style=color:#5fb3b3>, </span><span>callback)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: 10
</span></code></pre><p>Si aún les cuesta un poco descifrar lo que está pasando, puedo ayudarles con eso. Si sacamos <code>callback</code> de la ecuación esto es lo que sucede.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>reduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arr</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>let </span><span>estado </span><span style=color:#5fb3b3>= </span><span>arr[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>let </span><span>resto </span><span style=color:#5fb3b3>= </span><span>arr</span><span style=color:#5fb3b3>.</span><span style=color:#69c>slice</span><span>(</span><span style=color:#f99157>1</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>const </span><span>valor </span><span style=color:#5fb3b3>of </span><span>resto) </span><span style=color:#5fb3b3>{
</span><span>   estado </span><span style=color:#5fb3b3>= </span><span>estado </span><span style=color:#5fb3b3>+ </span><span>valor</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>estado</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>¿Recuerdan las tres líneas verdes?<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(arr) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   let estado = arr[0];
</span><span>    let resto = arr.slice(1);
</span><span>    for(const valor of resto) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>    estado = estado + valor;
</span><span>    }
</span><span>
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   return estado;
</span><span>  }
</span></code></pre><p>¿Lo notaron? Eso es todo lo que necesitan recordar. Básicamente,<code>reduce</code> nos da la habilidad de transformar una <strong>operación</strong> que actúa sobre dos valores a una que actúa sobre una cantidad variada.<h2 id=cuando-es-util>¿Cuando es útil?</h2><p><code>reduce</code> es una de esas funciones que pueden utilizarse en muchas ocasiones pero no en todas es la mejor solución. Ahora que sabemos cómo funciona veamos en qué tipo de situaciones puede ser la mejor opción.<h3 id=un-caso-ideal>Un caso ideal</h3><p>El ejemplo anterior ya debería darles una pista. Nuestra función es más efectiva cuando seguimos ciertos patrones. Pensemos un momento en lo que hace <code>callback</code> en nuestro ejemplo. Sabemos que necesita dos números, ejecuta una operación matemática y nos devuelve otro número. Entonces hace esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>Número + Número -&gt; Número
</span></code></pre><p>Bien, pero si damos un paso atrás y pensamos en términos más generales lo que tenemos es esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>TipoA + TipoA -&gt; TipoA
</span></code></pre><p>Hay dos valores del mismo tipo (TipoA) y una operación (el signo +) que nos devuelve otro valor del mismo tipo (TipoA). Cuando lo vemos de esa manera podemos darnos cuenta de un patrón que puede ser útil más allá de las operaciones matemáticas. Hagamos otro ejemplo con números pero esta vez lo que haremos será una comparación.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>max</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>un_numero</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>otro_numero</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(un_numero </span><span style=color:#5fb3b3>&gt; </span><span>otro_numero) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>un_numero</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>otro_numero</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p><code>max</code> es una operación que actúa sobre dos números, los compara y devuelve el mayor. Es muy general y con una capacidad limitada. Si volvemos a pensar en lo abstracto vemos ese patrón otra vez.<pre style=background-color:#2b2c2f;color:#cccece><code><span>TipoA + TipoA -&gt; TipoA
</span></code></pre><p>O si somos más específicos.<pre style=background-color:#2b2c2f;color:#cccece><code><span>Número + Número -&gt; Número
</span></code></pre><p>Ya saben lo que significa, podemos usar <code>reduce</code> para ampliar su capacidad.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array2 </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>42</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>39</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>38</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// 40 &gt; 41 &gt; 42 &gt; 39 &gt; 38
</span><span style=color:#69c>reduce</span><span>(array2</span><span style=color:#5fb3b3>, </span><span>max)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: 42
</span></code></pre><p>Resulta que el patrón que hemos estado siguiendo para crear el <code>callback</code> que necesita <code>reduce</code> tiene un nombre en el paradigma funcional, a este lo llaman <strong>Semigrupo</strong>. En cualquier ocasión en la tengan dos valores de un mismo tipo y puedan combinarlos para crear otra instancia, están en la presencia de un semigrupo. En otras palabras, <em>dos valores</em> + <em>forma de combinarlos</em> = <em>Semigrupo</em>.<p>Una manera de probar que tienen una operación que sigue las reglas de un semigrupo es asegurarse de que la función cumple con la propiedad asociativa. Nuestra función <code>max</code> por ejemplo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>max_1 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>max</span><span>(</span><span style=color:#69c>max</span><span>(</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>42</span><span>)</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>max_2 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>max</span><span>(</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#69c>max</span><span>(</span><span style=color:#f99157>42</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>max_1 </span><span style=color:#5fb3b3>=== </span><span>max_2</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: true
</span></code></pre><p>¿Ven? Ejecutarla con el tipo de dato adecuado en diferente orden no afecta su resultado. Esto nos da la garantía de que funcionará si la combinamos con <code>reduce</code> y un arreglo de números.<p>¿Pero podríamos aplicar estas reglas a una estructura más compleja? Claro que sí. En javascript ya tenemos un par que las cumplen. Piensen en los arreglos, en el prototipo <code>Array</code> tenemos el método <code>concat</code>, este nos permite mezclar dos arreglos y crear uno nuevo con los elementos de ambos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>concat</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>uno</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>otro</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>uno</span><span style=color:#5fb3b3>.</span><span style=color:#69c>concat</span><span>(otro)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Con esto tenemos que.<pre style=background-color:#2b2c2f;color:#cccece><code><span>Array + Array -&gt; Array
</span></code></pre><p>Okey, el segundo parámetro de <code>concat</code> no tiene que ser un arreglo pero ignoraremos eso por el momento. Entonces si combinamos <code>concat</code> con <code>reduce</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array3 </span><span style=color:#5fb3b3>= </span><span>[[</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>42</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>39</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>38</span><span>]]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// [40, 41] + [42] + [39, 38]
</span><span style=color:#69c>reduce</span><span>(array3</span><span style=color:#5fb3b3>, </span><span>concat)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: [40, 41, 42, 39, 38]
</span></code></pre><p>Ahora si quisieramos podríamos crear una función que "aplana" un nivel de un arreglo multidimensional, ¿No es genial? Y al igual que con los números, con los arreglos no tenemos porque limitarnos a operaciones que nos provee javascript. Si tenemos alguna función auxiliar que trabaje con dos arreglos y cumpla con la propiedad asociativa podemos combinarla con <code>reduce</code>.<p>Digamos que tenemos una función que une los elementos únicos de dos arreglos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>union</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>uno</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>otro</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>set </span><span style=color:#5fb3b3>= new </span><span>Set([</span><span style=color:#5fb3b3>...</span><span>uno</span><span style=color:#5fb3b3>, ...</span><span>otro])</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>from</span><span>(set)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Bien, tenemos una función que trabaja con dos valores de un mismo tipo ahora veamos si cumple con la propiedad asociativa.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>union_1 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>union</span><span>(</span><span style=color:#69c>union</span><span>([</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>42</span><span>])</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>39</span><span>])</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>union_2 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>union</span><span>([</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span>]</span><span style=color:#5fb3b3>, </span><span style=color:#69c>union</span><span>([</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>42</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>39</span><span>]))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>union_1</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>== </span><span>union_2</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: true
</span></code></pre><p>Sí cumple con las reglas, eso quiere decir que es posible procesar una cantidad variada de arreglos si usamos <code>reduce</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array4 </span><span style=color:#5fb3b3>= </span><span>[
</span><span>  [</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>,
</span><span>  [</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>awesome</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>,
</span><span>  [</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>world</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>!</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>,
</span><span>  [</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>!!!!</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>world</span><span style=color:#5fb3b3>&#39;</span><span>]
</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>reduce</span><span>(array4</span><span style=color:#5fb3b3>, </span><span>union)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: [ &quot;hello&quot;, &quot;awesome&quot;, &quot;world&quot;, &quot;!&quot;, &quot;!!&quot; ]
</span></code></pre><h3 id=algo-de-resistencia>Algo de resistencia</h3><p>Habrán notado que en todos los ejemplos nuestros arreglos de datos son todos del tipo correcto, esto no siempre es así en el "mundo real". Podemos encontrarnos situaciones en las que el primer elemento de un arreglo no es un dato válido para nuestra operación.<p>Imaginemos que queremos usar <code>concat</code> otra vez pero el arreglo que tenemos para procesar es el siguiente.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array5 </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>40</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>41</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>42</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>39</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>38</span><span>]]</span><span style=color:#5fb3b3>;
</span></code></pre><p>Si intentamos usar <code>reduce</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>reduce</span><span>(array5</span><span style=color:#5fb3b3>, </span><span>concat)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Obtenemos esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>TypeError: uno.concat is not a function
</span></code></pre><p>Esto ocurre porque en la primera iteración el valor de <code>uno</code> es el número <code>40</code>, el cual no posee un método <code>concat</code>. ¿Qué debemos hacer? Por lo general se considera una buena práctica utilizar un valor inicial fijo para evitar este tipo de errores. Pero tenemos un problema, nuestro <code>reduce</code> no acepta un valor inicial, así que deberíamos corregir eso.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> function reduce(arr, callback) {
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>   let estado = arr[0];
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>   let resto = arr.slice(1);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> function reduce(arr, ...args) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   if(args.length === 1) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     var [callback] = args;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     var estado = arr[0];
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     var resto = arr.slice(1);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   } else if(args.length &gt;= 2) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     var [estado, callback] = args;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     var resto = arr;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span>    for(const valor of resto) {
</span><span>     estado = callback(estado, valor);
</span><span>    }
</span><span>
</span><span>    return estado;
</span><span>  }
</span></code></pre><p>Ahora para evitar el error anterior lo que haremos será pasarle a <code>reduce</code> un arreglo vacío como valor inicial.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>reduce</span><span>(array5</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span>concat)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: [ 40, 41, 42, 39, 38 ]
</span></code></pre><p>Ya no hay error y pudimos obtener el arreglo que queríamos. Pero fíjense en una cosa, el arreglo vacío no sólo logró evitar el error sino que también dejó intacto el resultado de la operación. Al igual que con los números, con los arreglos tenemos la noción de un elemento vacío que podemos usar en nuestras operaciones sin causar un error en nuestro programa.<p>El arreglo vacío puede considerarse como un <strong>elemento identidad</strong>, un valor neutro que al aplicarlo a una operación no tiene ningún efecto en el resultado final. Adivinen qué, este comportamiento también tiene un nombre en el paradigma funcional, se le conoce como <strong>Monoid</strong>. Cuando tenemos un semigrupo con un elemento identidad estamos en presencia de un monoid. Entonces, <em>semigrupo</em> + <em>elemento identidad</em> = <em>Monoid</em>.<p>Podemos probar que los arreglos siguen las reglas de un monoid para nuestras operaciones.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#5f6364>// Concat
</span><span style=color:#c594c5>const </span><span>concat_1 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>concat</span><span>([]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]) </span><span style=color:#5f6364>// =&gt; [&quot;hello&quot;]
</span><span style=color:#c594c5>const </span><span>concat_2 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>concat</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>, </span><span>[]) </span><span style=color:#5f6364>// =&gt; [&quot;hello&quot;]
</span><span>
</span><span>concat_1</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>== </span><span>concat_2</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: true
</span><span>
</span><span style=color:#5f6364>// Union
</span><span style=color:#c594c5>const </span><span>union_3 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>union</span><span>([]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// =&gt; [&quot;hello&quot;]
</span><span style=color:#c594c5>const </span><span>union_4 </span><span style=color:#5fb3b3>= </span><span style=color:#69c>union</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>, </span><span>[])</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// =&gt; [&quot;hello&quot;]
</span><span>
</span><span>union_3</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>== </span><span>union_4</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// valor esperado: true
</span></code></pre><p>¿Por qué es importante? Piensen en esto: ¿Cuantas veces han tenido que escribir un <code>if</code> para resguardar una operación de un valor <code>null</code> o <code>undefined</code>? Si podemos representar un "valor vacío" de una manera más segura podemos eliminar toda una categoría de errores en nuestros programas.<p>Otra situación donde los monoids son útiles es cuando queremos ejecutar una operación "insegura" sobre un valor. Podríamos aplicar esa operación sobre una referencia a un valor vacío y así dejar el resto de los elementos intactos.<p>Imaginen que tienen fragmentos de información esparcidos en varios objectos y queremos unirlos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>array6 </span><span style=color:#5fb3b3>= </span><span>[
</span><span>  </span><span style=color:#5fb3b3>{</span><span>name</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>Harold</span><span style=color:#5fb3b3>&#39;},
</span><span>  </span><span style=color:#5fb3b3>{</span><span>lastname</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>Cooper</span><span style=color:#5fb3b3>&#39;},
</span><span>  </span><span style=color:#5fb3b3>{</span><span>state</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>wrong</span><span style=color:#5fb3b3>&#39;}
</span><span>]</span><span style=color:#5fb3b3>;
</span></code></pre><p>Normalmente usarían la <a rel=noopener target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax>sintaxis de extensión</a> para mezclar todo eso, pero digamos que vivimos en un mundo donde eso no es posible. No teman, tenemos una función que puede hacer el trabajo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#fac863>Object</span><span style=color:#5fb3b3>.</span><span>assign</span><span style=color:#5fb3b3>;
</span></code></pre><p>Si lo piensan <code>Object.assign</code> también sigue el patrón.<pre style=background-color:#2b2c2f;color:#cccece><code><span>TipoA + TipoA -&gt; TipoA
</span></code></pre><p>Si le pasamos dos objetos nos devuelve un nuevo objecto. Pero hay algo que deben saber, <code>Object.assign</code> modifica el objeto que le pasamos como primer parámetro. Entonces si hacemos esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>reduce</span><span>(array6</span><span style=color:#5fb3b3>, </span><span style=color:#fac863>Object</span><span style=color:#5fb3b3>.</span><span>assign)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Valor esperado: { &quot;name&quot;: &quot;Harold&quot;, &quot;lastname&quot;: &quot;Cooper&quot;, &quot;state&quot;: &quot;wrong&quot; }
</span></code></pre><p>Parecería que todo está bien, pero no es así. Si revisan <code>array6[0]</code> verán que ha cambiado, definitivamente no quieren eso. Por suerte para nosotros los objetos en javascript se comportan como monoids, así que podemos usar un "valor vacío". Entonces la manera correcta de usar <code>reduce</code> en este caso sería esta.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>reduce</span><span>(array6</span><span style=color:#5fb3b3>, {}, </span><span style=color:#fac863>Object</span><span style=color:#5fb3b3>.</span><span>assign)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Valor esperado: 
</span><span style=color:#5f6364>// { &quot;name&quot;: &quot;Harold&quot;, &quot;lastname&quot;: &quot;Cooper&quot;, &quot;state&quot;: &quot;wrong&quot; }
</span><span>
</span><span>array6</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Valor esperado: 
</span><span style=color:#5f6364>// [ { &quot;name&quot;: &quot;Harold&quot; }, { &quot;lastname&quot;: &quot;Cooper&quot; }, { &quot;state&quot;: &quot;wrong&quot; } ]
</span></code></pre><p>Podemos decir que cuando trabajamos con un arreglo de estructuras que siguen las reglas de los monoid podemos estar seguros que <code>reduce</code> será una buena opción para procesarlo.<h2 id=mas-alla-de-los-arreglos>Más allá de los arreglos</h2><p>Si nosotros pudimos implementar una versión de <code>reduce</code> para los arreglos entonces no sería del todo extraño pensar que otras personas hayan incorporado algo similar a otras estructuras. Saber cómo funciona <code>reduce</code> puede ser muy útil si utilizan una librería que tenga un método parecido.<p>Por ejemplo, la librería <a rel=noopener target=_blank href=https://mithril.js.org/stream.html>mithril-stream</a> tiene un método llamado <code>scan</code> que tiene la siguiente forma.<pre style=background-color:#2b2c2f;color:#cccece><code><span>Stream.scan(fn, accumulator, stream)
</span></code></pre><p>Esa variable <code>fn</code> debe ser una función que debe tener la siguiente firma.<pre style=background-color:#2b2c2f;color:#cccece><code><span>(accumulator, value) -&gt; result | SKIP
</span></code></pre><p>¿Reconocen eso? Espero que sí. Son los mismos requerimientos de <code>reduce</code>. ¿Pero qué hace esa función? Bueno, ejecuta la función <code>fn</code> cuando la fuente (<code>stream</code>) produce un nuevo dato. Cuando la función <code>fn</code> es ejecutada recibe como parámetro el estado actual del acumulador y el nuevo dato producido, luego el resultado retornado por <code>fn</code> se convierte en el nuevo estado del acumulador. ¿Les suena familiar ese comportamiento?<p>Pueden probar el método <code>scan</code> con nuestra función <code>union</code> y ver cómo se comporta.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>import </span><span>Stream </span><span style=color:#c594c5>from </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>https://cdn.pika.dev/mithril-stream@^2.0.0</span><span style=color:#5fb3b3>&#39;;
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#69c>union</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>another</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>set </span><span style=color:#5fb3b3>= new </span><span>Set([</span><span style=color:#5fb3b3>...</span><span>one</span><span style=color:#5fb3b3>, ...</span><span>another])</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>from</span><span>(set)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>const </span><span>list </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Stream</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>node</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>js</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>state </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Stream</span><span style=color:#5fb3b3>.</span><span style=color:#69c>scan</span><span>(union</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span>list)</span><span style=color:#5fb3b3>;
</span><span>state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>list</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>node</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span><span style=color:#69c>list</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>js</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>deno</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span><span style=color:#69c>list</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>node</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>javascript</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span></code></pre><p>Deberían observar cómo la lista sólo agrega elementos que no han sido agregados antes.<p>Pueden ver en acción una versión modificada de ese fragmento en codepen.<p class=codepen data-height=600 data-theme-id=dark data-default-tab=js,result data-user=VonHeikemen data-slug-hash=NWGrozo data-preview=true style="height:600px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border:2px solid;margin:1em 0;padding:1em" data-pen-title="A different reduce"><span>See the Pen <a href=https://codepen.io/VonHeikemen/pen/NWGrozo>A different reduce</a> by Heiker (<a href=https://codepen.io/VonHeikemen>@VonHeikemen</a>) on <a href=https://codepen.io>CodePen</a>.</span></p><script async src=https://static.codepen.io/assets/embed/ei.js></script><p>¿Vieron? nuestro conocimiento de <code>reduce</code> (y tal vez algo de semigrupos y monoids) nos puede ayudar a crear funciones auxiliares que podemos reusar con diferentes estructuras. ¿No es genial?<h2 id=conclusion>Conclusión</h2><p>Aunque no mencioné todas las cosas que pueden hacer con <code>reduce</code> ahora tienen las herramientas para poder identificar los casos en lo que puede ser utilizado efectivamente, incluso si no están seguros pueden hacer las pruebas necesarias para garantizar que la operación que quieren ejecutar tiene las características adecuadas.<h2 id=fuentes>Fuentes</h2><ul><li><a rel=noopener target=_blank href="https://www.youtube.com/watch?v=Qnkn4612ZIQ">Practical Category Theory: Monoids (video)</a><li><a rel=noopener target=_blank href=https://github.com/thefrontside/funcadelic.js>Funcadelic.js</a><li><a rel=noopener target=_blank href=https://jrsinclair.com/articles/2019/functional-js-do-more-with-reduce/>Functional JavaScript: How to use array reduce for more than just numbers</a><li><a rel=noopener target=_blank href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce>Array.prototype.reduce (MDN)</a><li><a rel=noopener target=_blank href=https://github.com/fantasyland/fantasy-land#fantasy-land-specification>Fantasy Land</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario
en cualquiera de estas plataformas:<ul><li><a rel=noopener target=_blank href=https://dev.to/vonheikemen/reduce-como-y-cuando-18a1>dev.to</a><li><a rel=noopener target=_blank href=https://vonheikemen.hashnode.dev/reduce-how-and-when-es>Hashnode</a></ul><p>Puedes contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" target=_blank href=https://twitter.com/VonHeikemen_>@VonHeikemen_</a><li>Mastodon <a rel="noopener me" target=_blank href=https://hachyderm.io/@vonheikemen>@vonheikemen@hachyderm.io</a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>