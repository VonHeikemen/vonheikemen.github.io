<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Una introducción a las mónadas (en javascript) | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=me href=https://hachyderm.io/@vonheikemen><link rel=me href=https://twitter.com/VonHeikemen_><meta name=keywords content="javascript,paradigma-funcional,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Donde intentamos usar javascript para explicar que son los mónadas"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2022 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Una introducción a las mónadas (en javascript)</h1><span class=post-date>2020-09-26
| 8 minutos
| <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/an-introduction-to-monads-in-js/>Read in english</a></span><p>Las infames mónadas. Innombrables en el mundo javascript. Hoy hablaremos de ellas, para ser más específico lo que haremos será "revisar" una definición de mónadas que leí por ahí, la única que no hace que mi cerebro explote. Para mantener nuestra cordura intacta sólo vamos a explorar los aspectos que podemos modelar fácilmente usando javascript. ¿Todo el mundo listo? Comencemos.<p>Aquí vamos. Esta será fácil, se los juro. Las mónadas son...<blockquote><p>functores puntiagudos que pueden aplanarse.</blockquote><p>Dijeron que estaban listos. En fin, podemos con esto. Sólo tienen que conocer cuál es el comportamiento de un functor y los demás será pan comido.<h2 id=presentando-a-los-functores>Presentando a los Functores</h2><p>Si hablamos de javascript, la forma más común de implementar un functor es creando una especie contenedor con una característica especial: debe permitirnos transformar el valor interno en cualquier forma que nosotros queramos sin tener que dejar el contenedor.<p>¿Acaso no suena interesante? ¿Cómo se vería eso en código? Intentemos creando el functor más simple que podamos imaginar.<h3 id=la-caja>La Caja</h3><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>Caja</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>return </span><span style=color:#69c>Caja</span><span>(</span><span style=color:#69c>fn</span><span>(data))</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Muy bien ¿qué ocurre aquí? Bueno, tenemos una <code>Caja</code> diseñada específicamente para almacenar un valor que llamamos <code>data</code> y la única manera de llegar a ese valor es a través del método <code>map</code>. En esta instancia <code>map</code> recibe una función <code>fn</code> (un callback) como argumento, aplica esta función a <code>data</code> y coloca el resultado de la función en una nueva <code>Caja</code>. No todos los functores lucen así, pero en general todos siguen este patrón. Ahora vamos a usarlo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>xbox </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Caja</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span>
</span><span>xbox</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(to_uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; X
</span><span style=color:#5f6364>// =&gt; Object { map: map() }
</span></code></pre><p>Entonces, tenemos esta <code>Caja</code> que es um... totalmente inútil. Sip, y eso es a propósito. Verán, lo que tenemos aquí es el functor <code>Identidad</code>. Su utilidad en el "mundo real" es debatible pero para ilustrar el patrón de los functors con fines educativos funciona de maravilla.<p>Muy bonito todo ¿Pero cuáles son los beneficios que nos traen estas cosas, los functores? Al agregar esta pequeña abstracción obtenemos la habilidad de separar un "efecto" de una computación pura. Para aclarar un poco mi punto vamos a darle un vistazo a un functor que sí tiene un propósito.<h3 id=un-rostro-familiar>Un rostro familiar</h3><p>No sé si están al tanto o no pero les diré de todas formas, los arreglos siguen el patrón que les acabo de describir. Prueben esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>xbox </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span>
</span><span>xbox</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(to_uppercase)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array [ &quot;X&quot; ]
</span></code></pre><p>El arreglo es un contenedor, tiene un método <code>map</code> el cual nos permite transformar el contenido del arreglo, y los nuevos valores que se originan de la función son puestos nuevamente en un arreglo.<p>Bien, pero ahora ¿Cuál es el "efecto" de un arreglo? Ellos nos permiten almacenar múltiples valores en una sola estructura, eso es lo que hacen. <code>Array.map</code> en particular se asegura de aplicar una función a cada elemento del arreglo. No importa si tienen un arreglo con 100 elementos o uno que esté vacío, <code>.map</code> se encarga de la lógica que dicta <strong>cuando</strong> debe ejecutarse la función para que ustedes se concentren en <strong>qué</strong> deben hacer con el elemento dentro de la estructura.<p>Y por supuesto los functores se pueden usar para muchas otras cosas, como el manejo de errores o validar la ausencia de valores e incluso para procesos asíncronos. Me gustaría seguir hablando de este tema pero debemos seguir con la definición de mónada.<h2 id=la-parte-puntiaguda>La parte puntiaguda</h2><p>Necesitamos que nuestros functores sean "puntiagudos". Esta es una manera graciosa de decirnos que necesitamos una función auxiliar que pueda colocar cualquier valor ordinario dentro de la unidad más simple de nuestra estructura. Esta función es conocida como "pure", otros nombres también incluyen "unit" y "of".<p>Volvamos a visitar a nuestro viejo amigo <code>Array</code>. ¿Si colocamos un valor dentro de la unidad más simple de una arreglo, qué tenemos? Sí, un arreglo con un solo elemento. Curiosamente hay una función que puede hacer eso por nosotros.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>¿en serio?</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array [ &quot;¿en serio?&quot; ]
</span><span>
</span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#f99157>42</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array [ 42 ]
</span><span>
</span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#f99157>null</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array [ null ]
</span></code></pre><p>Algo como esto puede ser especialmente útil si la forma normal de crear un functor es complicada. Con esta función podríamos envolver cualquier valor que queramos y empezar a usar <code>.map</code> inmediatamente. Podría contarles más sobre esta función pero esa es básicamente la idea. Sigamos.<h2 id=a-planilandia>A Planilandia</h2><p>Ya estamos llegando al corazón del problema. Esperen... ¿cuál es exactamente el problema?<p>Imaginen esta situación, tenemos un número en una <code>Caja</code> y queremos usar <code>.map</code> para aplicar una función que llamaremos <code>accion</code>. Algo así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>numero </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Caja</span><span>(</span><span style=color:#f99157>41</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>accion </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>numero</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>Caja</span><span>(numero </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>resultado </span><span style=color:#5fb3b3>= </span><span>numero</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(accion)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Todo parece estar bien hasta que nos damos cuenta que <code>accion</code> nos regresa otra <code>Caja</code>. Entonces <code>resultado</code> es de hecho una <code>Caja</code> dentro de otra <code>Caja</code>: <code>Caja(Caja(42))</code>. Ahora para acceder al valor tendríamos que hacer esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>resultado</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>caja</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>caja</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>valor</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{</span><span style=color:#5f6364>/* código */</span><span style=color:#5fb3b3>}</span><span>))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Eso no está bien. Nadie quiere lidiar con una estructura así. Aquí es donde las mónadas pueden ayudarnos. Ellas nos dan la "habilidad" de fusionar estas capas innecesarias que crean una estructura anidada. En nuestro caso puede transformar <code>Caja(Caja(42))</code> en <code>Caja(42)</code>. ¿Cómo? Con la ayuda de un método llamado <code>join</code>.<p>Así sería la implementación en nuestra <code>Caja</code>.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function Caja(data) {
</span><span>    return {
</span><span>      map(fn) {
</span><span>        return Caja(fn(data));
</span><span>      },
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     join() {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return data;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     }
</span><span>    }
</span><span>  }
</span></code></pre><p>Ya sé lo que están pensando, no parece que esté fusionando nada. Quizá hasta estén pensando en cambiarle el nombre al método y ponerle "extract". Sólo esperen un momento. Volvamos a nuestro ejemplo con <code>accion</code>, vamos a arreglarlo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>resultado </span><span style=color:#5fb3b3>= </span><span>numero</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(accion)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>()</span><span style=color:#5fb3b3>;
</span></code></pre><p>Ahora sí tenemos una <code>Caja(42)</code>, con esto podemos acceder al valor que queremos usando un solo <code>.map</code>. ¿Qué? ¿Por qué me miran así? Bien, digamos que le cambio el nombre. Ahora es así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>resultado </span><span style=color:#5fb3b3>= </span><span>numero</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(accion)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>extract</span><span>()</span><span style=color:#5fb3b3>;
</span></code></pre><p>Este es el problema, si leo esa línea por sí sola yo asumiría que <code>resultado</code> es un valor ordinario, algo que pueda usar libremente, me voy a molestar un poco cuando descubra que en realidad tengo una <code>Caja</code>. Por otra parte, si veo <code>join</code> sé que <code>resultado</code> aún es una mónada y puedo prepararme para ello.<p>Ahora pueden estar pensando "Bien, ya entendí ¿Pero sabes qué? Yo uso javascript, simplemente voy a ignorar totalmente los functores y no necesitaré esas mónadas". Totalmente válido, pueden hacer eso. La mala noticia es que <strong>los arreglos son functores</strong> así que no pueden escapar de ellos. La buena noticia es que <strong>los arreglos son mónadas</strong> así que cuando se encuentren con ese problema de estructuras anidadas (y lo harán) pueden arreglarlo fácilmente.<p>Los arreglos no tienen un método <code>join</code>... bueno, sí lo tienen pero se llama <code>flat</code>. Contemplen.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>[[</span><span style=color:#f99157>41</span><span>]</span><span style=color:#5fb3b3>, </span><span>[</span><span style=color:#f99157>42</span><span>]]</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flat</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array [ 41, 42 ]
</span></code></pre><p>Y ahí lo tienen, después de llamar a <code>flat</code> pueden seguir con sus vidas sin tener que preocuparse por "capas" innecesarias entorpeciendo su camino. Eso es todo, en la práctica esto es básicamente el problema que las mónadas resuelven.<p>Pero antes de irme quiero decirles una cosa más.<h2 id=monadas-en-secuencia>Mónadas en secuencia</h2><p>Resulta que esta combinación de <code>map/join</code> es tan común que hay un método que combina las características de esos dos. Este también tiene varios nombres: "chain", "flatMap", "bind", ">>=" (en haskell). Los arreglos lo llaman <code>flatMap</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>split </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>str </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>/</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>some/stuff</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>another/thing</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(split)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// =&gt; Array(4) [ &quot;some&quot;, &quot;stuff&quot;, &quot;another&quot;, &quot;thing&quot; ]
</span></code></pre><p>¿Acaso no es genial? En lugar de tener dos arreglos anidados sólo tenemos un gran arreglo. Esto es mucho más fácil de manejar que una estructura anidada.<p>Pero esto no sólo es para ahorrar unos cuantos caracteres, también fomenta la composición de funciones de la misma forma que <code>.map</code> lo hace. Podrían hacer algo como esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>monad</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(action)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(another)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(cool)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(getItNow)</span><span style=color:#5fb3b3>;
</span></code></pre><p>No estoy diciendo que hagan esto con los arreglos. Les estoy diciendo que si crean sus propias mónadas pueden combinar funciones de esta manera. Sólo tienen que recordar si su función retorna una mónada usan <code>flatMap</code>, si no usan <code>map</code>.<h2 id=conclusion>Conclusión</h2><p>Aprendimos que las mónadas son functores con características extras. En otras palabras son contenedores mágicos que... ¿no les gusta tener otros contenedores internamente? Intentemos nuevamente: son como cebollas mágicas que... no importa, son mágicos, dejémoslo así.<p>Podemos usarlos para añadir un "efecto" a cualquier valor ordinario. Podemos usarlos para el manejo de errores, operaciones asíncronas, controlar efectos secundarios, y un montón de cosas más.<p>También aprendimos que a las mónadas se les quiere o se les tiene un odio irracional, y no hay ningún punto medio.<h2 id=fuentes>Fuentes</h2><ul><li><a rel=noopener target=_blank href=https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/ch09.html>Professor Frisby's Mostly Adequate Guide to Functional Programming. Chapter 9: Monadic Onions</a><li><a rel=noopener target=_blank href=https://github.com/thefrontside/funcadelic.js>Funcadelic.js</a><li><a rel=noopener target=_blank href=https://github.com/fantasyland/fantasy-land>Fantasy Land</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario
en cualquiera de estas plataformas:<ul><li><a rel=noopener target=_blank href=https://dev.to/vonheikemen/una-introduccion-a-las-monadas-en-javascript-4hg0>dev.to</a><li><a rel=noopener target=_blank href=https://vonheikemen.hashnode.dev/an-introduction-to-monads-in-js-es>Hashnode</a></ul><p>Puedes contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" target=_blank href=https://twitter.com/VonHeikemen_>@VonHeikemen_</a><li>Mastodon <a rel="noopener me" target=_blank href=https://hachyderm.io/@vonheikemen>@vonheikemen@hachyderm.io</a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>