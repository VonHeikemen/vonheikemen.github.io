<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Observables hechos en casa | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, paradigma-reactivo, aprendizaje, software, coding, development" name=keywords><meta content="Creando un observable como los de RxJS desde cero" name=description><link href=https://dev.to/vonheikemen/observables-hechos-en-casa-1bch rel=canonical><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2024 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Observables hechos en casa</h1><span class=post-date>2019-11-24 | Originalmente publicado en <a href=https://dev.to/vonheikemen/observables-hechos-en-casa-1bch> dev.to </a> | 10 minutos | <a href=https://vonheikemen.github.io/devlog/web-development/homemade-observables/> Read in english </a> </span><p>En esta ocasión implementaremos nuestros propios observables. Al terminar espero que tengan un mejor entendimiento de cómo este patrón es usado en librerías como RxJS.<h2 id=los-observables>Los Observables</h2><h3 id=que-son>¿Qué son?</h3><p>Empecemos con <strong>mi</strong> definición de observable.<blockquote><p>Un Observable es una función que sigue una convención y es usada para conectar una fuente que emite datos a un consumidor.</blockquote><p>En nuestro caso la fuente puede ser cualquier cosa produzca valores. Y, un consumidor es el que recibe datos.<h3 id=datos-curiosos>Datos curiosos</h3><h4 id=los-observables-no-hacen-nada-por-si-solos>Los Observables no hacen nada por sí solos</h4><p>Quiero decir que estos no producen ningún efecto o comienzan a trabajar hasta que es absolutamente necesario. No hacen nada hasta que te suscribes a ellos.<h4 id=pueden-emitir-datos>Pueden emitir datos</h4><p>Dependendiendo de la fuente, pueden recibir un número infinito de valores.<h4 id=pueden-ser-sincronos-o-asincronos>Pueden ser síncronos o asíncronos</h4><p>Todo dependerá de su implementación. Se puede crear un observable que reciba valores de un evento que puede ocurrir en cualquier momento, también se pueden crear para procesar una colección de datos de manera síncrona.<h3 id=algunas-reglas>Algunas reglas</h3><p>Ya mencioné que se debe seguir una convención. Bueno, ahora vamos a definir algunas reglas arbitrarias que nuestra implementación va a seguir. Estas son importantes porque crearemos un pequeño ecosistema con nuestros observables.<ol><li>Deberán tener un método <code>subscribe</code>.<li>Nuestro "constructor" de observables aceptará un parámetro, será el suscriptor (<code>subscriber</code>) el cual será una función.<li>El suscriptor aceptará un parámetro, este será un objeto que llamaremos <code>observer</code>.<li>El objeto <code>observer</code> puede implementar los siguientes métodos: <code>next</code>, <code>error</code> y <code>complete</code>.</ol><p>Empecemos.<h3 id=el-codigo>El código</h3><h3 id=constructor>Constructor</h3><pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>Observable</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>subscriber</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#6699cc>subscribe</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>observer </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>subscriber</span><span>(observer)
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// Se los juro, esto funciona
</span></code></pre><p>Tal vez es menos mágico de lo que pensaron. Lo que vemos aquí es que el constructor <strong>Observable</strong> sólo es una forma de posponer el trabajo hasta que se ejecuta <code>subscribe</code>. La función <code>subscriber</code> es la que hace el trabajo pesado, eso es bueno porque podemos hacer lo que sea ahí, es lo que hace que nuestros observable sean útiles.<p>Hasta ahora no he explicado el rol de <code>observer</code> o <code>subscriber</code>. Es mejor explicarlo con un ejemplo.<h2 id=un-ejemplo>Un ejemplo</h2><p>Digamos que queremos convertir un arreglo en un Observable. ¿Cómo lo hacemos?<p>Pensemos en lo que sabemos hasta ahora:<ul><li>Podemos colocar la lógica dentro de la función <code>subscriber</code>.<li>Podemos contar con que nuestro objeto <code>observer</code> tendrá uno de estos tres métodos <code>next</code>, <code>error</code> y <code>complete</code></ul><p>Podemos usar los métodos de <code>observer</code> como canales de cómunicación. La función <code>next</code> recibirá los valores que nos de la fuente. Utilizaremos <code>error</code> cuando algo salga mal, algo así como el método <code>catch</code> que tienen las promesas. Por último, utilizaremos <code>complete</code> cuando la fuente deje de producir valores.<p>La función para convertir un arreglo a observable puede ser así.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>fromArray</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arr</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>observer</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>try </span><span style=color:#5fb3b3>{
</span><span>      arr</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>forEach</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span>      observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>complete</span><span>()</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>catch </span><span>(e) </span><span style=color:#5fb3b3>{
</span><span>      observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>error</span><span>(e)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// Así la usamos
</span><span>
</span><span style=color:#c594c5>var </span><span>arrayStream </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>fromArray</span><span>([</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>4</span><span>])</span><span style=color:#5fb3b3>;
</span><span>
</span><span>arrayStream</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#6699cc>next</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(value)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>error</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>err </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>error</span><span>(err)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>complete</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>info</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>Listo</span><span style=color:#5fb3b3>'</span><span>)
</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Y ahora a ver qué pasa en la cónsola.
</span></code></pre><h3 id=tengan-cuidado>Tengan cuidado</h3><p>Justo ahora nuestros observables básicamente son como un pueblo sin ley, podemos hacer todo tipo de cosas indebidas como seguir enviando valores después de llamar el método <code>complete</code>. En un mundo ideal nuestros observables deberían darnos algunas garantías.<ul><li>Los métodos del objeto <code>observer</code> deberían ser opcionales.<li>Los métodos <code>complete</code> y <code>error</code> deberían llamar una función para dejar de observar, una función <code>unsubscribe</code> (si esta existe).<li>Si ejecutas <code>unsubscribe</code> yo no podrás ejecutar los demás métodos.<li>Si se ejecuta <code>complete</code> o <code>error</code> se dejarán de recibir valores.</ul><h3 id=un-ejemplo-interactivo>Un ejemplo interactivo</h3><p>Ya podemos empezar a hacer cosas interesantes con lo que tenemos hasta ahora. En este ejemplo hice una función que nos permite crear un observable de un evento.<p data-pen-title="Observables - basics" style="height:600px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border:2px solid;margin:1em 0;padding:1em" class=codepen data-default-tab=js,result data-height=600 data-preview=true data-slug-hash=wxNYPV data-theme-id=dark data-user=VonHeikemen><span> See the Pen <a href=https://codepen.io/VonHeikemen/pen/wxNYPV>Observables - basics</a> by Heiker (<a href=https://codepen.io/VonHeikemen>@VonHeikemen</a>) on <a href=https://codepen.io>CodePen</a>. </span></p><script async src=https://static.codepen.io/assets/embed/ei.js></script><h2 id=composicion>Composición</h2><p>Ahora que sabemos cómo crearlos veamos cómo podemos manipularlos para extender sus capacidades.<p>Esta vez lo que haremos será crear funciones complementarias y modificar nuestra implementación.<h3 id=todo-esta-en-los-operadores>Todo está en los operadores</h3><p>Los operadores son funciones que nos permitirán agregar características a nuestros observables mediante una cadena de funciones. Cada una de estas funciones aceptará un observable como parámetro, lo convertirá en su fuente y devolverá un nuevo observable.<p>Sigamos con la temática del arreglo y hagamos un operador <strong>map</strong> que intente imitar el comportamiento del método nativo map que tienen los arreglos. Nuestro operador hará lo siguiente: tomará un valor, aplicará una función sobre ese valor y emitirá el resultado.<p>Hagamos el intento:<p>Primer paso, vamos a recibir la función y la fuente de datos, luego devolveremos un observable.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transformFn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>source$</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>observer</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// continuará
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ahora viene lo interesante, la fuente que recibimos es un observable y eso significa que podemos suscribirnos para recibir valores.<pre class=language-diff data-lang=diff style=background:#2b2c2f;color:#cccece><code class=language-diff data-lang=diff><span> function map(transformFn, source$) {
</span><span>   return Observable(function(observer) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>    return source$.subscribe(function(value) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>      // continuará
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>    });
</span><span>   });
</span><span> }
</span></code></pre><p>Lo siguiente será pasar el resultado de la transformación a <code>observer</code> para que puedan "verlo" cuando se suscriban a este nuevo observable.<pre class=language-diff data-lang=diff style=background:#2b2c2f;color:#cccece><code class=language-diff data-lang=diff><span> function map(transformFn, source$) {
</span><span>   return Observable(function(observer) {
</span><span>     return source$.subscribe(function(value) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>      var newValue = transformFn(value);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>      observer.next(newValue);
</span><span>     });
</span><span>   });
</span><span> }
</span></code></pre><p>Hay otra forma de hacer esto. Si usamos funciones de una expresión (Arrow functions como se les conoce por ahí) sería algo así.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transformFn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>source$</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#f99157>observer </span><span style=color:#c594c5>=> 
</span><span>    source$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(
</span><span>      </span><span style=color:#6699cc>transformFn</span><span>(value)
</span><span>    ))
</span><span>  )</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ya podemos empezar a usarlo pero justo ahora tendríamos que hacerlo de esta manera.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>fromArray</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arr</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>observer</span><span style=color:#5fb3b3>) {
</span><span>    arr</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>forEach</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span>    observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>complete</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>var </span><span>thisArray </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>4</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>var </span><span style=color:#6699cc>plusOne   </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>num </span><span style=color:#c594c5>=> </span><span>num </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>var </span><span>array$    </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>map</span><span>(plusOne</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>fromArray</span><span>(thisArray))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>array$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(value))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Eso no es muy cómodo. Y si queremos seguir usando más funciones <code>map</code> tendríamos que "envolverlas", no me parece bien. Nos ocuparemos de eso ahora.<h3 id=la-cadena>La cadena</h3><p>Crearemos otro método que nos permitirá usar una cadena de operadores que extenderan un observable fuente. Esta función tomará una lista de funciones, cada función en la lista usará el observable retornado por la anterior.<p>Primero veamos como podría hacerse esto en una función aislada.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>pipe</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>aFunctionArray</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>initialSource</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>var </span><span style=color:#6699cc>reducerFn </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>source</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>var </span><span>result </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>fn</span><span>(source)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>return </span><span>result</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span>
</span><span>  </span><span style=color:#c594c5>var </span><span>finalResult </span><span style=color:#5fb3b3>= </span><span>aFunctionArray</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>reduce</span><span>(reducerFn</span><span style=color:#5fb3b3>, </span><span>initialSource)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>finalResult</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Aquí usamos <code>reduce</code> para recorrer el arreglo de funciones y por cada elemento se ejecuta <code>reducerFn</code>. Dentro de <code>reducerFn</code> en el primer recorrido <code>source</code> tendrá el valor de <code>initialSource</code> y en el resto <code>source</code> será lo que <code>reducerFn</code> retorne. <code>finalResult</code> simplemente es el último resultado de <code>reducerFn</code>.<p>Con algunos ajustes a nuestro constructor podemos agregar esta función. También he reducido la implementación del método <code>pipe</code> con algo de ayuda.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>Observable </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>subscriber</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>var </span><span>observable </span><span style=color:#5fb3b3>= {
</span><span>    </span><span style=color:#6699cc>subscribe</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>observer </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>subscriber</span><span>(</span><span style=color:#6699cc>SafeObserver</span><span>(observer))</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#6699cc>pipe</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>function </span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>return </span><span>fns</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>reduce</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>source</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(source)</span><span style=color:#5fb3b3>, </span><span>observable)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>observable</span><span style=color:#5fb3b3>; 
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Aún tenemos que hacer una cosa para asegurarnos que los operadores sean compatibles con el método <code>pipe</code>. Justo ahora el operador <code>map</code> espera tanto <code>transformFn</code> como <code>source</code>, eso no funcionará cuando usemos <code>pipe</code>. Tendremos que dividirlo en dos funciones, una que reciba el parámetro inicial y otra que acepte la fuente.<p>Tenemos opciones.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#5f6364>// Opción 1
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transformFn</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>  </span><span style=color:#5f6364>// En lugar de devolver el observable
</span><span style=color:#5fb3b3>  </span><span style=color:#5f6364>// regresamos una función que espera `source`
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#f99157>source$ </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#f99157>observer </span><span style=color:#c594c5>=> 
</span><span>    source$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(
</span><span>      </span><span style=color:#6699cc>transformFn</span><span>(value)
</span><span>    ))
</span><span>  )</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// Opción 2
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transformFn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>source$</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(source$ </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>undefined</span><span>) </span><span style=color:#5fb3b3>{
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// en caso de no recibir `source` 
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// devolvemos una función una que recuerde `transformFn` 
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// y que espere `source`    
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#f99157>placeholder </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>map</span><span>(transformFn</span><span style=color:#5fb3b3>, </span><span>placeholder)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#f99157>observer </span><span style=color:#c594c5>=> 
</span><span>    source$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(
</span><span>      </span><span style=color:#6699cc>transformFn</span><span>(value)
</span><span>    ))
</span><span>  )</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Y ya finalmente podemos extender nuestros observables así.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>var </span><span>thisArray </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>4</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>var </span><span style=color:#6699cc>plusOne   </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>num </span><span style=color:#c594c5>=> </span><span>num </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>var </span><span style=color:#6699cc>timesTwo  </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>num </span><span style=color:#c594c5>=> </span><span>num </span><span style=color:#5fb3b3>* </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>var </span><span>array$ </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>fromArray</span><span>(thisArray)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>pipe</span><span>(
</span><span>  </span><span style=color:#6699cc>map</span><span>(plusOne)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>map</span><span>(timesTwo)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>map</span><span>(</span><span style=color:#f99157>num </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>number: </span><span style=color:#5fb3b3>${</span><span>num</span><span style=color:#5fb3b3>}`</span><span>)</span><span style=color:#5fb3b3>,
</span><span style=color:#5fb3b3>  </span><span style=color:#5f6364>// y otros...
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>array$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(value))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Estamos listos para crear más operadores.<h2 id=otro-ejercicio>Otro ejercicio</h2><p>Digamos que tenemos una función que muestra la hora en la cónsola cada segundo, y se detiene después de cinco segundos (sólo porque sí).<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>startTimer</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>var </span><span>time </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>var </span><span>interval </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>setInterval</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() {
</span><span>    time </span><span style=color:#5fb3b3>= </span><span>time </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span>    </span><span style=color:#c594c5>var </span><span>minutes </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>Math</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>floor</span><span>((time </span><span style=color:#5fb3b3>/ </span><span style=color:#f99157>60</span><span>) </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>60</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toString</span><span>()</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>padStart</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, '</span><span style=color:#99c794>0</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>var </span><span>seconds </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>Math</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>floor</span><span>(time </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>60</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toString</span><span>()</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>padStart</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, '</span><span style=color:#99c794>0</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>var </span><span>timeString </span><span style=color:#5fb3b3>= </span><span>minutes </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>:</span><span style=color:#5fb3b3>' + </span><span>seconds</span><span style=color:#5fb3b3>;
</span><span>
</span><span>    </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(timeString)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>    </span><span style=color:#c594c5>if</span><span>(timeString </span><span style=color:#5fb3b3>=== '</span><span style=color:#99c794>00:05</span><span style=color:#5fb3b3>'</span><span>) </span><span style=color:#5fb3b3>{
</span><span>      </span><span style=color:#6699cc>clearInterval</span><span>(interval)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}, </span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ahora bien, esa función no tiene nada de malo. Digo, hace su trabajo, es predecible y todo lo que necesitas saber está a plena vista. Pero recien aprendimos algo nuevo y queremos aplicarlo. Convertiremos esto en un observable.<p>Primero lo primero, vamos a extraer la lógica que maneja el formateo y el cálculo del tiempo.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>paddedNumber</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>num</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>num</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toString</span><span>()</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>padStart</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, '</span><span style=color:#99c794>0</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>readableTime</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>time</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>var </span><span>minutes </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>Math</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>floor</span><span>((time </span><span style=color:#5fb3b3>/ </span><span style=color:#f99157>60</span><span>) </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>60</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>var </span><span>seconds </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>Math</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>floor</span><span>(time </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>60</span><span>)</span><span style=color:#5fb3b3>;
</span><span> 
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>paddedNumber</span><span>(minutes) </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>:</span><span style=color:#5fb3b3>' + </span><span style=color:#6699cc>paddedNumber</span><span>(seconds)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Veamos qué hacemos con el tiempo. <code>setInterval</code> es un buen candidato para convertirse una fuente, recibe un "callback" en el cual podemos producir valores y también tiene un mecanismo de "limpieza". Es un buen observable.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#c594c5>function </span><span style=color:#6699cc>interval</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>delay</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>observer</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>var </span><span>counter   </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>var </span><span style=color:#6699cc>callback  </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=> </span><span>observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(counter</span><span style=color:#5fb3b3>++</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>var </span><span>_interval </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>setInterval</span><span>(callback</span><span style=color:#5fb3b3>, </span><span>delay)</span><span style=color:#5fb3b3>;
</span><span>    
</span><span>    observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>setUnsubscribe</span><span>(</span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>clearInterval</span><span>(_interval))</span><span style=color:#5fb3b3>;
</span><span>    
</span><span>    </span><span style=color:#c594c5>return </span><span>observer</span><span style=color:#5fb3b3>.</span><span>unsubscribe</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Tenemos una forma reusable de crear y destruir un <code>interval</code>.<p>Puede que hayan notado que le pasamos un número a <code>observer</code>, no lo llamamos "segundos" porque <code>delay</code> puede ser cualquier número. Aquí no estamos siguiendo el tiempo, estamos contando las veces que <code>callback</code> es ejecutado. ¿Por qué? Porque queremos que nuestros constructores sean genéricos. Siempre podremos modificar su comportamiento con operadores.<p>Así usamos nuestro nuevo constructor.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#5f6364>// fingiremos que las demás funciones están por aquí
</span><span>
</span><span style=color:#c594c5>var </span><span>time$ </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>interval</span><span>(</span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>pipe</span><span>(
</span><span>  </span><span style=color:#6699cc>map</span><span>(plusOne)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>map</span><span>(readableTime)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>var </span><span>unsubscribe </span><span style=color:#5fb3b3>= </span><span>time$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>timeString</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(timeString)</span><span style=color:#5fb3b3>;
</span><span>  
</span><span>  </span><span style=color:#c594c5>if</span><span>(timeString </span><span style=color:#5fb3b3>=== '</span><span style=color:#99c794>00:05</span><span style=color:#5fb3b3>'</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#6699cc>unsubscribe</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Está mejor. Pero ese <code>if</code> me molesta. Como que no debería estar ahí. ¿Saben que podemos hacer? Crear otro operador, uno que cancele la suscripción después de que <code>interval</code> emita cinco valores.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span>
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>take</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>total</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#f99157>source$ </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>Observable</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>observer</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// tendremos nuestro propio contador porque no confío
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// en los valores que emiten otros observables
</span><span>    </span><span style=color:#c594c5>var </span><span>count </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>var </span><span>unsubscribeSource </span><span style=color:#5fb3b3>= </span><span>source$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>      count</span><span style=color:#5fb3b3>++;
</span><span style=color:#5fb3b3>      </span><span style=color:#5f6364>// pasamos cada valor a `observer`
</span><span style=color:#5fb3b3>      </span><span style=color:#5f6364>// la función subscribe aún recibirá cada valor original
</span><span>      observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>next</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>      
</span><span>      </span><span style=color:#c594c5>if </span><span>(count </span><span style=color:#5fb3b3>=== </span><span>total) </span><span style=color:#5fb3b3>{
</span><span style=color:#5fb3b3>        </span><span style=color:#5f6364>// indicamos que el flujo a terminado y lo "destruimos"
</span><span>        observer</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>complete</span><span>()</span><span style=color:#5fb3b3>;
</span><span>        </span><span style=color:#6699cc>unsubscribeSource</span><span>()</span><span style=color:#5fb3b3>;
</span><span>      </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ya tenemos un contador que se autodestruye. Finalmente.<pre class=language-javascript data-lang=javascript style=background:#2b2c2f;color:#cccece><code class=language-javascript data-lang=javascript><span style=color:#5f6364>// las otras funciones siguen ahí
</span><span>
</span><span style=color:#c594c5>var </span><span>time$ </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>interval</span><span>(</span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>pipe</span><span>(
</span><span>  </span><span style=color:#6699cc>map</span><span>(plusOne)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>map</span><span>(readableTime)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>take</span><span>(</span><span style=color:#f99157>5</span><span>)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>time$</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>subscribe</span><span>(</span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#6699cc>next</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>timeString </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(timeString)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#6699cc>complete</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>info</span><span>(</span><span style=color:#5fb3b3>"</span><span style=color:#99c794>Time's up</span><span style=color:#5fb3b3>"</span><span>)
</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><h2 id=patio-de-juegos>Patio de juegos</h2><p>Hice un par de ejemplos en codepen para poder hacer experimentos con estas cosas. <a href=https://codepen.io/VonHeikemen/pen/OwQYxG rel=noopener target=_blank>Este de aquí</a> contiene todos el código relacionado con <code>Observable</code> y algo más.<p>Y este de aquí es el del ejercicio.<p data-pen-title="Observables - boring timer" style="height:600px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border:2px solid;margin:1em 0;padding:1em" class=codepen data-default-tab=js,result data-height=600 data-preview=true data-slug-hash=VGZXZa data-theme-id=dark data-user=VonHeikemen><span> See the Pen <a href=https://codepen.io/VonHeikemen/pen/VGZXZa>Observables - boring timer</a> by Heiker (<a href=https://codepen.io/VonHeikemen>@VonHeikemen</a>) on <a href=https://codepen.io>CodePen</a>. </span><h2 id=conclusion>Conclusión</h2><p>Los Observables nos permiten hacer muchas cosas y con un algo de creatividad puedes convertir lo que sea en un observable. En serio, una promesa (Promise), una petición AJAX, un evento en el DOM, un arreglo... otro observable. Todo lo que se pueden imaginar puede ser una fuente de datos que pueden envolver en un observable. También nos dan habilidad de ensamblar soluciones utilizando funciones genéricas y otras más específicas.<p>Aún así no son la solución perfecta para todo. Tendrán que decidir si la complejidad que traen vale la pena. Como en el ejemplo del intervalo, perdimos la simplicidad de <code>startTimer</code> por la "flexibilidad" de los observables.<h2 id=fuentes>Fuentes</h2><ul><li><a href=https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87 rel=noopener target=_blank>Learning Observable By Building Observable</a><li><a href=https://medium.com/@kevinkreuzer/observables-just-powerful-functions-a033c355b22c rel=noopener target=_blank>Observables, just powerful functions?</a><li><a href=https://netbasal.com/whos-afraid-of-observables-bde0dc4f48cc rel=noopener target=_blank>Who’s Afraid of Observables?</a><li><a href=https://netbasal.com/understanding-mergemap-and-switchmap-in-rxjs-13cf9c57c885 rel=noopener target=_blank>Understanding mergeMap and switchMap in RxJS</a><li><a href=https://netbasal.com/javascript-observables-under-the-hood-2423f760584 rel=noopener target=_blank>JavaScript — Observables Under The Hood</a><li><a href=https://github.com/zenparsing/zen-observable rel=noopener target=_blank>Github repository - zen-observable</a><li><a href=https://dev.to/supermanitu/understanding-observables rel=noopener target=_blank>Understanding Observables</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/observables-hechos-en-casa-1bch rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/homemade-observables-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=height:60px!important;width:217px!important> </a></div></div>