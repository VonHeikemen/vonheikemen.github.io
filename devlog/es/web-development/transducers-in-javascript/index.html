<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Transductores en javascript | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="javascript,paradigma-funcional,software,coding,development"><meta name=description content="Vamos a adentrarnos un poco en el mundo de los transductores (en javascript)"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2022 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Transductores en javascript</h1><span class=post-date>2020-12-27
| 20 minutos
| <a href=https://vonheikemen.github.io/devlog/web-development/transducers-in-javascript/>Read in english</a></span><p>¿Qué pasaría si pudiéramos extraer la idea detrás de operaciones como <code>map</code> y <code>filter</code> y aplicarlas a otro tipo de colecciones más allá de los arreglos? ¿Y si les digo que puedo implementar <code>filter</code> una sola vez y reusar ese mismo código en diferentes tipos de colecciones? Esa es la premisa de los transductores. Hoy vamos a aprender qué son, cómo funcionan y cómo se usan.<h2 id=requerimientos>Requerimientos</h2><p>Antes de comenzar hay un par de cosas que necesitan saber:<ul><li><a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/reduce-how-and-when/>Cómo funciona Array.reduce</a><li><a href=https://vonheikemen.github.io/devlog/es/web-development/the-case-for-reducers/>Qué es un reducer</a></ul><p>También es recomendado que tengan familiaridad con los siguientes conceptos:<ul><li>Funciones de primera clase<li>Funciones de orden superior<li>Cierres (closures)</ul><p>Y si no están al tanto de qué significa todo eso, no se preocupen. Sólo deben saber que en javascript podemos tratar a las funciones como cualquier otro tipo de dato.<p>Comencemos.<h2 id=que-son-los-transductores>¿Qué son los transductores?</h2><p>La palabra transductor tiene una larga historia. Si buscan su definición se van a encontrar con algo como esto:<blockquote><p>Un transductor es un dispositivo capaz de transformar o convertir una determinada manifestación de energía de entrada, en otra diferente de salida...
-- <a rel=noopener target=_blank href=https://es.wikipedia.org/wiki/Transductor>Wikipedia</a></blockquote><p>Definitivamente no estamos hablando de dispositivos físicos en este artículo. Pero sí se acerca a lo que queremos, el objetivo principal de un transductor (en nuestro contexto) será procesar los datos de una colección y potencialmente convertir esa colección de un tipo de dato a otro.<p>Para nuestros propósitos una definición más cercana a lo que queremos sería esta:<blockquote><p>Transformaciones algorítmicas combinables.</blockquote><p>Ya sé, no parece que esa tampoco ayude mucho. Bueno, la idea aquí es básicamente combinar procesos de una manera declarativa, y también que sea reusable en diferentes estructuras. Eso es todo. Pero claro es más fácil decirlo que hacerlo.<p>¿Cómo logramos todo eso?<p>Buena pregunta. Esto será todo un viaje, mejor empecemos con pasos pequeños. Primero preguntemos...<h2 id=por-que>¿Por qué?</h2><p>Usemos un ejemplo para responder eso. Imaginemos un escenario común. Digamos que tenemos un arreglo y queremos filtrarlo. ¿Cómo lo hacemos? Usamos el método <code>.filter</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ 2 ]
</span></code></pre><p>Todo se ve bien. Ahora nos llega otro requerimiento, tenemos que transformar los valores que pasan la prueba de la función <code>is_even</code>. No hay problema porque podemos usar <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>add_message </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>The number is: </span><span style=color:#5fb3b3>${</span><span>number</span><span style=color:#5fb3b3>}`;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(add_message)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ &quot;The number is: 2&quot; ]
</span></code></pre><p>Genial. Todo funciona bien hasta que un día, por razones que no vamos discutir, nos vemos obligados a convertir <code>data</code> en un <a rel=noopener target=_blank href=https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Set>Set</a>. Después de hacer el cambio nos topamos con este mensaje.<pre style=background-color:#2b2c2f;color:#cccece><code><span>Uncaught TypeError: data.filter is not a function
</span></code></pre><p>¿Cómo podemos resolver esto? Una forma sería usar el ciclo <code>for..of</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>add_message </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>The number is: </span><span style=color:#5fb3b3>${</span><span>number</span><span style=color:#5fb3b3>}`;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= new </span><span>Set([</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>])</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>filtered </span><span style=color:#5fb3b3>= new </span><span>Set()</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>let </span><span>number </span><span style=color:#5fb3b3>of </span><span>data) </span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#69c>is_even</span><span>(number)) </span><span style=color:#5fb3b3>{
</span><span>    filtered</span><span style=color:#5fb3b3>.</span><span style=color:#69c>add</span><span>(</span><span style=color:#69c>add_message</span><span>(number))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span>filtered</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Set [ &quot;The number is: 2&quot; ]
</span></code></pre><p>La buena noticia es que esto funciona con cualquier estructura que implemente el <a rel=noopener target=_blank href=https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Iteration_protocols>protocolo de iteración</a>. La mala noticia es que para agregar otra "operación" tenemos que modificar el código de nuestro <code>for</code>.<p>¿Por qué modificar el código sería un problema?<p>Hagamos una comparación. Digamos que tenemos nuestro ciclo en su lugar.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>let </span><span>number </span><span style=color:#5fb3b3>of </span><span>data) </span><span style=color:#5fb3b3>{
</span><span>
</span><span style=color:#5fb3b3>}
</span></code></pre><p>¿Qué hacemos cuando queremos filtrar? Agregamos código dentro del bloque.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  for(let number of data) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   if(is_even(number)) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     filtered.add(number);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span>  }
</span></code></pre><p>¿Qué hacemos cuando queremos transformar? Agregamos código dentro del bloque.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  for(let number of data) {
</span><span>    if(is_even(number)) {
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>     filtered.add(number);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     filtered.add(add_message(number));
</span><span>    }
</span><span>  }
</span></code></pre><p>Eso va ocurrir cada vez que queramos agregar alguna funcionalidad a nuestro ciclo. ¿Alguna vez han escuchado la frase "abierto para extensión, cerrado para modificación"? Es básicamente lo que quiero ilustrar aquí. Para extender el ciclo <code>for</code> necesitamos modificarlo, no es que sea una terrible idea, es sólo que hay una forma más "elegante" de lograr nuestro objetivo.<p>Revisemos nuevamente nuestra primera versión, la que tenía <code>data</code> como un <code>Array</code>. ¿Qué hacemos cuando necesitamos filtrar? Agregamos una función.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>;
</span></code></pre><p>¿Qué hacemos cuando queremos transformar? Agregamos una función.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> data.filter(is_even);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> data.filter(is_even).map(add_message);
</span></code></pre><p>¿Ven a donde quiero llegar? No voy a decir que es mejor, sólo digamos que es más "expresivo". En este caso, para extender nuestro proceso lo que hacemos es combinar funciones.<p>Pero no todo es color de rosas. Ya nos topamos con un problema: no todas las colecciones implementan estos métodos. Y otro problema que podríamos enfrentar tiene que ver con el desempeño, porque cada método es el equivalente a un ciclo <code>for</code>. Así que tal vez no sea una buena idea hacer una larga cadena de <code>filter</code>s y <code>map</code>s.<p>Aquí es donde entran los transductores, con ellos podemos construir una cadena de operaciones de una manera declarativa y eficiente. Aunque no serán tan rápidos como un ciclo <code>for</code>, puede ser una manera de aumentar el desempeño cuando tienen una larga cadena de operaciones actuando sobre una colección con muchos (muchos) elementos.<p>Otra cosa en la que destacan sobre los métodos tradicionales en el prototipo <code>Array</code> es que podemos reusar la misma operación en distintas estructuras. Podemos por ejemplo implementar <code>filter</code> como un transductor una vez y reusamos ese mismo código para los arreglos, <code>Set</code>s, <a rel=noopener target=_blank href=https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/function*>generadores</a> u otro tipo de colecciones. Suena genial, ¿cierto?<h2 id=como-funcionan>¿Cómo funcionan?</h2><p>La magia detrás de los transductores se encuentra dentro de un concepto que mencioné en la sección de requirimientos: <code>reducer</code>. Especificamente <code>reducer</code>s de orden superior. (Se los advertí).<p>Tomen un momento para digerir esta frase: "reducer de orden superior."<p>¿Están listos?<p>Por ahora podemos pensar en un transductor como una función que puede recibir un <code>reducer</code> como argumento y retorna otro <code>reducer</code>. Resulta que (con un poco de magia) podemos combinar <code>reducer</code>s usando composición de funciones. Esta propiedad es la que nos va a permitir armar cadenas de operaciones como en nuestro ejemplo anterior, donde llamamos al método <code>.filter</code> y luego <code>.map</code>. Pero hay una gran diferencia, la manera en la que se combinan de hecho debería ser algo así.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>compose</span><span>(</span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>, </span><span style=color:#69c>map</span><span>(add_message))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Antes de que pregunten, la magia no ocurre en <code>compose</code>. Esa función es bastante genérica. Lo único que hace es pasar el resultado de una función a la otra. Podemos implementarla nosotros mismos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>compose</span><span style=color:#5fb3b3>(...</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>apply </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(arg)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>initial</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>fns</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduceRight</span><span>(apply</span><span style=color:#5fb3b3>, </span><span>initial)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ahora, cuando combinamos varios transductores con <code>compose</code> lo que obtenemos es otro transductor. Pero ese no es el fin de la historia, como ya mencioné un transductor nos devuelve un <code>reducer</code>, ¿Y qué función conocen ustedes que necesite un <code>reducer</code>? Por supuesto, nuestro amigo <code>reduce</code>. <code>reduce</code> será como el "protocolo" que usaremos para recorrer los valores de la colección y hacer algo con ellos.<p>Creo que ya es suficiente de teorías, vamos a la práctica. Para empezar vamos a crear un transductor con la misma funcionalidad de <code>filter</code>.<h3 id=creando-un-transductor>Creando un transductor</h3><h4 id=paso-1-reunir-los-argumentos-necesarios>Paso 1: Reunir los argumentos necesarios</h4><p>Primero lo primero, creamos una función y obtenemos todo lo que necesitamos con los parámetros. ¿Qué necesitamos en este caso? Una función que debería retornar <code>true</code> o <code>false</code>, un predicado.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>) {
</span><span>
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Un buen comienzo pero no es suficiente. Sabemos que en algún momento vamos a combinar este transductor con otro. Lo que necesitamos ahora es aceptar otro <code>reducer</code>, que vendría siendo el siguiente "paso" en la composición. Vamos a agregar eso.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Si aún no está claro, recordemos nuestro ejemplo anterior.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>compose</span><span>(</span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>, </span><span style=color:#69c>map</span><span>(add_message))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Aquí lo que va a pasar es que <code>map(add_message)</code> nos devolverá un <code>reducer</code>. Ese <code>reducer</code> se convertirá en nuestro parámetro <code>next</code>.<p>Ya sé lo que piensan, sólo estoy enviando el argumento <code>is_even</code>. ¿Cómo vamos a obtener <code>next</code>? Vamos a lidiar con eso después. Sigamos.<h4 id=paso-2-retornar-un-reducer>Paso 2: Retornar un reducer</h4><p>En la práctica un <code>reducer</code> no es más que una función binaria. Sólo necesitamos retornar eso.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return function </span><span style=color:#69c>reducer</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// ???
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><h4 id=paso-3-implementa-el-resto>Paso 3: Implementa el resto</h4><p>Bien, ya (casi) terminamos con la estructura del transductor. Lo que viene ahora es la lógica que queremos implementar. En este caso, lo que queremos hacer es replicar el comportamiento de <code>Array.filter</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return function </span><span style=color:#69c>reducer</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#69c>predicate</span><span>(value)) </span><span style=color:#5fb3b3>{
</span><span>      </span><span style=color:#c594c5>return </span><span style=color:#69c>next</span><span>(state</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Aquí tomamos el predicado, lo evaluamos, y decidimos si vamos seguir con el siguiente paso o no hacemos nada.<h4 id=paso-4-aplicacion-parcial>Paso 4: Aplicación parcial</h4><p>Aquí viene la magia. Sabemos cómo queremos usar <code>filter</code> pero justo ahora no va a funcionar. Necesitamos que <code>filter</code> sea lo suficientemente inteligente para saber cuando tiene que ejecutarse, ¿Cuándo es eso? Cuando tenga todos sus argumentos.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#ec5f67>arguments</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>1</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>_next</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>filter</span><span>(predicate</span><span style=color:#5fb3b3>, </span><span>_next)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return function </span><span style=color:#69c>reducer</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#69c>predicate</span><span>(value)) </span><span style=color:#5fb3b3>{
</span><span>      </span><span style=color:#c594c5>return </span><span style=color:#69c>next</span><span>(state</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Esta es sólo una forma de lograr la aplicación parcial. No tiene que ser de esta manera.<h3 id=usando-un-transductor>Usando un transductor</h3><p>Ya tenemos algo que en teoría debería funcionar. Ahora necesitamos una función <code>reduce</code>. Por suerte para nosotros el prototipo <code>Array</code> tiene una que podemos usar. Empecemos usando un solo transductor.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>filter</span><span>(is_even</span><span style=color:#5fb3b3>, </span><span>combine)</span><span style=color:#5fb3b3>, </span><span>[])</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ 2 ]
</span></code></pre><p>¡Genial, de verdad funciona! Ahora vamos a expandir el conjunto de datos. Digamos que ahora <code>data</code> tendrá números negativos, pero tampoco queremos esos, vamos a crear otro filtro que deje pasar sólo los números positivos. Aquí es donde la composición entra en escena.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>is_positive </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>&gt; </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span>(</span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>, </span><span style=color:#69c>filter</span><span>(is_even))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>transducer</span><span>(combine)</span><span style=color:#5fb3b3>, </span><span>[])</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ 2 ]
</span></code></pre><p>¿Vieron? Obtuvimos el mismo resultado. Ahora hagamos algo mejor, vamos a añadir otra "operación."<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transform</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#ec5f67>arguments</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>1</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>_next</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>map</span><span>(transform</span><span style=color:#5fb3b3>, </span><span>_next)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return function </span><span style=color:#69c>reducer</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>next</span><span>(state</span><span style=color:#5fb3b3>, </span><span style=color:#69c>transform</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><p>El comportamiento es el mismo que esperarían de <code>Array.map</code>. Aquí el valor es transformado antes de ir al siguiente paso. Ahora vamos a incorporarlo en el ejemplo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span>(
</span><span>  </span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>map</span><span>(add_message)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>transducer</span><span>(combine)</span><span style=color:#5fb3b3>, </span><span>[])</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ &quot;The number is: 2&quot; ]
</span></code></pre><p>Esto es bueno, muy bueno. Hay un detalle que necesitamos atender, la compatibilidad. Les mencioné que los transductores deberían funcionar con otros tipos de colecciones aparte de <code>Array</code>, pero aquí usamos <code>Array.reduce</code>. El asunto es que para completar el panorama tenemos que controlar la función <code>reduce</code>, así que haremos una.<p>Ya que javascript nos ofrece el protocolo de iteración, vamos a usar eso para ahorrarnos muchas molestias en nuestro propio <code>reduce</code>, con esto haremos que nuestros transductores sean compatibles con más tipos de colecciones.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>reduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>reducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>initial</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>let </span><span>state </span><span style=color:#5fb3b3>= </span><span>initial</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>let </span><span>value </span><span style=color:#5fb3b3>of </span><span>collection) </span><span style=color:#5fb3b3>{
</span><span>    state </span><span style=color:#5fb3b3>= </span><span style=color:#69c>reducer</span><span>(state</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Para probar esto cambiaremos nuestro ejemplo, <code>data</code> pasará de ser un arreglo a un <code>Set</code>. Cambiaremos la función <code>combine</code>, para que ahora esté al tanto de cómo armar un <code>Set</code>. También cambiaremos nuestro valor inicial en <code>reduce</code> a un <code>Set</code>. Lo demás seguirá igual.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= new </span><span>Set([</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>])</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>add</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span>(
</span><span>  </span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>map</span><span>(add_message)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>transducer</span><span>(combine)</span><span style=color:#5fb3b3>, new </span><span>Set()</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Set [ &quot;The number is: 2&quot; ]
</span></code></pre><p>Noten que el resultado no tiene porque ser un <code>Set</code>, podemos transformar <code>data</code> a un <code>Array</code> si eso deseamos. Para cambiar de un tipo de colección a otro, sólo tenemos que intercambiar el valor inicial en <code>reduce</code> y cambiar la función <code>combine</code>.<p>Todo funciona bien pero hay una cosa más que podemos hacer para crear una "experiencia" más agradable. Hagamos una función auxiliar, <code>transduce</code>, para que se encargue de algunos detalles por nosotros.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>transduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>combine</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>initial</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>transducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>transducer</span><span>(combine)</span><span style=color:#5fb3b3>, </span><span>initial</span><span style=color:#5fb3b3>, </span><span>collection)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>No parece una gran mejora pero esto nos permite aumentar nuestro control sobre <code>reduce</code>, ahora podríamos tener varias implementaciones para diferentes estructuras y decidir cual queremos usar basados en el tipo de dato de <code>collection</code>. Pero por el momento sólo usaremos la función <code>reduce</code> que creamos anteriormente.<p>Ahora lo que haremos será encargarnos de algunos detalles antes de tiempo. Crearemos funciones que tengan la misma funcionalidad de <code>combine</code>, para acumular los valores finales y asociamos eso con el valor inicial correcto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>curry</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arity</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>rest</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if </span><span>(arity </span><span style=color:#5fb3b3>&lt;= </span><span>rest</span><span style=color:#5fb3b3>.</span><span>length) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>fn</span><span>(</span><span style=color:#5fb3b3>...</span><span>rest)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>curry</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>arity</span><span style=color:#5fb3b3>, </span><span>fn</span><span style=color:#5fb3b3>, ...</span><span>rest)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>const </span><span>Into </span><span style=color:#5fb3b3>= {
</span><span>  array</span><span style=color:#5fb3b3>: </span><span style=color:#69c>curry</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>transduce</span><span>(combine</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span>transducer</span><span style=color:#5fb3b3>, </span><span>collection)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  string</span><span style=color:#5fb3b3>: </span><span style=color:#69c>curry</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>concat</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>transduce</span><span>(combine</span><span style=color:#5fb3b3>, &quot;&quot;, </span><span>transducer</span><span style=color:#5fb3b3>, </span><span>collection)
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  set</span><span style=color:#5fb3b3>: </span><span style=color:#69c>curry</span><span>(</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>transducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>add</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>transduce</span><span>(combine</span><span style=color:#5fb3b3>, new </span><span>Set()</span><span style=color:#5fb3b3>, </span><span>transducer</span><span style=color:#5fb3b3>, </span><span>collection)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>,
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Ahora podemos usar aplicación parcial en los argumentos. En esta ocasión logramos ese efecto con la función <code>curry</code>. Vamos a probar.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span>(
</span><span>  </span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>map</span><span>(add_message)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Into</span><span style=color:#5fb3b3>.</span><span style=color:#69c>array</span><span>(transducer</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ &quot;The number is: 2&quot; ]
</span></code></pre><p>También podemos hacer esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>some_process </span><span style=color:#5fb3b3>= </span><span>Into</span><span style=color:#5fb3b3>.</span><span style=color:#69c>array</span><span>(</span><span style=color:#69c>compose</span><span>(
</span><span>  </span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>filter</span><span>(is_even)</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#69c>map</span><span>(add_message)
</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>some_process</span><span>(data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ &quot;The number is: 2&quot; ]
</span></code></pre><blockquote><p>Pueden visualizar todo el código de este ejemplo <a rel=noopener target=_blank href=https://gist.github.com/VonHeikemen/a6b2b2e27ea999e87ebc30cf9c039295>aquí</a></blockquote><p>Ahora poseemos "operaciones" reusables. No tuvimos que implementar un <code>filter</code> especial para el <code>Array</code> y otra para el <code>Set</code>. En este ejemplo no parece gran cosa, pero imagínense tener un arsenal de operaciones como <a rel=noopener target=_blank href=https://rxjs.dev/api>RxJS</a>, y poder usarlas en diferentes estructuras. Lo único que deben hacer es una función <code>reduce</code>. Además, la manera en la que combinamos estas operaciones nos invita a resolver nuestros problemas con una función a la vez.<p>Hay una cosa más que deben saber.<h2 id=esta-no-es-su-forma-final>Esta no es su forma final</h2><p>Hasta ahora he estado presentando los transductores como funciones que retornan un <code>reducer</code>, pero sólo era para ilustrar su funcionamiento. El problema es que nuestros transductores son limitados. Hay un par de cosas que nuestra implementación no soporta:<ul><li><p>Mecanismo de inicialización: Una manera de que un transductor pueda producir el valor inicial para el proceso.<li><p>Interrupción temprana: Un transductor debe ser capaz de interrumpir todo el proceso y devolver el resultado que se ha procesado hasta el momento. Algo así como el <code>break</code> de un ciclo <code>for</code>.<li><p>Una función "final": Básicamente proveer un mecanismo para ejecutar una función al final del proceso. Esto podría ser útil para ejecutar procesos de "limpieza".</ul><p>Es por cosas como esas que muchos artículos que hablan sobre transductores recomiendan encarecidamente que usen una librería.<p>Librerías que tienen soporte para transductores solo conozco:<ul><li><a rel=noopener target=_blank href=https://github.com/cognitect-labs/transducers-js>transducers-js</a><li><a rel=noopener target=_blank href=https://ramdajs.com/docs/>ramda</a></ul><h2 id=siguiendo-el-protocolo>Siguiendo el protocolo</h2><p>Ya sabemos cómo funcionan los transductores a grandes rasgos, ahora vamos a descubrir cómo implementar uno de la manera correcta. Para esto vamos a seguir el <a rel=noopener target=_blank href=https://github.com/cognitect-labs/transducers-js#the-transducer-protocol>protocolo</a> establecido en la librería <em>transducers-js</em>.<p>Las reglas dicen que un transductor debe ser un objeto con la siguiente forma.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= {
</span><span>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/init</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() {
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#5f6364>/* ???? */</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/result</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/step</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// ???
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>};
</span></code></pre><ul><li><p><strong>@@transducer/init</strong>: Será la función que nos da la oportunidad de retornar un valor inicial si por alguna razón necesitamos uno. El comportamiento "por defecto" es delegar sus funciones al siguiente transductor de la composición, con suerte alguno tendrá que devolver algo útil.<li><p><strong>@@transducer/result</strong>: Será la función que se ejecute al final del proceso, es decir cuando ya no haya más valores para procesar. Al igual que <code>@@transducer/init</code>, el comportamiento que se espera por defecto es delegar sus funciones al siguiente transductor en la composición.<li><p><strong>@@transducer/step</strong>: Aquí es donde reside la lógica para nuestro transductor, es decir la "operación" que queremos ejecutar. Básicamente esta función será nuestro <code>reducer</code>.</ul><p>Aún no hemos terminado, también necesitamos una manera de señalar que el proceso será interrumpido y regresar el resultado que se tiene en ese momento. Para esto el protocolo indica la existencia de un objeto especial que llama <code>reduced</code> (reducido). La idea es que cuando la función <code>reduce</code> detecte este objeto se de por terminado el proceso. Este objeto debe tener la siguiente forma.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>reduced </span><span style=color:#5fb3b3>= {
</span><span>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/reduced</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/value</span><span style=color:#5fb3b3>&#39;: </span><span>algo </span><span style=color:#5f6364>// el valor procesado hasta el momento
</span><span style=color:#5fb3b3>};
</span></code></pre><h3 id=un-verdadero-transducer>Un verdadero transducer</h3><p>Es momento de aplicar todo lo que hemos aprendido, vamos a reimplementar <code>filter</code> de la manera correcta. Podemos hacerlo, la mayor parte va a ser igual.<p>Empezamos con una función que retorna un objeto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>predicate</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>next</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ahora la inicialización, ¿Qué necesitamos hacer? Nada, en realidad. Entonces lo que haremos será delegar.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function filter(predicate, next) {
</span><span>    return {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     &#39;@@transducer/init&#39;: function() {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return next[&#39;@@transducer/init&#39;]();
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>    };
</span><span>  }
</span></code></pre><p>Al finalizar, ¿Qué necesitamos hacer? Nada. Ya saben el procedimiento.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function filter(predicate, next) {
</span><span>    return {
</span><span>      &#39;@@transducer/init&#39;: function() {
</span><span>        return next[&#39;@@transducer/init&#39;]();
</span><span>      },
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     &#39;@@transducer/result&#39;: function(state) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return next[&#39;@@transducer/result&#39;](state);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>    };
</span><span>  }
</span></code></pre><p>Ahora para el gran final, la operación en sí.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function filter(predicate, next) {
</span><span>    return {
</span><span>      &#39;@@transducer/init&#39;: function() {
</span><span>        return next[&#39;@@transducer/init&#39;]();
</span><span>      },
</span><span>      &#39;@@transducer/result&#39;: function(state) {
</span><span>        return next[&#39;@@transducer/result&#39;](state);
</span><span>      },
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     &#39;@@transducer/step&#39;: function(state, value) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       if(predicate(value)) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         return next[&#39;@@transducer/step&#39;](state, value);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       }
</span><span style=color:#5fb3b3>+
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return state;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>    };
</span><span>  }
</span></code></pre><p>Y que no se les olvide el toque mágico.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function filter(predicate, next) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   if(arguments.length === 1) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     return (_next) =&gt; filter(predicate, _next);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span>
</span><span>    return {
</span><span>      &#39;@@transducer/init&#39;: function() {
</span><span>        return next[&#39;@@transducer/init&#39;]();
</span><span>      },
</span><span>      &#39;@@transducer/result&#39;: function(state) {
</span><span>        return next[&#39;@@transducer/result&#39;](state);
</span><span>      },
</span><span>      &#39;@@transducer/step&#39;: function(state, value) {
</span><span>        if(predicate(value)) {
</span><span>          return next[&#39;@@transducer/step&#39;](state, value);
</span><span>        }
</span><span> 
</span><span>        return state;
</span><span>      },
</span><span>    };
</span><span>  }
</span></code></pre><p>Ya tenemos el transductor, pero ahora tenemos un problema: no tenemos una función <code>reduce</code> capaz de utilizarlo.<h3 id=reduce-mejorado>reduce mejorado</h3><p>Ahora nos toca hacerle unos ajustes a nuestro <code>reduce</code>.<p>Recuerdan esto.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>reduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>reducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>initial</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>let </span><span>state </span><span style=color:#5fb3b3>= </span><span>initial</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>let </span><span>value </span><span style=color:#5fb3b3>of </span><span>collection) </span><span style=color:#5fb3b3>{
</span><span>    state </span><span style=color:#5fb3b3>= </span><span style=color:#69c>reducer</span><span>(state</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Primero vamos a manejar la inicialización.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> function reduce(reducer, initial, collection) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> function reduce(transducer, initial, collection) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   if(arguments.length === 2) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     collection = initial;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     initial = transducer[&#39;@@transducer/init&#39;]();
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   }
</span><span style=color:#5fb3b3>+
</span><span>    let state = initial;
</span><span>
</span><span>    for(let value of collection) {
</span><span>      state = reducer(state, value);
</span><span>    }
</span><span>
</span><span>    return state;
</span><span>  }
</span></code></pre><p>Cuando la función reciba dos argumentos la colección estará en <code>initial</code> y <code>collection</code> será <code>undefined</code>, así que lo que hacemos es asignar <code>initial</code> a <code>collection</code> y darle la oportunidad a nuestro transductor de generar el estado inicial del proceso.<p>Ahora veremos cómo ejecutar el <code>reducer</code> que como saben ahora está situado en <code>@@transducer/step</code>.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(transducer, initial, collection) {
</span><span>    if(arguments.length === 2) {
</span><span>      collection = initial;
</span><span>      initial = transducer[&#39;@@transducer/init&#39;]();
</span><span>    }
</span><span> 
</span><span>    let state = initial;
</span><span>
</span><span>    for(let value of collection) {
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>     state = reducer(state, value);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     state = transducer[&#39;@@transducer/step&#39;](state, value);
</span><span>    }
</span><span>
</span><span>    return state;
</span><span>  }
</span></code></pre><p>Lo siguiente será evaluar el resultado del <code>reducer</code> y determinar si debemos seguir con el proceso.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(transducer, initial, collection) {
</span><span>    if(arguments.length === 2) {
</span><span>      collection = initial;
</span><span>      initial = transducer[&#39;@@transducer/init&#39;]();
</span><span>    }
</span><span> 
</span><span>    let state = initial;
</span><span>
</span><span>    for(let value of collection) {
</span><span>      state = transducer[&#39;@@transducer/step&#39;](state, value);
</span><span style=color:#5fb3b3>+
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     if(state != null &amp;&amp; state[&#39;@@transducer/reduced&#39;]) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       state = state[&#39;@@transducer/value&#39;];
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       break;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     }
</span><span>    }
</span><span>
</span><span>    return state;
</span><span>  }
</span></code></pre><p>Por último debemos asegurarnos que todas las operaciones sepan que el proceso ha terminado.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(transducer, initial, collection) {
</span><span>    if(arguments.length === 2) {
</span><span>      collection = initial;
</span><span>      initial = transducer[&#39;@@transducer/init&#39;]();
</span><span>    }
</span><span> 
</span><span>    let state = initial;
</span><span>
</span><span>    for(let value of collection) {
</span><span>      state = transducer[&#39;@@transducer/step&#39;](state, value);
</span><span> 
</span><span>      if(state != null &amp;&amp; state[&#39;@@transducer/reduced&#39;]) {
</span><span>        state = state[&#39;@@transducer/value&#39;];
</span><span>        break;
</span><span>      }
</span><span>    }
</span><span>
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67>   return state;
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   return transducer[&#39;@@transducer/result&#39;](state);
</span><span>  }
</span></code></pre><p>Hay un paso extra que me gustaría hacer. Tal vez notaron que renombré <code>reducer</code> a <code>transducer</code>, pero me gustaría que siguiera funcionando con <code>reducer</code>s normales, como los que se usa con <code>Array.reduce</code>. Entonces lo que haremos será crear un transductor que pueda transformar un <code>reducer</code> en un transductor.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>to_transducer</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>reducer</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(</span><span style=color:#5fb3b3>typeof </span><span>reducer[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/step</span><span style=color:#5fb3b3>&#39;</span><span>] </span><span style=color:#5fb3b3>== &#39;</span><span style=color:#99c794>function</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>reducer</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/init</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() {
</span><span>      </span><span style=color:#c594c5>throw </span><span style=color:#5fb3b3>new </span><span>Error(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Method not implemented</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>},
</span><span>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/result</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>return </span><span>state</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>},
</span><span>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>@@transducer/step</span><span style=color:#5fb3b3>&#39;: </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>return </span><span style=color:#69c>reducer</span><span>(state</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>};
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Ahora podemos usarla en <code>reduce</code>.<pre data-lang=diff style=background-color:#2b2c2f;color:#cccece class=language-diff><code class=language-diff data-lang=diff><span>  function reduce(transducer, initial, collection) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>   transducer = to_transducer(transducer);
</span><span style=color:#5fb3b3>+
</span><span>    if(arguments.length === 2) {
</span><span>      collection = initial;
</span><span>      initial = transducer[&#39;@@transducer/init&#39;]();
</span><span>    }
</span><span> 
</span><span>    let state = initial;
</span><span>
</span><span>    for(let value of collection) {
</span><span>      state = transducer[&#39;@@transducer/step&#39;](state, value);
</span><span> 
</span><span>      if(state != null &amp;&amp; state[&#39;@@transducer/reduced&#39;]) {
</span><span>        state = state[&#39;@@transducer/value&#39;];
</span><span>        break;
</span><span>      }
</span><span>    }
</span><span>
</span><span>    return transducer[&#39;@@transducer/result&#39;](state);
</span><span>  }
</span></code></pre><p>Es momento de probar todo el arduo trabajo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_positive </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>&gt; </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>reduce</span><span>(</span><span style=color:#69c>filter</span><span>(is_positive</span><span style=color:#5fb3b3>, </span><span style=color:#69c>to_transducer</span><span>(combine))</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array(3) [ 1, 2, 3 ]
</span></code></pre><p>Bien, todo funciona. Pero es mucho trabajo usar <code>reduce</code>. Es por eso que tenemos la función <code>transduce</code>, pero justo ahora le falta algo, tenemos que agregarle <code>to_transducer</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>transduce</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>combine</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>initial</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>transducer</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>collection</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#69c>reduce</span><span>(
</span><span>    </span><span style=color:#69c>transducer</span><span>(</span><span style=color:#69c>to_transducer</span><span>(combine))</span><span style=color:#5fb3b3>,
</span><span>    initial</span><span style=color:#5fb3b3>,
</span><span>    collection
</span><span>  )</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Vamos de nuevo.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_positive </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>&gt; </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>transduce</span><span>(combine</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array(3) [ 1, 2, 3 ]
</span></code></pre><p>Ahora vamos a probar la composición.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>is_even </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>% </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>=== </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>is_positive </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>number </span><span style=color:#c594c5>=&gt; </span><span>number </span><span style=color:#5fb3b3>&gt; </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>data </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>-</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, -</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>3</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>combine </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>state</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(state</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span>(value)</span><span style=color:#5fb3b3>, </span><span>state)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>transducer </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compose</span><span>(</span><span style=color:#69c>filter</span><span>(is_positive)</span><span style=color:#5fb3b3>, </span><span style=color:#69c>filter</span><span>(is_even))</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#69c>transduce</span><span>(combine</span><span style=color:#5fb3b3>, </span><span>[]</span><span style=color:#5fb3b3>, </span><span>transducer</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Array [ 2 ]
</span></code></pre><blockquote><p>Pueden visualizar todo el código de este ejemplo <a rel=noopener target=_blank href=https://gist.github.com/VonHeikemen/a70479feeb59a26cd5f217ea752cf115>aquí</a></blockquote><p>Oficialmente hemos terminado. No hay nada más qué hacer. Creo que ya tienen suficiente información para crear sus propios transductores.<h2 id=conclusion>Conclusión</h2><p>¡Lo lograron! Llegaron al final del artículo. Debo felicitarlos, especialmente si entendieron todo en el primer intento, este no fue nada fácil. Celebren, se lo merecen.<p>En fin, hoy aprendimos que los transductores (en javascript) son transformaciones que pueden operar en diferentes tipos de colecciones, siempre y cuando estas provean una función <code>reduce</code> que sea compatible. También tienen algunas propiedades sumamente útiles como interrupción temprana (como la de un ciclo <code>for</code>), mecanismos para señalar la finalización e inicio de un proceso y pueden ser combinadas usando composición de funciones. Y por último, también deberían ser eficientes, pero no son más rápidos que un ciclo <code>for</code>. Aunque no sean la solución más eficiente en cuestión de desempeño su nivel de compatibilidad con diferentes colecciones y la forma declarativa para combinar operaciones hacen que sea una herramienta poderosa.<h2 id=fuentes>Fuentes</h2><ul><li><a rel=noopener target=_blank href=https://github.com/getify/Functional-Light-JS/blob/master/manuscript/apA.md/#appendix-a-transducing>Functional-Light JavaScript | Appendix A: Transducing</a><li><a rel=noopener target=_blank href=https://www.jeremydaly.com/transducers-supercharge-functional-javascript/>Transducers: Supercharge your functional JavaScript</a><li><a rel=noopener target=_blank href=https://jrsinclair.com/articles/2019/magical-mystical-js-transducers/>Magical, Mystical JavaScript Transducers</a><li><a rel=noopener target=_blank href=https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d>Transducers: Efficient Data Processing Pipelines in JavaScript</a><li><a rel=noopener target=_blank href="https://www.youtube.com/watch?v=6mTbuzafcII">"Transducers" by Rich Hickey (video)</a><li><a rel=noopener target=_blank href=https://github.com/cognitect-labs/transducers-js>transducers-js</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario
en cualquiera de estas plataformas:<ul><li><a rel=noopener target=_blank href=https://dev.to/vonheikemen/transductores-en-javascript-30kc>dev.to</a><li><a rel=noopener target=_blank href=https://vonheikemen.hashnode.dev/transducers-in-javascript-es>Hashnode</a></ul><p>O puedes contactarme en twitter
<a rel=noopener target=_blank href=https://twitter.com/VonHeikemen_>@VonHeikemen_</a><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>