<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Cómo sobrevivir sin cursores múltiples en vim | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=me href=https://hachyderm.io/@vonheikemen><link rel=me href=https://twitter.com/VonHeikemen_><meta name=keywords content="vim,neovim,shell,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Patrones alternativos que podemos usar en vim en lugar de cursores múltiples"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2023 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Cómo sobrevivir sin cursores múltiples en vim</h1><span class=post-date>2023-01-15
| 11 minutos
| <a href=https://vonheikemen.github.io/devlog/tools/how-to-survive-without-multiple-cursors-in-vim/>Read in english</a></span><p>Sí, los cursores múltiples son mágicos. Son convenientes, fácil de usar y están presente en muchos editores modernos. Para bien o para mal, vim no los tiene. Pero está bien, podemos ser felices sin ellos. Bueno... yo puedo y voy decirles cómo.<p>Vamos a repasar las situaciones donde podríamos usar cursores múltiples y veremos qué alternativas tenemos en vim.<h2 id=reemplazar-palabra-debajo-del-cursor>Reemplazar palabra debajo del cursor</h2><p>En vim debemos comenzar el proceso buscando la palabra debajo del cursor, para esto presionamos <code>*</code>. Luego presionamos <code>cgn</code> para reemplazar la próxima ocurrencia. Si queremos repetir la acción presionamos <code>.</code>, sí, el punto. Si no queremos reemplazar la ocurrencia actual podemos ignorarla y pasar a la siguiente presionando <code>n</code>.<p>Podemos hacer este proceso más rápido si creamos un atajo de teclado que agrupe los primeros dos pasos.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;leader&gt;</span><span>j *``cgn
</span></code></pre><p>Con este atajo podremos utilizar la tecla líder + j para reemplazar la palabra actual, luego podremos navegar entre cada ocurrencia de la palabra y usar <code>.</code> para reemplazar el texto.<p><script src=https://asciinema.org/a/qxb6feyI4ieLUlFUwO2kXzV4I.js id=asciicast-qxb6feyI4ieLUlFUwO2kXzV4I data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/540516>asciinema</a>.</blockquote><h2 id=cambiar-una-variable>Cambiar una variable</h2><p>Puede ser que la palabra que quieren reemplazar es una variable en su código, en este caso sería ideal que el editor sólo reemplace las referencias que son válidas. Aquí la solución puede ser un poco más complicada. Como saben vim no es un IDE, este tipo de funcionalidad no está habilitada por defecto. Pero no es imposible, existen plugins que nos permiten usar servidores LSP. Resulta que renombrar variables es una de esas funcionalidades que podemos obtener con un servidor LSP.<p>Personalmente uso Neovim y no vim como tal. En mi caso sólo necesito algo como esto.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>lua require</span><span>(</span><span style=color:#99c794>&#39;lspconfig&#39;</span><span>).tsserver.</span><span style=color:#69c>setup</span><span>({})
</span><span>
</span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;F2&gt; &lt;cmd&gt;</span><span style=color:#69c>lua</span><span> vim.lsp.buf.</span><span style=color:#69c>rename</span><span>()</span><span style=color:#fac863>&lt;cr&gt;
</span></code></pre><p>Aquí uso <a rel=noopener target=_blank href=https://github.com/neovim/nvim-lspconfig>nvim-lspconfig</a> para configurar <a rel=noopener target=_blank href=https://github.com/theia-ide/typescript-language-server>tsserver</a>. Y creo el atajo <code>&lt;F2></code> para renombrar variables.<p><script src=https://asciinema.org/a/217Yk9e9HtmuPi0t8HsNPHOAN.js id=asciicast-217Yk9e9HtmuPi0t8HsNPHOAN data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/540539>asciinema</a>.</blockquote><p>Si ustedes usan vim pueden probar estos plugins:<ul><li><a rel=noopener target=_blank href=https://github.com/prabirshrestha/vim-lsp>vim-lsp</a><li><a rel=noopener target=_blank href=https://github.com/neoclide/coc.nvim>coc.nvim</a></ul><h2 id=reemplazar-seleccion>Reemplazar selección</h2><p>Tal vez el texto que queremos reemplazar no es una palabra, tal vez es una oración o un atributo de html. En este caso no tenemos una funcionalidad nativa que nos ayude pero podemos implementar nuestra propia solución.<p>Lo primero que haremos será colocar la selección actual en el "registro de búsqueda" de vim.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>@</span><span style=color:#5fb3b3>/=escape(@&quot;, &#39;/</span><span>&#39;)
</span></code></pre><p>Aquí tomamos el registro <code>"</code> que contiene la selección más reciente, nos aseguramos de escapar el caracter <code>/</code> para que no ocurra un conflicto en nuestra búsqueda, finalmente asignamos el resultado al registro <code>/</code>.<p>Luego debemos borrar toda la selección e ir al modo de inserción. Esto lo logramos con esta secuencia.<pre style=background-color:#2b2c2f;color:#cccece><code><span>&quot;_cgn
</span></code></pre><p>Con <code>"_</code> le decimos a vim que queremos usar el registro <code>_</code> para nuestra siguiente operación. <code>cgn</code> es para reemplazar la primera ocurrencia de una búsqueda.<p>Si juntamos estas piezas en un atajo tendremos esto.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>xnoremap </span><span style=color:#fac863>&lt;leader&gt;</span><span>j y</span><span style=color:#fac863>&lt;cmd&gt;</span><span style=color:#69c>let </span><span>@</span><span style=color:#5fb3b3>/=escape(@&quot;, &#39;/</span><span>&#39;)</span><span style=color:#fac863>&lt;cr&gt;</span><span style=color:#5f6364>&quot;_cgn
</span></code></pre><p>Pero esta solución sólo funciona con búsquedas de una línea. Si por alguna razón quieren reemplazar una selección de múltiples líneas deben hacer esto.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>xnoremap </span><span style=color:#fac863>&lt;leader&gt;</span><span>j y</span><span style=color:#fac863>&lt;cmd&gt;</span><span style=color:#69c>substitute</span><span>(</span><span style=color:#69c>escape</span><span>(@</span><span style=color:#99c794>&quot;, &#39;/&#39;), &#39;\n&#39;, &#39;\\n&#39;, &#39;g&#39;)&lt;cr&gt;&quot;</span><span>_cgn
</span></code></pre><p>Aquí usamos la función <code>substitute</code> para reemplazar el salto de línea con <code>\n</code>, así técnicamente nuestra búsqueda siempre será de una línea.<p>¿Cómo usamos esto? De la misma forma que usamos el atajo <code>&lt;leader>j</code> en la sección "reemplazar palabra debajo del cursor". La diferencia es que en este caso primero debemos ir a modo visual para seleccionar el texto. Luego podremos repetir la acción usando <code>.</code> o podemos movernos a la siguiente ocurrencia usando <code>n</code>.<h2 id=anadir-texto-al-inicio-de-una-lista>Añadir texto al inicio de una lista</h2><p>Digamos que tenemos una lista de palabras y queremos convertirla en una lista ordenada en markdown.<p>Queremos transformar esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>volar
</span><span>html
</span><span>cssls
</span></code></pre><p>En esto.<pre style=background-color:#2b2c2f;color:#cccece><code><span>1. volar
</span><span>1. html
</span><span>1. cssls
</span></code></pre><p>En vim tenemos un modo llamado "visual block", cuando estamos en este modo tenemos la posibilidad de agregar texto a cada línea de la selección si vamos a modo de inserción usando <code>I</code> o <code>A</code>. Luego de insertar el texto en la primera línea vim procede a repetir esta acción en el resto de las líneas seleccionadas.<p>Vamos a revisar paso a paso lo que debemos hacer.<p><script src=https://asciinema.org/a/tjCikrHM5d1QsoSk00u9iUQMa.js id=asciicast-tjCikrHM5d1QsoSk00u9iUQMa data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/539909>asciinema</a>.</blockquote><ol><li>Vamos al primer caracter de la primera línea.<li>Presionamos <code>Ctrl + v</code> para ir al modo "visual block".<li>Seleccionamos las líneas que queremos cambiar.<li>Presionamos <code>I</code> para colocar el cursor al inicio de la selección.<li>Agregamos el texto que queremos.<li>Presionamos <code>Esc</code>.</ol><h2 id=anadir-texto-al-final-de-una-lista>Añadir texto al final de una lista</h2><p>Sí. También podemos modificar el final de la línea. El proceso es casi idéntico, con la diferencia de aquí debemos expandir la selección hacia el final de la línea.<p>Digamos que tenemos nuestra lista ordenada pero ahora queremos agregar el texto <code>(is supported)</code> al final de cada línea.<p><script src=https://asciinema.org/a/eF1Pdf34IY4Sj5PixzjCqPIxz.js id=asciicast-eF1Pdf34IY4Sj5PixzjCqPIxz data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/539912>asciinema</a>.</blockquote><ol><li>Vamos al primer caracter de la primera línea.<li>Presionamos <code>Ctrl + v</code> para ir al modo "visual block".<li>Seleccionamos las líneas que queremos cambiar.<li>Expandimos la selección hacia el final de la línea presionando <code>$</code>.<li>Presionamos <code>A</code> para colocar el cursor al final de la primera línea.<li>Agregamos el texto que queremos.<li>Presionamos <code>Esc</code>.</ol><h2 id=repetir-un-movimientos>Repetir un movimientos</h2><p>El modo <code>visual block</code> puede ser útil en muchas situaciones pero es limitado. Sólo puede agregar texto en un lugar. ¿Qué hacemos cuando queremos hacer modificaciones complejas? La respuesta: <code>macros</code>. Un macro es una cadena de texto que describe una secuencia de teclas. Podemos "grabar" un macro y repetirlo tantas veces sea necesario.<p>¿Cómo usamos un macro? Primero debemos elegir un registro. Algo así como una etiqueta para nuestro macro. Presionamos <code>q</code> seguido de la letra de nuestro registro. Luego ejecutamos las modificaciones que queremos. Finalmente presionamos <code>q</code> para terminar de grabar el macro. Para repetir el macro debemos presionar <code>@</code> seguido de la letra que elegimos en el primer paso.<p>Vamos con un ejemplo.<p>Tenemos esta lista.<pre style=background-color:#2b2c2f;color:#cccece><code><span>volar
</span><span>html
</span><span>cssls
</span><span>eslint
</span></code></pre><p>Y queremos convertirlo en una lista ordenada de enlaces.<pre style=background-color:#2b2c2f;color:#cccece><code><span>1. [volar](http://localhost/how-to-configure-volar-lsp)
</span><span>1. [html](http://localhost/how-to-configure-html-lsp)
</span><span>1. [cssls](http://localhost/how-to-configure-cssls-lsp)
</span><span>1. [eslint](http://localhost/how-to-configure-eslint-lsp)
</span></code></pre><p>Noten que aquí necesitamos añadir texto al inicio y final de cada línea. También tenemos que copiar el nombre de cada item y colocarlo en el enlace.<p>Lo que haremos será convertir el primer item y repetir el proceso usando un macro. Estos son los pasos.<ol><li>Grabamos el macro en el registro <code>i</code>. Presionamos <code>qi</code>.<li>Modificamos el primer item.<li>Finalizamos la grabación del macro presionando <code>q</code> nuevamente.<li>Repetimos el macro tres veces presionando <code>3@i</code>.</ol><p><script src=https://asciinema.org/a/85qQ7TtkOclesgMJNBDcKk5BK.js id=asciicast-85qQ7TtkOclesgMJNBDcKk5BK data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/540581>asciinema</a>.</blockquote><p>Cuando aplicamos un macro de esta manera, con repeticiones automáticas, debemos tener en cuenta la posición del cursor. En este caso particular el primer atajo que utilicé al comenzar a grabar el macro fue <code>0</code> y terminé presionando <code>j</code>. Con esto me aseguro de que en cada repetición el cursor esté en el primer caracter de la línea, y justo antes de terminar el macro muevo el cursor a la línea que está debajo.<h3 id=aplicar-un-macro-en-lineas-especificas>Aplicar un macro en líneas específicas</h3><p>Otra forma interesante de aplicar un macro es con el comando <code>g</code>. Este comando ejecuta una búsqueda y nos da la oportunidad de ejecutar otro comando en las líneas donde hay una ocurrencia. En nuestro caso lo que queremos hacer después de la búsqueda es ejecutar un macro, para eso usamos el comando <code>normal @i</code> (donde <code>i</code> puede ser cualquier registro).<p>Digamos que queremos buscar todas las líneas con la palabra <code>vim</code> y ejecutar un macro. Podemos hacer algo así.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>:g</span><span style=color:#5fb3b3>/vim/</span><span>normal @i
</span></code></pre><p>Si quieren asegurarse de que su búsqueda tiene los resultados esperados pueden omitir la sección que va después de la búsqueda.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>:g</span><span style=color:#5fb3b3>/vim/
</span></code></pre><p>Si todo está bien agregamos <code>normal @i</code>.<h3 id=aplicar-un-macro-en-una-seleccion>Aplicar un macro en una selección</h3><p>No estamos obligados a usar el comando <code>g</code>, podemos utilizar el comando <code>normal @i</code> sobre una selección ejecutando este comando.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#99c794>&#39;&lt;,&#39;</span><span>&gt;normal @i
</span></code></pre><blockquote><p>Nota: No se preocupen por recordar la sintaxis <code>'&lt;,'></code>, vim lo agregará automáticamente cuando pasamos de modo visual a modo de comando.</blockquote><p>Esto ejecutará el macro en <code>i</code> sobre cada línea de la selección. Deben tener en cuenta que cada macro comenzará con el cursor al principio de la línea.<h3 id=buscar-patron-y-ejecutar-un-macro>Buscar patrón y ejecutar un macro</h3><p>Esta es una alternativa al comando <code>g</code>. Porque tal vez no se sienten cómodos usando expresiones regulares. Los entiendo. La mayoría de las veces lo que quiero hacer es seleccionar un pedazo de texto y aplicar un macro sobre algunas ocurrencias. Ya vimos cómo buscar una selección, podemos aplicar este conocimiento para manipular la posición del cursor.<p>¿Recuerdan esto?<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>y</span><span style=color:#fac863>&lt;cmd&gt;</span><span style=color:#69c>let </span><span>@</span><span style=color:#5fb3b3>/=substitute(escape(@&quot;, &#39;/</span><span style=color:#99c794>&#39;), &#39;</span><span>\n</span><span style=color:#99c794>&#39;, &#39;</span><span>\\n</span><span style=color:#99c794>&#39;, &#39;</span><span>g&#39;)</span><span style=color:#fac863>&lt;cr&gt;
</span></code></pre><p>Esta es la secuencia que usamos para colocar la selección actual en el registro de búsqueda. Todo lo que tenemos que hacer es iniciar la grabación del macro después de esta función. Así.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>gvqi
</span></code></pre><p>Con <code>gv</code> vim vuelve a resaltar la selección anterior, porque recuerden que perdemos la selección luego de presionar <code>y</code>. Después con <code>qi</code> comienza la grabación del macro en el registro <code>i</code>.<p>Si juntamos todo esto en un atajo obtenemos:<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>xnoremap </span><span style=color:#fac863>&lt;leader&gt;</span><span>i y</span><span style=color:#fac863>&lt;cmd&gt;</span><span style=color:#69c>let </span><span>@</span><span style=color:#5fb3b3>/=substitute(escape(@&quot;, &#39;/</span><span style=color:#99c794>&#39;), &#39;</span><span>\n</span><span style=color:#99c794>&#39;, &#39;</span><span>\\n</span><span style=color:#99c794>&#39;, &#39;</span><span>g&#39;)</span><span style=color:#fac863>&lt;cr&gt;</span><span>gvqi
</span></code></pre><p>La historia no termina aquí, ahora tenemos que aplicar el macro en las ocurrencias de nuestra selección. Usaremos <code>gn</code> para seleccionar la siguiente ocurrencia y ejecutar el macro.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;F8&gt;</span><span> gn@i
</span></code></pre><p>Vamos con un ejemplo de la vida real.<p>Hace unos meses estaba probando <a rel=noopener target=_blank href=https://github.com/wbthomason/packer.nvim>packer.nvim</a>, un manejador de plugins. En mi configuración tenía este código.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>packer</span><span style=color:#5fb3b3>&#39;).</span><span style=color:#69c>startup</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>use</span><span style=color:#5fb3b3>)
</span><span style=color:#69c>  use</span><span style=color:#5fb3b3>({
</span><span style=color:#69c>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>nvim-lualine/lualine.nvim</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>    config </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() </span><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plugins.lualine</span><span style=color:#5fb3b3>&#39;) </span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>})
</span><span style=color:#69c>  use</span><span style=color:#5fb3b3>({
</span><span style=color:#69c>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>akinsho/bufferline.nvim</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>    config </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() </span><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plugins.bufferline</span><span style=color:#5fb3b3>&#39;) </span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>})
</span><span style=color:#69c>  use</span><span style=color:#5fb3b3>({
</span><span style=color:#69c>    </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>lukas-reineke/indent-blankline.nvim</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>    config </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>() </span><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plugins.indent-blankline</span><span style=color:#5fb3b3>&#39;) </span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>})
</span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>)
</span></code></pre><p>Me molestaba tener que repetir <code>function() require...</code> por cada plugin. Busqué por internet y encontré la manera de reducir el código repetido. Escribí esta función.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local function </span><span style=color:#69c>load</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>name</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#f99157>string</span><span style=color:#5fb3b3>.</span><span style=color:#69c>format</span><span style=color:#5fb3b3>([[</span><span style=color:#99c794>pcall(require, &#39;plugins.%s&#39;)</span><span style=color:#5fb3b3>]], </span><span>name</span><span style=color:#5fb3b3>)
</span><span style=color:#c594c5>end
</span></code></pre><p>Con esta función puedo reducir el código necesario para utilizar <code>config</code>. Puedo hacer esto.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>config </span><span style=color:#5fb3b3>= </span><span style=color:#69c>load</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>lualine</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Lo que queda es reemplazar la propiedad <code>config</code> de cada plugin.<p><script src=https://asciinema.org/a/OUlPjhimpPKIDxEqPJgoxHcYt.js id=asciicast-OUlPjhimpPKIDxEqPJgoxHcYt data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/OUlPjhimpPKIDxEqPJgoxHcYt>asciinema</a>.</blockquote><ol><li>Seleccionamos el patrón que vamos a buscar. En este caso <code>config =</code>.<li>Comenzamos a grabar el macro usando el atajo <code>&lt;leader>i</code>.<li>Hacemos las operaciones necesarias.<li>Terminamos de grabar el macro presionando <code>q</code>.<li>Presionamos <code>n</code> para ir al siguiente punto.<li>Repetimos el macro con el atajo <code>&lt;F8></code>.</ol><h2 id=busqueda-y-reemplazo>Búsqueda y reemplazo</h2><p>Porque muchas veces no necesitamos herramientas complicadas.<p>En vim podemos usar el comando <code>substitute</code>. Esta es la sintaxis.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>%s</span><span style=color:#5fb3b3>/&lt;patrón&gt;/</span><span style=color:#fac863>&lt;reemplazo&gt;</span><span>/g
</span></code></pre><p>Aquí <code>%</code> es el "rango" de la búsqueda, si usamos <code>%</code> quiere decir que queremos buscar en todo el archivo. <code>s</code> es el comando, no tenemos que escribir el nombre completo <code>substitute</code>. <code>&lt;patrón></code> es la expresión regular que queremos buscar. <code>&lt;reemplazo></code> es el texto queremos usar. <code>g</code> es un "flag" que le indica a vim que debe buscar en toda la línea. Noten que cada una de estas secciones está separada por <code>/</code>, pero podemos usar otros caracteres.<p>Vamos con un ejemplo. Digamos que queremos cambiar la palabra <code>config</code> por <code>setup</code>. No necesitamos conocer nada de expresiones regulares, sólo colocamos las palabras en el lugar correcto.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>%s</span><span style=color:#5fb3b3>/config/</span><span>setup/g
</span></code></pre><h3 id=el-kirby-tuerto>El Kirby tuerto</h3><p>Okey. Si hay algo que les recomiendo aprender de expresiones regulares en vim son los "grupos". Incluso un pequeño truco puede traer muchos beneficios.<p>¿Qué es eso del kirby tuerto? Es la forma de recordar esta sintaxis.<pre style=background-color:#2b2c2f;color:#cccece><code><span>\(.*\)
</span></code></pre><blockquote><p>Este truco lo aprendí de <a rel=noopener target=_blank href=https://github.com/ThePrimeagen>ThePrimeagen</a>.</blockquote><p>Con este patrón podemos capturar un pedazo de texto y crear un "grupo". Una vez que tenemos un grupo podremos utilizar el texto en nuestro texto de reemplazo.<p>Consideren este comando.<pre style=background-color:#2b2c2f;color:#cccece><code><span>%s/`\(.*\)`/[\1](#how-to-configure-\1-lsp)
</span></code></pre><p>Aquí capturamos todo el texto que se encuentre entre comillas. Luego utilizamos el texto del grupo con el patrón <code>\1</code> en el texto de reemplazo. Aquí tienen un demo.<p><script src=https://asciinema.org/a/odouPFLqH5SSHkJuSVhp28yjR.js id=asciicast-odouPFLqH5SSHkJuSVhp28yjR data-preload=false data-size=small async></script><blockquote><p>Ver en <a rel=noopener target=_blank href=https://asciinema.org/a/542501>asciinema</a>.</blockquote><p>En este demo se puede observar en tiempo real el efecto del comando mientras escribo. Tengo entendido que esto es único de neovim (puedo estar equivocado). Pero sí, con este efecto en tiempo real el comando <code>substitute</code> puede ser una buena alternativa (en algunos casos) a los cursores múltiples.<p>Si les preocupa no poder recordar la sintaxis del Kirby tuerto consideren crear un atajo.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>cnoremap </span><span style=color:#fac863>&lt;F2&gt; </span><span>\(.*\)
</span></code></pre><p>De esta manera sólo tienen que presionar <code>&lt;F2></code> para crear el grupo.<h2 id=conclusion>Conclusión</h2><p>Ya están listos. Pueden salir al mundo y ser productivos con vim. No puedo garantizar que serán felices pero sobrevivirán. Está bien si todavía consideran que los cursores múltiples es la mejor herramienta. No importa, pueden vivir sin ellos mientras están en vim.<hr><p>Si tienen alguna pregunta pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" target=_blank href=https://twitter.com/VonHeikemen_>@VonHeikemen_</a><li>Mastodon <a rel="noopener me" target=_blank href=https://hachyderm.io/@vonheikemen>@vonheikemen@hachyderm.io</a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>