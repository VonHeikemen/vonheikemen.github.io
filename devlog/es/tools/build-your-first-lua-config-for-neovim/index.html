<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Cómo crear tu primera configuración de Neovim usando lua | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, neovim, shell, software, coding, development" name=keywords><meta content="Donde aprendemos cómo personalizar Neovim y agregar plugins" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Cómo crear tu primera configuración de Neovim usando lua</h1><span class=post-date>2022-07-02 | 19 minutos | <a href=https://vonheikemen.github.io/devlog/tools/build-your-first-lua-config-for-neovim/> Read in english </a> </span><blockquote>Última actualización: 2025-12-10</blockquote><p>Aquí espero poder enseñarles suficiente sobre <code>lua</code> y la api de Neovim para poder construir una configuración que se adapte a sus necesidades.<p>Lo que haremos será crear un archivo de configuración que llamaremos <code>init.lua</code>, agregaremos un par de plugins y les diré cómo crear sus propios comandos.<p>Este tutorial está pensado para aquellos que son totalmente nuevos en Neovim. Si ya tienen una configuración escrita en vimscript y desean migrarla a lua, les recomiendo leer esto: <a href=https://vonheikemen.github.io/devlog/es/tools/configuring-neovim-using-lua/>Todo lo que necesitan saber para configurar neovim usando lua</a>.<h2 id=recomendaciones>Recomendaciones</h2><p>Antes de empezar, les aconsejo que instalen la versión estable de Neovim más reciente. Pueden visitar la <a rel="noopener external" href=https://github.com/neovim/neovim/releases target=_blank>sección releases</a> del repositorio en github y descargarla de ahí. En esta ocasión necesitaremos una versión de Neovim que sea igual o mayor a v0.9.5.<p>Y si aún no se sienten cómodos usando Neovim para editar texto, hagan el tutorial interactivo que viene incluido. Pueden acceder a él ejecutando este comando en su terminal.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=shellscript><span class=giallo-l><span style=color:#7aa89f>nvim</span><span style=color:#98bb6c> +Tutor</span></span></code></pre><p>El tutorial está inglés. Si no tienen un buen dominio del idioma pueden hacer el tutorial de <strong>Vim</strong>, que es un simple archivo de texto. Está disponible en repositorio de Vim: <a rel="noopener external" href=https://raw.githubusercontent.com/vim/vim/d899e51120798d3fb5420abb1f19dddf3f014d05/runtime/tutor/tutor.es target=_blank>vim/runtime/tutor/tutor.es</a>. Guardan ese archivo en algún lugar de su sistema y lo abren con Neovim. Voy a asumir que ya conocen todas las funcionalidades que enseña el tutor.<h2 id=el-inicio>El Inicio</h2><p>Lo primero que debemos hacer es crear nuestro archivo de configuración, el famoso <code>init.lua</code>. ¿Dónde? Depende de su sistema operativo y sus variables de entorno. Pero puedo enseñarles cómo crearlo desde Neovim, así no tenemos que preocuparnos por esos detalles.<blockquote><p>Dato curioso: En algunos tutoriales se refieren al archivo de configuración como <code>vimrc</code>, porque ese es el nombre que tiene el archivo en Vim.</blockquote><p>En esta sección no vamos a usar lua, usaremos el lenguaje que fue creado para Vim: vimscript.<p>Vamos a abrir Neovim y luego ejecutamos este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:call</span><span style=color:#7e9cd8> mkdir</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>stdpath</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>"config"</span><span style=color:#9cabca>),</span><span style=color:#98bb6c> "p"</span><span style=color:#9cabca>)</span></span></code></pre><p>Con esto crearemos la carpeta donde vivirá nuestra configuración. Si quieren conocer la ubicación exacta usen este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:</span><span style=color:#7e9cd8>echo stdpath</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>"config"</span><span style=color:#9cabca>)</span></span></code></pre><p>Ahora vamos con el comando para editar la configuración.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:</span><span style=color:#7e9cd8>exe</span><span style=color:#98bb6c> "edit"</span><span style=color:#7e9cd8> stdpath</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>"config"</span><span style=color:#9cabca>)</span><span style=color:#e6c384> . </span><span style=color:#98bb6c>"/init.lua"</span></span></code></pre><p>Después de ejecutarlo tendremos una "página" en blanco, pero el archivo aún no existe en el sistema. Para crearlo debemos guardarlo. Ejecuten esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:</span><span style=color:#7aa89f>write</span></span></code></pre><p>Una vez que tenemos el archivo podremos editarlo en cualquier momento con este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:edit $MYVIMRC</span></span></code></pre><p>Si ustedes son de aquellas personas que les gusta crear scripts para automatizar sus tareas, pueden ejecutar todos estos pasos con un sólo comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=shellscript><span class=giallo-l><span style=color:#7aa89f>nvim</span><span style=color:#98bb6c> --headless -c 'call mkdir(stdpath("config"), "p") | exe "edit" stdpath("config") . "/init.lua" | write | quit'</span></span></code></pre><h2 id=opciones-del-editor>Opciones del editor</h2><p>Para acceder a las opciones de Neovim debemos usar la variable global <code>vim</code>. Bueno, esto es más que una variable, es un módulo donde podemos encontrar cualquier tipo de utilidades. Pero ahora lo que nos interesa es una propiedad llamada <code>o</code>, con eso podremos modificar cualquiera de las 351 opciones que ofrece Neovim.<p>Esta es la sintaxis que deben seguir.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.nombre_opcion</span><span style=color:#e6c384> =</span><span> valor</span></span></code></pre><p>Donde <code>nombre_opcion</code> puede ser cualquiera de <a rel="noopener external" href=https://neovim.io/doc/user/quickref.html#option-list target=_blank>esta lista</a>. Y <code>valor</code> debe concordar con el tipo de dato que espera la opción.<blockquote><p>Pueden ver la lista de opciones desde Neovim con el comando <code>:help option-list</code>.</blockquote><p>Deben tener en cuenta que cada opción tiene un "ámbito." Algunas opciones son globales, otras se limitan a la ventana o archivo que están manipulando en su momento. Para conocer estos detalles revisen la documentación de esta manera.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help </span><span style=color:#98bb6c>'nombre_opcion'</span></span></code></pre><h3 id=opciones-de-interes>Opciones de interés</h3><ul><li><code>number</code></ul><p>Esta opción es de tipo booleano, quiere decir que sólo tiene dos posibles valores: <code>true</code> o <code>false</code>. Si le asignamos el valor <code>true</code> la habilitamos, <code>false</code> hace lo contrario.<p>Al habilitar <code>number</code> Neovim nos muestra los números de cada línea en pantalla.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.number</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span></code></pre><ul><li><code>ignorecase</code></ul><p>Con esto le decimos a Neovim si debe ignorar las letrás mayúsculas cuando realizamos una búsqueda. Por ejemplo, si buscamos la palabra <code>dos</code> nuestros resultados pueden incluir diferentes variaciones como <code>Dos</code>, <code>DOS</code> o <code>dos</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.ignorecase</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span></code></pre><ul><li><code>smartcase</code></ul><p>Hace que nuestra búsqueda ignore las letrás mayúsculas a menos que el término que estamos buscando tenga una letra mayúscula. Generalmente se usa en conjunto con <code>ignorecase</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.smartcase</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span></code></pre><ul><li><code>hlsearch</code></ul><p>Resalta los resultados de una búsqueda anterior. La mayor parte del tiempo no queremos esto, así que lo deshabilitamos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.hlsearch</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span></code></pre><ul><li><code>wrap</code></ul><p>Hace que el texto de las líneas largas (las que sobrepasan el ancho de la pantalla) siempre esté visible. Su valor defecto es <code>true</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.wrap</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span></code></pre><ul><li><code>breakindent</code></ul><p>Conserva la indentación de las líneas que sólo son visibles cuando <code>wrap</code> es <code>true</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.breakindent</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span></code></pre><ul><li><code>tabstop</code></ul><p>La cantidad de carácteres que ocupa <code>Tab</code>. El valor por defecto es 8. Yo prefiero 2.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.tabstop</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 2</span></span></code></pre><ul><li><code>shiftwidth</code></ul><p>El espacio que Neovim usará para indentar una línea. Esta opción afecta los atajos <code>&lt;&lt;</code> y <code>>></code>. Su valor por defecto es 8. La convención es tener el mismo valor que <code>tabstop</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.shiftwidth</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 2</span></span></code></pre><ul><li><code>expandtab</code></ul><p>Determina si Neovim debe transformar el carácter <code>Tab</code> en espacios. Su valor por defecto es <code>false</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.expandtab</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span></code></pre><p>En lo que se refiere a configuración de variables hay más características que podría mencionar, pero tenemos otras cosas qué hacer. Pueden encontrar más detalles del tema aquí: <a href=https://vonheikemen.github.io/devlog/es/tools/configuring-neovim-using-lua/#opciones-del-editor>Configurando neovim - Opciones del editor</a>.<h2 id=atajos-de-teclado>Atajos de teclado</h2><p>Para esto debemos aprender a usar la función <code>vim.keymap.set</code>. Les mostraré un ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;space>w'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>write&lt;cr>'</span><span>, {desc</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Guardar'</span><span>})</span></span></code></pre><p>Después de ejecutar esta función la combinación <code>Espacio</code> + <code>w</code> nos permitirá usar el comando <code>write</code>. Podremos guardar el archivo actual con <code>Espacio</code> + <code>w</code>.<p>Ahora déjenme explicarles qué hace cada parámetro.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({mode}, {lhs}, {rhs}, {opts})</span></span></code></pre><ul><li><p><code>{mode}</code> es el modo donde tendrá efecto nuestro atajo (puede ser una lista de modos). Pero no necesitamos nombres, necesitamos la abreviación. Estas son las más comunes.</p> <ul><li><code>n</code>: Modo normal.<li><code>i</code>: Modo de inserción.<li><code>x</code>: Modo visual.<li><code>s</code>: Modo de selección.<li><code>v</code>: Visual y selección.<li><code>t</code>: Modo de terminal.<li><code>o</code>: Modo de espera de operador.<li><code>''</code>: Sí, una cadena de texto vacía. Es el equivalente a <code>n</code> + <code>v</code> + <code>o</code>.</ul><li><p><code>{lhs}</code> es el atajo que queremos crear.</p><li><p><code>{rhs}</code> es la acción que queremos ejecutar. Puede ser un comando, una expresión o una función de lua.</p><li><p><code>{opts}</code> este parámetro debe ser una tabla de lua. Si no saben qué es una tabla, sólo piensen que es una manera albergar varios tipos de datos en un lugar. Estas son las propiedades de uso común.</p> <ul><li><p><code>desc</code>: Cadena de texto que describe qué hace el comando. Aquí podemos escribir cualquier cosa.</p><li><p><code>remap</code>: Booleano que controla si nuestro atajo debe ser recursivo. Su valor por defecto es <code>false</code>. Los atajos recursivos pueden crear conflictos, así que no lo habiliten si no tienen idea de lo que están haciendo. Luego les explico con más detalle.</p><li><p><code>buffer</code>: Puede ser un Booleano o un número. Si el valor es el booleano <code>true</code> quiere decir que al atajo sólo tendrá efecto en el archivo actual. Si es un número deberá ser el "id" de un archivo que tenemos abierto.</p><li><p><code>silent</code>: Booleano que controla si el atajo puede mostrar un mensaje. Su valor por defecto es <code>false</code>.</p><li><p><code>expr</code>: Booleano. Si lo habilitamos tendremos la posibilidad de usar vimscript o lua para generar el valor del parámetro <code>{rhs}</code>. Su valor por defecto es <code>false</code>.</p></ul></ul><h3 id=la-tecla-lider>La tecla líder</h3><p>Cuando definimos nuestros atajos podemos usar la secuencia especial <code>&lt;leader></code> en el parámetro <code>{lhs}</code>, esta toma el valor que tenemos en la variable global <code>mapleader</code>.<p><code>mapleader</code> es una variable que debe ser una cadena texto. Por ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.g.mapleader</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> ','</span></span></code></pre><p>Con esto podríamos usar la tecla <code>,</code> como un prefijo para nuestros atajos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>w'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>write&lt;cr>'</span><span>)</span></span></code></pre><p>Y así la secuencia <code>,</code> + <code>w</code> guarda el archivo actual.<p>¿Qué pasa si no definimos <code>mapleader</code>? Por defecto tiene el valor <code>\</code>, que no es lo mejor del mundo. Mi recomendación para la tecla líder es usar <code>Espacio</code>. Pueden hacer esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.g.mapleader</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> ' '</span></span></code></pre><h3 id=atajos>Atajos</h3><p>Ahora les mostraré algunos atajos que pueden ser útiles para ustedes.<ul><li>Copiar y pegar del portapapeles</ul><p>Por defecto Neovim (y Vim) no interactúa con el portapapeles. Cuando copiamos algún texto con la tecla <code>y</code> el contenido se va un registro interno. Yo prefiero conservar esta funcionalidad y crear atajos dedicados para manipular el portapapeles.<p>Copia al portapapeles.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'x'</span><span>}, </span><span style=color:#98bb6c>'gy'</span><span>, </span><span style=color:#98bb6c>'"+y'</span><span>)</span></span></code></pre><p>Pegar desde el portapapeles.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'x'</span><span>}, </span><span style=color:#98bb6c>'gp'</span><span>, </span><span style=color:#98bb6c>'"+p'</span><span>)</span></span></code></pre><ul><li>Borrar texto sin alterar el registro</ul><p>Cuando borramos algo en modo normal o visual usando <code>c</code>, <code>d</code> o <code>x</code> ese texto se va un registro. Esto afecta el texto que podemos pegar con la tecla <code>p</code>. Lo que quiero hacer es modificar <code>x</code> y <code>X</code> para poder borrar texto sin afectar el historial de copias.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'x'</span><span>}, </span><span style=color:#98bb6c>'x'</span><span>, </span><span style=color:#98bb6c>'"_x'</span><span>)</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'x'</span><span>}, </span><span style=color:#98bb6c>'X'</span><span>, </span><span style=color:#98bb6c>'"_d'</span><span>)</span></span></code></pre><p>Con estos atajos <code>x</code> puede borrar un caracter en modo normal, en modo visual va a borrar la selección actual. La <code>X</code> va a tener el mismo comportamiento del comando <code>d</code>.<ul><li>Seleccionar todo el texto</ul><pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>a'</span><span>, </span><span style=color:#98bb6c>':keepjumps normal! ggVG&lt;CR>'</span><span>)</span></span></code></pre><h2 id=plugin-manager>Plugin manager</h2><p>Aquí vamos a usar <a rel="noopener external" href=https://nvim-mini.org/mini.nvim/ target=_blank>mini.nvim</a>.<p>mini.nvim es una colección de módulos escritos en lua. Uno de esos módulos es el manejador de plugins que vamos a usar, <code>mini.deps</code>.<p>Deben saber el equipo de Neovim está trabajando en un <a rel="noopener external" href=https://neovim.io/doc/user/pack.html#_plugin-manager target=_blank>manejador de plugins</a> que estará en incluido en Neovim <code>v0.12</code>. Este manejador de plugins estará basado en <code>mini.deps</code>.<p>Ahora bien, <em>¿cómo se instala un plugin sin un manejador de plugins?</em><p>En Vim (y Neovim) es posible instalar un plugin si lo descargamos en una ubicación especial. El truco está en saber dónde. Lo que haremos será escribir una función (en lua) para descargar mini.nvim.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local mini</span><span style=color:#e6c384> =</span><span> {}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>mini.branch</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'main'</span></span>
<span class=giallo-l><span>mini.packpath</span><span style=color:#e6c384> =</span><span> vim.fn.</span><span style=color:#7e9cd8>stdpath</span><span>(</span><span style=color:#98bb6c>'data'</span><span>) </span><span style=color:#e6c384>..</span><span style=color:#98bb6c> '/site'</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>function</span><span style=color:#7e9cd8> mini</span><span>.</span><span style=color:#7e9cd8>require_deps</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  local uv</span><span style=color:#e6c384> =</span><span> vim.uv</span><span style=color:#e6c384> or</span><span> vim.loop</span></span>
<span class=giallo-l><span>  local mini_path</span><span style=color:#e6c384> =</span><span> mini.packpath</span><span style=color:#e6c384> ..</span><span style=color:#98bb6c> '/pack/deps/start/mini.nvim'</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>  if</span><span style=color:#e6c384> not</span><span> uv.</span><span style=color:#7e9cd8>fs_stat</span><span>(mini_path) </span><span style=color:#957fb8>then</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    print</span><span>(</span><span style=color:#98bb6c>'Installing mini.nvim....'</span><span>)</span></span>
<span class=giallo-l><span>    vim.fn.</span><span style=color:#7e9cd8>system</span><span>({</span></span>
<span class=giallo-l><span style=color:#98bb6c>      'git'</span><span>,</span></span>
<span class=giallo-l><span style=color:#98bb6c>      'clone'</span><span>,</span></span>
<span class=giallo-l><span style=color:#98bb6c>      '--filter=blob:none'</span><span>,</span></span>
<span class=giallo-l><span style=color:#98bb6c>      'https://github.com/nvim-mini/mini.nvim'</span><span>,</span></span>
<span class=giallo-l><span style=color:#7e9cd8>      string.format</span><span>(</span><span style=color:#98bb6c>'--branch=%s'</span><span>, mini.branch),</span></span>
<span class=giallo-l><span>      mini_path</span></span>
<span class=giallo-l><span>    })</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    vim.</span><span style=color:#7e9cd8>cmd</span><span>(</span><span style=color:#98bb6c>'packadd mini.nvim | helptags ALL'</span><span>)</span></span>
<span class=giallo-l><span style=color:#957fb8>  end</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>  local ok, deps</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> pcall</span><span>(</span><span style=color:#7e9cd8>require</span><span>, </span><span style=color:#98bb6c>'mini.deps'</span><span>)</span></span>
<span class=giallo-l><span style=color:#957fb8>  if</span><span style=color:#e6c384> not</span><span> ok</span><span style=color:#957fb8> then</span></span>
<span class=giallo-l><span style=color:#957fb8>    return</span><span> {}</span></span>
<span class=giallo-l><span style=color:#957fb8>  end</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>  return</span><span> deps</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span></span></code></pre><p>Aquí tenemos una tabla de lua llamada <code>mini</code>, y esta contiene un par de opciones y una función.<p>La función <code>.require_deps()</code> usará el comando <code>git clone</code> para descargar mini.nvim si no se encuentra instalado en nuestro sistema. Luego intentará cargar el módulo <code>mini.deps</code> de manera segura. Ahora bien, este código simplemente crea la función. Para que tenga efecto debemos invocarla.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local MiniDeps</span><span style=color:#e6c384> =</span><span> mini.</span><span style=color:#7e9cd8>require_deps</span><span>()</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>if</span><span style=color:#e6c384> not</span><span> MiniDeps.setup</span><span style=color:#957fb8> then</span></span>
<span class=giallo-l><span style=color:#957fb8>  return</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span></span></code></pre><p>Si todo sale bien la variable <code>MiniDeps</code> tendrá todas las funciones del módulo <code>mini.deps</code>. Si resulta que <code>MiniDeps</code> no contiene la función <code>.setup</code> debemos asumir que ocurrió algún error y se detiene la ejecución del script. De esta manera incluso si algo está mal el editor se mantendrá en un estado funcional.<p>En mini.nvim (casi) todos los módulos deben ser activados de manera explícita. Esto quiere decir que luego de usar la función <code>require</code> para cargar un módulo debemos ejecutar la función <code>.setup()</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>MiniDeps.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  path</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    package</span><span style=color:#e6c384> =</span><span> mini.packpath,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>La función <code>.setup()</code> es dónde colocamos nuestra configuración, si necesitamos una. En este caso no es estrictamente necesario. La variable <code>mini.packpath</code> ya contiene el valor que <code>mini.deps</code> espera por defecto. Pero si en algún momento necesitamos cambiar su valor debemos pasar esa información a <code>mini.deps</code>.<p>Ahora vamos a descargar un plugin, un tema para que el editor tenga una mejor apariencia. En este caso debemos usar la función <code>.add()</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>MiniDeps.</span><span style=color:#7e9cd8>add</span><span>(</span><span style=color:#98bb6c>'folke/tokyonight.nvim'</span><span>)</span></span></code></pre><p>Esta es la cantidad mínima de información que <code>mini.deps</code> necesita para descargar un plugin de github. Basta con especificar el nombre del usuario (u organización) y el nombre del repositorio. Y curiosamente <code>.add()</code> funciona de manera similar a nuestra función <code>.require_deps()</code>, se asegura que el plugin esté instalado en nuestro sistema, de no ser así lo descarga, y finalmente lo añade al "runtimepath" de Neovim.<p><code>mini.deps</code> también tiene el concepto de una "especificación," que en inglés lo llaman "plugin spec." En este contexto una especificación es simplemente una tabla de lua que debe tener ciertas propiedades. Así es cómo agregamos más información del plugin que queremos instalar. Podemos por ejemplo decir qué versión queremos instalar o qué rama debe usar para descargar actualizaciones. Este es un ejemplo:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>MiniDeps.</span><span style=color:#7e9cd8>add</span><span>({</span></span>
<span class=giallo-l><span>  source</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'nvim-mini/mini.nvim'</span><span>,</span></span>
<span class=giallo-l><span>  checkout</span><span style=color:#e6c384> =</span><span> mini.branch,</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Noten que reemplazamos la cadena de texto con una tabla de lua. La propiedad <code>source</code> es obligatoria, esta debe ser la URL del plugin. En este caso si sólo especificamos los últimos componentes <code>mini.deps</code> asume que el plugin está alojado en github. La propiedad <code>checkout</code> es donde le decimos qué versión queremos instalar, aquí podemos colocar el nombre de una rama, un tag, o un commit.<p>Vale la pena mencionar que ya instalamos mini.nvim en una ubicación donde <code>mini.deps</code> puede manejarlo. Añadir mini.nvim con <code>MiniDeps.add()</code> es opcional. A menos claro que quieran cambiar algo como la versión o la rama.<p>Ahora vamos a agregar el código para aplicar el nuevo tema para el editor.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.termguicolors</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span></span>
<span class=giallo-l><span>vim.cmd.</span><span style=color:#7e9cd8>colorscheme</span><span>(</span><span style=color:#98bb6c>'tokyonight'</span><span>)</span></span></code></pre><p>Aquí habilitamos la opción <code>termguicolors</code> de Neovim para asegurarnos de tener la "mejor versión" del tema. Cada tema puede tener dos versiones, una para terminales que sólo soportan 256 colores y otra que utiliza códigos en hexadecimal (tiene más variedad de colores).<p>Para decirle a Neovim qué tema queremos usamos el comando <code>colorscheme</code>. Okey... técnicamente estamos usando una función de lua, pero esa función esta ejecutando un comando de vim.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>colorscheme tokyonight</span></span></code></pre><p>Ahora guardamos los cambios y reiniciamos Neovim. Al abrir Neovim nuevamente deberá aparecer un mensaje que nos muestra que se está clonando el repositorio de mini.nvim. Una vez que termine el proceso de descarga entonces <code>mini.deps</code> empezará a instalar el resto de los plugins.<h2 id=configuracion-de-plugins>Configuración de plugins</h2><p>Cada autor puede crear el método de configuración que mejor le parezca. ¿Cómo sabemos qué debemos hacer? Leemos la documentación, no nos queda de otra.<p>Cada plugin como mínimo debe tener un archivo llamado <code>README.md</code>. Este es el archivo que github nos muestra en la página principal del repositorio. Ahí debemos buscar las instrucciones de configuración.<p>Si el archivo <code>README.md</code> no tiene la información que nos interesa busquen una carpeta llamada <code>doc</code>. Por lo general ahí se encuentra un archivo <code>txt</code>, esa es la página de ayuda. Podemos leer ese archivo desde github o desde Neovim si usamos el comando <code>:help nombre-archivo</code>.<h3 id=convenciones-de-plugins-escritos-en-lua>Convenciones de plugins escritos en lua</h3><p>Por suerte para nosotros muchos de los plugins escritos en lua siguen un patrón, usan una función llamada <code>.setup()</code> que acepta una tabla de lua como argumento. Si hay algo que deben aprender para configurar plugins en lua es cómo crear tablas.<p><code>tokyonight.nvim</code>, el tema que acabamos de descargar, es uno de esos plugins que tiene una función <code>.setup()</code>. Usaremos eso como ejemplo.<p>En el repositorio de tokyonight contiene una carpeta llamada <code>doc</code> y dentro está el archivo <code>tokyonight.nvim.txt</code>. Si desean leerlo desde Neovim usen este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help tokyonight.nvim.txt</span></span></code></pre><p>Digamos que queremos deshabilitar las letras cursivas. En nuestra configuración debemos colocar algo como esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- Ver :help tokyonight.nvim-tokyo-night-configuration</span></span>
<span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'tokyonight'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  styles</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    comments</span><span style=color:#e6c384> =</span><span> {italic</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>},</span></span>
<span class=giallo-l><span>    keywords</span><span style=color:#e6c384> =</span><span> {italic</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>},</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Deben tener en cuenta que esta función debe ser ejecutada antes de usar aplicar el tema.<p>¿Cómo sabe uno qué opciones tiene disponible un plugin? Leemos la documentación. Ahí pueden encontrar la sección <code>tokyonight.nvim-tokyo-night-configuration</code>. Ya cuando tienen una referencia de las opciones a la mano, deben conocer la sintaxis que deben usar para crear una tabla de lua. Lo otro que deben tener en cuenta es que cada plugin hará su mejor esfuerzo para mezclar las opciones que trae por defecto con nuestra configuración personal. Incluso si el plugin tiene muchas opciones sólo basta con especificar las opciones que nosotros queremos cambiar.<p>En este punto podemos guardar los cambios y usar al comando <code>:source $MYVIMRC</code>.<p>Vale la pena mencionar que invocar la función <code>.setup()</code> en tokyonight es opcional. No es como en <code>mini.deps</code> que debemos usarla para activar todas las funcionalidades del plugin. Aquí ya tenemos un ejemplo claro de que cada plugin tiene la libertad para hacer lo que quiera. No existe una regla o comportamiento fijo para la función <code>.setup()</code>.<h3 id=plugins-en-vimscript>Plugins en vimscript</h3><p>Aún hay muchos plugins útiles que están escritos en vimscript. En la mayoría de los casos los configuramos usando variables globales. En lua podremos modificar variables globales de vimscript usando <code>vim.g</code>.<p>¿Ya les conté que Neovim viene con un explorador de archivos? Podemos acceder a él con el comando <code>:Lexplore</code>. Este explorador es de hecho un plugin escrito en vimscript, aquí no tenemos una función <code>.setup()</code>. Para saber cómo configurarlo debemos buscar en la documentación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help netrw</span></span></code></pre><p>Si revisan la tabla de contenido de esa página de ayuda notarán una sección llamada <code>netrw-browser-settings</code>. Ahí nos muestran una lista de variables y sus descripciones. Vamos a fijarnos en las que comienzan con el prefijo <code>g:</code>.<p>Por ejemplo, si queremos ocultar el texto de ayuda usamos <code>netrw_banner</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.g.netrw_banner</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 0</span></span></code></pre><p>También podemos cambiar el tamaño de la ventana.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.g.netrw_winsize</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 30</span></span></code></pre><p>Eso es todo... bueno, hay más variables que pueden modificar pero en general esto es lo más básico que deben saber. Revisan la documentación, identifican la variable que quieren modificar y la cambian con <code>vim.g</code>.<h2 id=informacion-extra>Información extra</h2><h3 id=atajos-recursivos-y-no-recursivos>Atajos recursivos y no recursivos</h3><p>Si ya conocen la palabra "recursividad" tal vez puedan intuir qué consecuencias tienen este tipo de atajos. Si no, dejénme demostrarles con un ejemplo.<p>Digamos que tenemos este atajo que abre el explorador de archivos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;F2>'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>Lexplore&lt;cr>'</span><span>)</span></span></code></pre><p>Bien, ahora vamos a crear un atajo recursivo que utilice <code>F2</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;space>&lt;space>'</span><span>, </span><span style=color:#98bb6c>'&lt;F2>'</span><span>, {remap</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>})</span></span></code></pre><p>Si pulsan <code>Espacio</code> dos veces seguidas les aparecerá el explorador. Pero si cambian <code>remap</code> de <code>true</code> a <code>false</code> no aparecerá nada.<p>Con los atajos recursivos podremos usar atajos definidos por nosotros mismos o por plugins. Con los atajos "no recursivos" sólo tendremos acceso a los atajos definidos directamente por Neovim.<p>Por lo general sólo queremos atajos recursivos cuando vamos a usar funcionalidades creadas por plugins.<p>¿Por qué los atajos recursivos pueden causar conflictos? Consideren esto.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'*'</span><span>, </span><span style=color:#98bb6c>'*zz'</span><span>)</span></span></code></pre><p>Noten que estamos usando <code>*</code> en <code>{lhs}</code> y también en <code>{rhs}</code>. Si este atajo fuera recursivo estaríamos creando un ciclo infinito. Neovim intentará llamar a la funcionalidad atada a <code>*</code> y nunca ejecuta <code>zz</code>.<h3 id=comandos-de-usuario>Comandos de usuario</h3><p>Para crear nuestros propios comandos usamos esta función:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_user_command</span><span>({name}, {command}, {opts})</span></span></code></pre><ul><li><p><code>{name}</code> es el nombre del comando, debe una cadena de texto y tiene que empezar con una letra mayúscula.</p><li><p><code>{command}</code> es la acción que queremos ejecutar. Puede una cadena de texto que contiene un fragmento de vimscript o puede ser una función de lua.</p><li><p><code>{opts}</code> debe ser una tabla de lua. No es opcional. Incluso si quieren utilizar todos los valores por defecto deben colocar una tabla vacía.</p></ul><p>Ejemplo, podemos crear un comando dedicado para recargar nuestra configuración.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_user_command</span><span>(</span><span style=color:#98bb6c>'ReloadConfig'</span><span>, </span><span style=color:#98bb6c>'source $MYVIMRC'</span><span>, {})</span></span></code></pre><p>Si quieren saber más detalles de los comandos de usuario revisen la documentación con los comandos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help </span><span style=color:#7e9cd8>nvim_create_user_command</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>:help user-commands</span></span></code></pre><h3 id=autocomandos>Autocomandos</h3><p>Los autocomandos son acciones que Neovim puede ejecutar cuando ocurre un evento. Pueden revisar la lista de eventos con el comando <code>:help events</code>.<p>Podemos crear un autocomando con esta función.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_autocmd</span><span>({event}, {opts})</span></span></code></pre><ul><li><p><code>{event}</code> debe ser el nombre de un evento.</p><li><p><code>{opts}</code> es una tabla de lua. Son las opciones que determinan el comportamiento del autocomando. Estas son algunas propiedades de uso común.</p> <ul><li><p><code>desc</code> es una cadena de texto que describe lo que hace el autocomando.</p><li><p><code>group</code> debe ser un número que representa el <code>id</code> de un grupo o una cadena de texto con el nombre de un grupo.</p><li><p><code>pattern</code> puede ser una tabla de lua o una cadena de texto. Nos permite filtrar los eventos en los que queremos ejecutar la acción. Su valor depende del evento. Deben revisar la documentación del evento para saber los posibles valores. Esta propiedad es opcional.</p><li><p><code>once</code> debe ser un booleano. Si lo habilitamos el autocomando sólo se ejecutará una vez. Su valor por defecto es <code>false</code>.</p><li><p><code>command</code> es una cadena de texto con un fragmento de vimscript. Es la acción que ejecutará el autocomando.</p><li><p><code>callback</code> puede ser una cadena de texto con el nombre de una función de vimscript o una función de lua. Es la acción que ejecutará el autocomando. No puede usarse en combinación con <code>command</code>.</p></ul></ul><p>Aquí les va un ejemplo. Voy a crear un grupo llamado <code>user_cmds</code> y le agregaré dos autocomandos.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local augroup</span><span style=color:#e6c384> =</span><span> vim.api.</span><span style=color:#7e9cd8>nvim_create_augroup</span><span>(</span><span style=color:#98bb6c>'user_cmds'</span><span>, {clear</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_autocmd</span><span>(</span><span style=color:#98bb6c>'FileType'</span><span>, {</span></span>
<span class=giallo-l><span>  pattern</span><span style=color:#e6c384> =</span><span> {</span><span style=color:#98bb6c>'help'</span><span>, </span><span style=color:#98bb6c>'man'</span><span>},</span></span>
<span class=giallo-l><span>  group</span><span style=color:#e6c384> =</span><span> augroup,</span></span>
<span class=giallo-l><span>  desc</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Usar q para cerrar ventana'</span><span>,</span></span>
<span class=giallo-l><span>  command</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'nnoremap &lt;buffer> q &lt;cmd>quit&lt;cr>'</span></span>
<span class=giallo-l><span>})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_autocmd</span><span>(</span><span style=color:#98bb6c>'TextYankPost'</span><span>, {</span></span>
<span class=giallo-l><span>  group</span><span style=color:#e6c384> =</span><span> augroup,</span></span>
<span class=giallo-l><span>  desc</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Resaltar texto copiado'</span><span>,</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  callback</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>event</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span>    vim.highlight.</span><span style=color:#7e9cd8>on_yank</span><span>({higroup</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Visual'</span><span>, timeout</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 200</span><span>})</span></span>
<span class=giallo-l><span style=color:#957fb8>  end</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Crear el grupo es opcional.<p>El primer autocomando creará el atajo <code>q</code> para cerrar la ventana actual, pero sólo si el archivo actual es de tipo <code>help</code> o <code>man</code>. En este ejemplo estoy usando vimscript en la propiedad <code>command</code>, pero también pude haberlo hecho usando lua con la propiedad <code>callback</code>.<p>El segundo autocomando usa una función de lua en la propiedad <code>callback</code>. Esta función lo que hace es resaltar el texto que copiamos. Pueden probar su efecto si copian una línea usando el atajo <code>yy</code>.<p>Para conocer más detalles de los autocomandos revisen la documentación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help autocmd-intro</span></span></code></pre><h3 id=modulos-de-usuario>Módulos de usuario</h3><p>No hay ninguna regla que nos obligue a tener toda nuestra configuración en un solo archivo. Podemos crear módulos para separar la configuración en piezas más pequeñas.<p>La convención es colocar todos nuestros módulos en un "espacio único" para evitar conflictos con plugins. Muchas personas crean un módulo llamado <code>user</code> (ustedes pueden darle otro nombre si quieren). Para esto debemos ir la carpeta donde está <code>init.lua</code>, crear el directorio <code>lua</code>, y dentro creamos <code>user</code>. Podemos hacer todo eso con un comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:call</span><span style=color:#7e9cd8> mkdir</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>stdpath</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>"config"</span><span style=color:#9cabca>)</span><span style=color:#e6c384> . </span><span style=color:#98bb6c>"/lua/user"</span><span style=color:#9cabca>,</span><span style=color:#98bb6c> "p"</span><span style=color:#9cabca>)</span></span></code></pre><p>Ya dentro de <code>/lua/user</code> podemos crear nuestros scripts de lua. Vamos a suponer que tenemos uno llamado <code>settings.lua</code>. Ahora, Neovim no sabe que ese script existe, no lo va a ejecutar, nosotros debemos llamarlo desde <code>init.lua</code> así.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'user.settings'</span><span>)</span></span></code></pre><p>Si quieren saber con detalle cómo funciona require... revisen la documentación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help lua-require</span></span></code></pre><h3 id=la-funcion-require>La función require</h3><p>Algo que deben saber de <code>require</code> es que sólo ejecuta el módulo una vez. ¿Qué quiere decir esto?<p>Consideren este código.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'user.settings'</span><span>)</span></span>
<span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'user.settings'</span><span>)</span></span></code></pre><p>Aquí el script <code>settings.lua</code> sólo se ejecutará una vez. Si desean crear plugins o alguna funcionalidad que depende de un plugin, esto es bueno. Lo malo es que si quieren usar el comando <code>:source $MYVIMRC</code> para "recargar" su configuración no obtendrán el resultado que quieren.<p>Hay un truco que pueden hacer. Pueden invalidar el caché de la función <code>require</code> antes de invocarla con un módulo. Ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local</span><span style=color:#7e9cd8> load</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>mod</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#ffa066>  package.loaded</span><span>[mod] </span><span style=color:#e6c384>=</span><span style=color:#ffa066> nil</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  require</span><span>(mod)</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#7e9cd8>load</span><span>(</span><span style=color:#98bb6c>'user.settings'</span><span>)</span></span>
<span class=giallo-l><span style=color:#7e9cd8>load</span><span>(</span><span style=color:#98bb6c>'user.keymaps'</span><span>)</span></span></code></pre><p>Sí hacemos esto en <code>init.lua</code> el comando <code>source</code> podrá ejecutar los módulos <code>settings</code> y <code>keymaps</code> de manera efectiva.<p><strong>ADVERTENCIA</strong>. Deben tener en cuenta que algunos plugins pueden actuar de manera extraña si los configuran más de una vez. Es decir, si ustedes usan <code>:source $MYVIMRC</code> y provocan que la función <code>.setup()</code> de un plugin se ejecute por segunda vez puede causar efectos inesperados.<h2 id=init-lua>init.lua</h2><p>Entonces, si aplican (casi) todo lo que les enseñé hoy este sería el resultado.<ul><li><a rel="noopener external" href=https://github.com/VonHeikemen/nvim-starter/blob/01-base/init.lua target=_blank>init.lua</a></ul><h2 id=que-sigue>¿Qué sigue?</h2><p>El siguiente paso es crear un ambiente de desarrollo en el que se sientan productivos. Investiguen qué plugins utiliza la comunidad de Neovim.<p>Este paso puede ser difícil si no saben dónde empezar, por eso he creado una "plantilla" que pueden revisar o incluso usar como base para su propia configuración personal.<ul><li>nvim-light: <a rel="noopener external" href=https://github.com/VonHeikemen/nvim-light target=_blank>github link</a></ul><h2 id=conclusion>Conclusión</h2><p>Ahora sabemos cómo modificar las opciones básicas de Neovim. Aprendimos cómo crear nuestros propios atajos. Podemos hacer que Neovim descargue plugins desde github. Configuramos un par de plugins, uno escrito en lua, otro escrito en vimscript. Dimos un vistazo a temas como atajos recursivos, comandos de usuario, autocomandos, módulos y algunos trucos.<p>En este punto ya tenemos todas la herramientas para explorar plugins, ver las configuraciones de otras personas y aprender de ellas.<hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/como-crear-tu-primera-configuracion-de-neovim-usando-lua-dah rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/build-your-first-neovim-configuration-in-lua-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>