<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Todo lo que necesitan saber para configurar neovim usando lua | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, neovim, shell, software, coding, development" name=keywords><meta content="Tus primeros pasos hacia una configuración creada en lua" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2025 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Todo lo que necesitan saber para configurar neovim usando lua</h1><span class=post-date>2021-07-29 | 16 minutos | <a href=https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/> Read in english </a> </span><blockquote>Última actualización: 2024-07-27</blockquote><p>Después de mucho tiempo en desarrollo neovim 0.5 por fin fue liberado como una versión estable. Entre las nuevas mejoras tenemos un mejor soporte para lua y la promesa de una api estable para crear nuestra configuración usando este lenguaje. Aprovechando esto hoy voy compartir con ustedes todo lo que aprendí mientras migraba mi configuración de vimscript a lua.<p>Si neovim es completamente nuevo para ustedes y su objetivo es configurarlo desde cero, les recomiendo leer esto: <a href=https://vonheikemen.github.io/devlog/es/tools/build-your-first-lua-config-for-neovim/>Cómo crear tu primera configuración de Neovim usando lua</a>.<p>Aquí voy a hablar de lo que podemos hacer en lua y su interacción con vimscript. Aunque presentaré muchos ejemplos, no les diré qué configuración deben activar o con qué valor. No hablaré de cosas específicas de algún lenguaje, y tampoco abordaré el tema de "convertir neovim en un IDE". Sólo espero darles una buena base para que puedan migrar su propia configuración.<p>Asumiré que su sistema operativo es linux (o algo parecido) y que su configuración está en la ruta <code>~/.config/nvim/init.vim</code>. Todo lo que mencionaré debería funcionar en cada sistema donde pueden instalar neovim, sólo tengan en cuenta que la ruta de <code>init.vim</code> puede ser diferente en su caso.<p>Comencemos.<h2 id=primeros-pasos>Primeros pasos</h2><p>Lo primero que deben saber es que podemos incorporar código escrito en lua directamente en nuestro <code>init.vim</code>. Podemos comenzar la migración de manera gradual desde <code>init.vim</code>, y reemplazar <code>init.vim</code> por <code>init.lua</code> sólo cuando estemos listos.<p>Empezemos con el "hola mundo" para probar que todo funciona de manera correcta. Pueden colocar esto en su <code>init.vim</code>:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>lua</span><span> &lt;&lt;EOF
</span><span style=color:#69c>print</span><span>(</span><span style=color:#99c794>'hola desde lua'</span><span>)
</span><span>EOF
</span></code></pre><p>Si ejecutan nuevamente <code>init.vim</code> o reinician neovim el mensaje <code>hola desde lua</code> debería aparecer justo debajo de su barra de estado. Aquí estamos utilizando algo llamado <code>lua-heredoc</code>. Todo lo que está encerrado en <code>&lt;&lt;EOF ... EOF</code> es considerado un "script" que será evaluado por el comando <code>lua</code>. Resulta útil cuando queremos ejecutar código con múltiples líneas pero no es estrictamente necesario si sólo necesitamos una. También podemos hacer esto.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>lua print</span><span>(</span><span style=color:#99c794>'esto también funciona'</span><span>)
</span></code></pre><p>Pero si vamos a llamar código lua desde vimscript lo que yo recomendaría sería "llamar" un script verdadero. En lua podemos hacer eso con la función <code>require</code>. Para que esto funcione necesitamos crear una carpeta llamada <code>lua</code> y colocarla en un directorio que se encuentre en el <code>runtimepath</code> de neovim.<p>Lo más conveniente sería usar el mismo directorio desde se encuentra <code>init.vim</code>, entonces lo que haremos será crear <code>~/.config/nvim/lua</code>, y dentro de esa carpeta colocaremos el script que llamaremos <code>basic.lua</code>. Por ahora sólo imprimiremos un mensaje.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>hola desde ~/config/nvim/lua/basic.lua</span><span style=color:#5fb3b3>')
</span></code></pre><p>Ahora desde <code>init.vim</code> podemos invocarlo de esta manera.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>lua require</span><span>(</span><span style=color:#99c794>'basic'</span><span>)
</span></code></pre><p>Aquí neovim buscará en todos los directorios del <code>runtimepath</code> una carpeta llamada <code>lua</code> y luego dentro de esa carpeta buscará <code>basic.lua</code>. El último script que encuentre que cumpla estas condiciones será ejecutado.<p>Una particularidad de lua que van a encontrar es que podemos usar el <code>.</code> como un separador de ruta. Por ejemplo, imaginemos que tenemos el archivo <code>~/.config/nvim/lua/usermod/settings.lua</code>. Si queremos llamar al archivo <code>settings.lua</code> podemos hacerlo de la siguiente manera.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>usermod.settings</span><span style=color:#5fb3b3>')
</span></code></pre><p>Es una convención común que van a encontrar si revisan el código de otras personas. Sólo recuerden que el punto es un separador de ruta.<p>Con este conocimiento ya están preparados para empezar su configuración en lua.<h2 id=opciones-del-editor>Opciones del editor</h2><p>Cada opción en neovim está disponible para nosotros en la variable global llamada <code>vim</code>... bueno, es más que una variable, es un módulo. Con <code>vim</code> tenemos acceso a opciones, a la api de neovim e incluso un conjunto de funciones auxiliares (una librería estándar). Por ahora lo que nos interesa es algo que llaman "meta-accessors", es lo que usaremos para acceder a las opciones del editor.<h3 id=ambitos>Ámbitos</h3><p>Al igual que en vimscript, en lua tenemos diferentes ámbitos para cada opción. Tenemos opciones que son globales, opciones que actúan sólo en una ventana, otras que aplican sólo para los archivos abiertos, etc. Cada uno tiene su propio espacio dentro del módulo <code>vim</code>.<ul><li>vim.o</ul><p>Sirve para leer o modificar opciones generales del editor.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>o</span><span style=color:#5fb3b3>.</span><span>background </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>light</span><span style=color:#5fb3b3>'
</span></code></pre><ul><li>vim.wo</ul><p>Lee o modifica valores específicos para una ventana.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>wo</span><span style=color:#5fb3b3>.</span><span>colorcolumn </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>80</span><span style=color:#5fb3b3>'
</span></code></pre><ul><li>vim.bo</ul><p>Lee o modifica valores específicos para un archivo (buffer).<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>bo</span><span style=color:#5fb3b3>.</span><span>filetype </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>lua</span><span style=color:#5fb3b3>'
</span></code></pre><ul><li>vim.g</ul><p>Lee o modifica valores globales. Aquí más que todo encontrarán valores usados por plugins. La única opción que conozco que no está necesariamente ligada a un plugin es la tecla líder.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#5f6364>-- espacio como tecla líder
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>mapleader </span><span style=color:#5fb3b3>= ' '
</span></code></pre><p>Una cosa que deben tener en cuenta es que algunos nombres de variables en vimscript no son válidos en lua. Aún podemos acceder a ellos pero debemos usar una sintaxis diferente. Por ejemplo <a href=https://github.com/dhruvasagar/vim-zoom rel=noopener target=_blank>vim-zoom</a> tiene una variable llamada <code>zoom#statustext</code> y en vimscript podemos modificarla usando <code>let</code>, así:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>g:zoom#statustext = </span><span style=color:#99c794>'Z'
</span></code></pre><p>En lua tendríamos que hacer esto:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>['</span><span style=color:#99c794>zoom#statustext</span><span style=color:#5fb3b3>'] = '</span><span style=color:#99c794>Z</span><span style=color:#5fb3b3>'
</span></code></pre><p>Esta sintaxis también nos sirve para acceder a propiedades que tienen el nombre de una palabra reservada. Por ejemplo <code>for</code>, <code>do</code> y <code>end</code> son palabras reservadas; entonces si tenemos alguna variable con esas propiedades podemos usar esta sintaxis para evitar un error.<ul><li>vim.env</ul><p>Lee o modifica variables de entorno.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>env</span><span style=color:#5fb3b3>.</span><span>FZF_DEFAULT_OPTS </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>--layout=reverse</span><span style=color:#5fb3b3>'
</span></code></pre><p>Tengo entendido que los cambios a estas variables sólo tendrán efecto en la sesión activa del editor.<p>Pero entonces ¿cómo sabemos qué "ámbito" usar cuando vamos a crear nuestra configuración? No se preocupen por eso, pueden pensar en <code>vim.o</code> y compañía como una especie de acceso rápido a una variable, es mejor usarlo para leer valores. Para realizar modificaciones tenemos otra propiedad.<h3 id=vim-opt>vim.opt</h3><p>Con <code>vim.opt</code> podremos modificar opciones generales, de ventana y de archivo.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#5f6364>-- opción de buffer
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>autoindent </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>
</span><span style=color:#5f6364>-- opción de ventana
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>
</span><span style=color:#5f6364>-- opción general
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>autowrite </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><p>En este sentido <code>vim.opt</code> actúa como el comando <code>:set</code> en vimscript, nos da una manera consistente de declarar nuestros valores.<p>Puedo decirles que asignar <code>vim.opt</code> a una variable llamada <code>set</code> funciona a la perfección. Por ejemplo, imaginemos que tenemos este fragmento en vimscript.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#5f6364>" comportamiento de la tecla tab
</span><span style=color:#69c>set</span><span> tabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span> shiftwidth=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span> softtabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set expandtab
</span></code></pre><p>Podemos migrar sin esfuerzo a lua de esta manera.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>set </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt
</span><span>
</span><span style=color:#5f6364>-- comportamiento de la tecla tab
</span><span>set</span><span style=color:#5fb3b3>.</span><span>tabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>shiftwidth </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>softtabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>expandtab </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><blockquote><p>Cuando declaran variables en lua no olviden la palabra clave <code>local</code>. En lua las variables son globales por defecto (esto incluye las funciones).</blockquote><p>¿Qué pasa con las variables globales o las variables de entorno? Para eso deberían seguir usando <code>vim.g</code> y <code>vim.env</code> respectivamente.<p>Lo interesante de <code>vim.opt</code> es que cada propiedad es como un objeto especial, son lo que llaman "meta-tabla". Quiere decir que son objetos que implementan sus propias funciones para operaciones comunes.<p>En el primer ejemplo teníamos esto: <code>vim.opt.autoindent = true</code>, tal vez estén pensando que también pueden inspeccionar su valor de manera normal, así:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>)
</span></code></pre><p>No obtendrán el valor que esperan, <code>print</code> les dirá que <code>vim.opt.autoindent</code> es una tabla. Si quieren acceder a su valor deben usar el método <code>:get()</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>:</span><span style=color:#69c>get</span><span style=color:#5fb3b3>())
</span></code></pre><p>Si realmente quieren saber qué hay dentro de <code>vim.opt.autoindent</code> pueden usar <code>vim.inspect</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>inspect</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>))
</span></code></pre><p>O incluso mejor, si tienen la version 0.7 pueden user el comando <code>:lua =</code> para inspeccionar su valor desde el modo de comandos.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:</span><span style=color:#69c>lua</span><span> = vim.opt.autoindent
</span></code></pre><p>Eso les mostrará el estado interno de la propiedad.<h3 id=tipos-de-datos>Tipos de datos</h3><p>Incluso cuando asignamos un valor a una propiedad de <code>vim.opt</code> hay algo de magia en el fondo. Ahora tienen que saber cómo <code>vim.opt</code> maneja los valores en comparación con vimscript.<ul><li>Booleanos</ul><p>Puede que no parezca muy especial pero aún creo que vale la pena mencionarlos.<p>En vimscript para activar o desactivar alguna opción hacemos esto.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> cursorline
</span><span style=color:#69c>set</span><span> nocursorline
</span></code></pre><p>Este es el equivalente en lua.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false
</span></code></pre><ul><li>Listas</ul><p>Para algunas opciones se espera una lista separada por comas. En este caso podríamos proveer la cadena texto nosotros mismos.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>wildignore </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>*/cache/*,*/tmp/*</span><span style=color:#5fb3b3>'
</span></code></pre><p>Ó podríamos usar una tabla.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>wildignore </span><span style=color:#5fb3b3>= {'</span><span style=color:#99c794>*/cache/*</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>*/tmp/*</span><span style=color:#5fb3b3>'}
</span></code></pre><p>Si revisan el contenido de <code>vim.o.wildignore</code> notarán que es la cadena de texto <code>*/cache/*,*/tmp/*</code>, eso significa que funcionó. Y si quieren estar muy seguros de que funcionó, revisen con este comando dentro de neovim.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:</span><span style=color:#69c>set</span><span> wildignore?
</span></code></pre><p>Obtandrán el mismo resultado.<p>La magia no termina ahí. En ocasiones no necesitamos sobreescribir los valores de la lista, a veces queremos agregar un elemento o tal vez necesitamos eliminarlo. Para facilitar estas tareas <code>vim.opt</code> tiene soporte para las siguientes operaciones:<p><strong>Añadir elemento al final de la lista</strong><p>Tomemos la opción <code>errorformat</code> como ejemplo. Si queremos añadir algo usando vimscript utilizamos este comando.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat+=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua podemos lograr el mismo efecto de dos maneras:<p>Usando el operador <code>+</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>'
</span></code></pre><p>O la función <code>append</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>append</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>')
</span></code></pre><p><strong>Añadir al inicio</strong><p>En vimscript:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat^=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>^ '</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>'
</span><span>
</span><span style=color:#5f6364>-- o su equivalente
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>prepend</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>')
</span></code></pre><p><strong>Eliminar un elemento</strong><p>En vimscript:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat-=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>- '</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>'
</span><span>
</span><span style=color:#5f6364>-- o su equivalente
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>')
</span></code></pre><ul><li>Pares</ul><p>Algunas opciones tienen un formato donde se debe especificar una propiedad y el valor para esa propiedad. Como ejemplo tenemos <code>listchars</code>.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> listchars=</span><span style=color:#69c>tab</span><span>:▸\ ,eol:↲,trail:·
</span></code></pre><p>En lua podemos usar tablas para representar esta opción.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>listchars </span><span style=color:#5fb3b3>= {</span><span style=color:#99c794>eol </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>↲</span><span style=color:#5fb3b3>', </span><span style=color:#99c794>tab </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>▸ </span><span style=color:#5fb3b3>', </span><span style=color:#99c794>trail </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>·</span><span style=color:#5fb3b3>'}
</span></code></pre><blockquote><p>Nota: para que la opción <code>listchars</code> tenga efecto deben activar la opción <code>list</code>. Ver <a href="https://neovim.io/doc/user/options.html#'listchars'" rel=noopener target=_blank>:help listchars</a></blockquote><p>Ya que esto también es una tabla podemos hacer las mismas operaciones que mencioné en la sección anterior.<h2 id=invocando-funciones-de-vim>Invocando funciones de vim</h2><p>Vimscript como cualquier otro lenguaje de programación tiene sus propias funciones nativas (<a href=https://neovim.io/doc/user/usr_41.html#function-list rel=noopener target=_blank>muchas funciones</a>) y gracias al módulo <code>vim</code> podemos acceder a ellas usando <code>vim.fn</code>. Al igual que <code>vim.opt</code>, <code>vim.fn</code> es una meta-tabla, pero en este caso nos permite tener una sintaxis conveniente para llamar funciones de vim. Podemos usar <code>vim.fn</code> para invocar funciones nativas, funciones creadas por nosotros mismos e incluso funciones de plugins que no están en escritos en lua.<p>Podríamos por ejemplo validar la versión de neovim de esta manera:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>if </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>has</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>nvim-0.7</span><span style=color:#5fb3b3>') == </span><span style=color:#f99157>1 </span><span style=color:#c594c5>then
</span><span>  </span><span style=color:#69c>print</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>tenemos neovim 0.7</span><span style=color:#5fb3b3>')
</span><span style=color:#c594c5>end
</span></code></pre><p>¿Por qué estoy comparando el resultado de <code>has</code> con un <code>1</code>? Vimscript no siempre ha tenido booleanos, estos fueron agregados a partir de la versión <code>7.4.1154</code>. Entonces funciones como <code>has</code> devuelven <code>0</code> o <code>1</code> y en lua cualquiera de esos valores pasa la evaluación de un <code>if</code>.<p>Hay casos donde el nombre de la función no es válido en lua. Ya saben que podemos usar corchetes así:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>['</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>']('</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>', </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>Pero también podemos usar la función <code>vim.call</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>', </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>En la práctica <code>vim.fn.unafuncion()</code> y <code>vim.call('unafuncion')</code> tienen exactamente el mismo efecto.<p>Ahora déjenme mostrarle algo genial. La integración lua-vimscript es tan buena que podríamos utilizar un "plugin manager" sin necesidad de adaptaciones especiales.<h3 id=vim-plug-en-lua>vim-plug en lua</h3><p>Sé que hay un montón de gente que utiliza <a href=https://github.com/junegunn/vim-plug/ rel=noopener target=_blank>vim-plug</a> y tal vez se estén preguntando si tienen que migrar a un plugin manager que esté escrito en lua. No tienen que hacerlo, <code>vim.fn</code> y su acompañante <code>vim.call</code> son suficientes para usarlo desde lua.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>Plug </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>['</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>']
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>')
</span><span>
</span><span style=color:#5f6364>-- Los plugins van aquí
</span><span style=color:#5f6364>-- ....
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>')
</span></code></pre><p>Esas tres líneas de código es todo lo que necesitan. Pueden probarlo, esto funciona.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>Plug </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>['</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>']
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>')
</span><span>
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>wellle/targets.vim</span><span style=color:#5fb3b3>'
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>tpope/vim-surround</span><span style=color:#5fb3b3>'
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>tpope/vim-repeat</span><span style=color:#5fb3b3>'
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>')
</span></code></pre><p>Todo eso es válido en lua. Si una función sólo recibe un argumento y ese argumento es una cadena de texto o una tabla, pueden omitir los paréntesis.<p>Si necesitan usar el segundo argumento de <code>Plug</code> deben usar los paréntesis y el segundo argumento debe ser una tabla. Vamos a comparar. Si en vimscript tenemos esto:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>Plug </span><span style=color:#99c794>'scrooloose/nerdtree'</span><span>, {</span><span style=color:#99c794>'on'</span><span>: </span><span style=color:#99c794>'NERDTreeToggle'</span><span>}
</span></code></pre><p>En lua debemos representarlo así:<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>scrooloose/nerdtree</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>on </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>NERDTreeToggle</span><span style=color:#5fb3b3>'})
</span></code></pre><p>Desafortunadamente <code>vim-plug</code> tiene opciones llamadas <code>for</code> y <code>do</code> que como ya mencioné son palabras reservadas, para estos casos debemos envolver el nombre de la propiedad con corchetes y comillas.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>junegunn/goyo.vim</span><span style=color:#5fb3b3>', {['</span><span style=color:#99c794>for</span><span style=color:#5fb3b3>'] = '</span><span style=color:#99c794>markdown</span><span style=color:#5fb3b3>'})
</span></code></pre><p>Una última cosa, la opción <code>do</code> se usa para ejecutar una acción cuando se instala o actualiza un plugin. Esta opción acepta una cadena de texto o una función. Si queremos usar una función no estamos obligados a pasar una "función de vim", podemos usar una función de lua sin ningún problema.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>VonHeikemen/rubber-themes.vim</span><span style=color:#5fb3b3>', {
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>['</span><span style=color:#99c794>do</span><span style=color:#5fb3b3>'] = </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>termguicolors </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>colorscheme rubber</span><span style=color:#5fb3b3>')
</span><span style=color:#69c>  </span><span style=color:#c594c5>end
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Ahora ya saben, no tienen que preocuparse si su plugin manager no está escrito en lua. Siempre y cuando exponga alguna función podremos usarlo en lua.<h2 id=vimscript-aun-es-nuestro-amigo>Vimscript aún es nuestro amigo</h2><p>Algunos de ustedes habrán notado que en el último ejemplo usé <code>vim.cmd</code> para configurar el tema del editor. Esto es porque aún hay cosas que no podemos hacer en lua. Con <code>vim.cmd</code> podemos ejecutar expresiones escritas en vimscript. Esto nos permite invocar comandos que no tienen un equivalente en lua.<p><code>vim.cmd</code> también es capaz de ejecutar múltiples líneas de vimscript. Significa que podemos hacer múltiples cosas en una sola llamada a <code>vim.cmd</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>[[
</span><span style=color:#99c794>  syntax enable
</span><span style=color:#99c794>  colorscheme rubber
</span><span style=color:#5fb3b3>]]
</span></code></pre><p>Cualquier fragmento de su <code>init.vim</code> que no puedan "traducir" a lua pueden colocarlo una cadena de texto y pasarlo a <code>vim.cmd</code>.<p>Ya que podemos ejecutar cualquier comando de vim tengo que mencionar que eso incluye <code>source</code>, con esto podemos invocar scripts escritos en vimscript. Por ejemplo, digamos que estamos migrando nuestra configuración pero aún no estamos listos para migrar nuestros atajos de teclado. Podemos crear un archivo <code>keymaps.vim</code> con nuestros atajos y ejecutarlo desde lua.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>source ~/.config/nvim/keymaps.vim</span><span style=color:#5fb3b3>'
</span></code></pre><h2 id=atajos-de-teclado>Atajos de teclado</h2><p>No, no necesitamos vimscript. Podemos crearlos usando lua.<p>Para estos casos tenemos la función <code>vim.keymap.set</code> (introducida en la versión v0.7). Esta función acepta 4 argumentos.<ul><li>Modo (o una lista de modos) en el que tendrá efecto nuestro atajo. Pero no podemos usar el nombre del modo, necesitamos usar su forma abreviada. Pueden encontrar una lista completa y detallada <a href=https://github.com/nanotee/nvim-lua-guide#defining-mappings rel=noopener target=_blank>aquí</a>.<li>Atajo que queremos vincular.<li>La acción que queremos ejecutar.<li>Opciones extra. Estas opciones son las mismas que usaríamos en vimscript, pueden encontrar la lista <a href=https://neovim.io/doc/user/map.html#:map-arguments rel=noopener target=_blank>aquí</a>. Pero también acepta un par de nuevas opciones, pueden encontrar los detalles en la documentación <a href=https://neovim.io/doc/user/lua.html#vim.keymap.set() rel=noopener target=_blank>:help vim.keymap.set()</a>.</ul><p>Digamos que queremos trasladar este atajo a lua.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader></span><span>w :write</span><span style=color:#fac863>&lt;CR>
</span></code></pre><p>Tendríamos que hacer esto.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#69c>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&lt;Leader>w</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>:write&lt;CR></span><span style=color:#5fb3b3>')
</span></code></pre><p>Por defecto los atajos serán "no recursivos", lo que significa que no debemos preocuparnos por ocasionar ciclos infinitos. Podríamos crear versiones alternativas de algún atajo. Por ejemplo, si queremos centrar la pantalla después de realizar una búsqueda con <code>*</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#69c>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>*</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>*zz</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Buscar y centrar pantalla</span><span style=color:#5fb3b3>'})
</span></code></pre><p>Podemos usar <code>*</code> en el atajo y la acción, esto no creará ningún conflicto.<p>Hay ocasiones donde necesitamos un atajo recursivo, generalmente cuando la acción que queremos ejecutar fue creada por un plugin. En esta situación podemos proveer la opción <code>remap = true</code> en el último argumento.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#69c>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&lt;leader>e</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>%</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>remap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, {</span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Ir al par correspondiente</span><span style=color:#5fb3b3>'}})
</span></code></pre><p>Un beneficio extra de esta función es que nos permite usar funciones de lua como nuestra "acción".<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#69c>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>Q</span><span style=color:#5fb3b3>', </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span style=color:#69c>  print</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>Hola</span><span style=color:#5fb3b3>')
</span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>, {</span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Saludar</span><span style=color:#5fb3b3>'})
</span></code></pre><p>Hablemos un poco de la opción <code>desc</code>. Esta nos permite agregar una descripción a nuestros atajos. Podemos leer estas descripciones con el comando <code>:map &lt;atajo></code>.<p>Entonces, ejecutar <code>:map *</code> nos mostrará:<pre style=color:#cccece;background-color:#2b2c2f><code><span>n  *           * *zz
</span><span>                 Buscar y centrar pantalla
</span></code></pre><p>Querrán utilizar estas descripciones cuando su atajo ejecute una función de lua. Por qué? Si revisamos <code>Q</code> con el comando <code>:map Q</code> obtenemos:<pre style=color:#cccece;background-color:#2b2c2f><code><span>n  Q           * &lt;Lua function 50>
</span><span>                 Saludar
</span></code></pre><p>No podemos leer el código de la función, entonces el único indicio que tenemos de su funcionalidad es la descripción. Tambien vale la pena mencionar que plugins pueden extraer esta descripción y mostrarlas de una manera más amigable.<h2 id=comandos-de-usuario>Comandos de usuario</h2><p>A partir de la version v0.7 neovim nos permite crear nuestros propios "ex-commands" usando lua, con la función <code>vim.api.nvim_create_user_command</code>.<p><code>nvim_create_user_command</code> espera tres argumentos:<ul><li>Nombre del comando. El nombre <strong>debe</strong> empezar con una letra mayúscula.<li>Comando. Puede ser una cadena de texto o una función de lua.<li>Atributos. Una tabla con las características opcionales que puede tener nuestro comando. Pueden encontrar los detalles en la documentación <a href=https://neovim.io/doc/user/api.html#nvim_create_user_command() rel=noopener target=_blank>:help nvim_create_user_command()</a> y <a href=https://neovim.io/doc/user/map.html#command-attributes rel=noopener target=_blank>:help command-attributes</a>.</ul><p>Digamos que tenemos este comando en vimscript.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>command</span><span>! -bang ProjectFiles call </span><span style=color:#69c>fzf#vim#files</span><span>(</span><span style=color:#99c794>'~/projects'</span><span>, </span><span style=color:#fac863>&lt;bang></span><span style=color:#f99157>0</span><span>)
</span></code></pre><p>En lua tenemos la posibilidad de usar vimscript in una cadena de texto.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_user_command</span><span style=color:#5fb3b3>(
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>ProjectFiles</span><span style=color:#5fb3b3>',
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>"</span><span style=color:#99c794>call fzf#vim#files('~/projects', &lt;bang>0)</span><span style=color:#5fb3b3>",
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>bang </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>)
</span></code></pre><p>O podemos usar una función de lua.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_user_command</span><span style=color:#5fb3b3>(
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>ProjectFiles</span><span style=color:#5fb3b3>',
</span><span style=color:#69c>  </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>input</span><span style=color:#5fb3b3>)
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>', </span><span>input</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bang</span><span style=color:#5fb3b3>)
</span><span style=color:#69c>  </span><span style=color:#c594c5>end</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>bang </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Buscar en directorio projects</span><span style=color:#5fb3b3>'}
</span><span style=color:#5fb3b3>)
</span></code></pre><p>Sí, podemos agregar descripciones a nuestros comandos. Pero en esta ocasión sólo estarán disponibles si el comando ejecuta una función de lua. Para inspeccionar un comando podemos ejecutar <code>:command &lt;nombre></code>. Entonces, el comando <code>:command ProjectFiles</code> nos mostrará:<pre style=color:#cccece;background-color:#2b2c2f><code><span>    Name              Args Address Complete    Definition
</span><span>!   ProjectFiles      0                        Buscar en directorio projects
</span></code></pre><p>Si nuestro comando ejecuta una expresión de vimscript nos mostrará ese código en la columna <code>Definition</code>.<h2 id=autocomandos>Autocomandos</h2><p>Los autocomandos nos permiten ejecutar funciones y comandos cuando neovim emite un evento. Pueden encontrar la lista de eventos en la documentación: <a href=https://neovim.io/doc/user/autocmd.html#events rel=noopener target=_blank>:help events</a>.<p>Digamos que tenemos un autocomando que modifica ligeramente un tema del editor, específicamente el tema <code>rubber</code>.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#c594c5>augroup</span><span> highlight_cmds
</span><span>  </span><span style=color:#69c>autocmd</span><span>!
</span><span>  </span><span style=color:#69c>autocmd</span><span> ColorScheme rubber highlight String guifg=#FFEB</span><span style=color:#f99157>95
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><blockquote><p>Este bloque debe ejecutarse antes de invocar el comando <code>colorscheme</code>.</blockquote><p>Este es el equivalente en lua.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>augroup </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_augroup</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>highlight_cmds</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>clear </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_autocmd</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>ColorScheme</span><span style=color:#5fb3b3>', {
</span><span style=color:#69c>  </span><span style=color:#99c794>pattern </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>rubber</span><span style=color:#5fb3b3>',
</span><span style=color:#69c>  </span><span style=color:#99c794>group </span><span style=color:#5fb3b3>= </span><span>augroup</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#99c794>command </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>highlight String guifg=#FFEB95</span><span style=color:#5fb3b3>'
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Noten que aquí estamos usando una opción llamada <code>command</code>, esta nos permite utilizar únicamente expresiones escritas en vimscript. También podemos usar una función de lua pero no con la propiedad <code>command</code>, tenemos que usar <code>callback</code>.<pre class=language-lua data-lang=lua style=color:#cccece;background-color:#2b2c2f><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>augroup </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_augroup</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>highlight_cmds</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>clear </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_create_autocmd</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>ColorScheme</span><span style=color:#5fb3b3>', {
</span><span style=color:#69c>  </span><span style=color:#99c794>pattern </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>rubber</span><span style=color:#5fb3b3>',
</span><span style=color:#69c>  </span><span style=color:#99c794>group </span><span style=color:#5fb3b3>= </span><span>augroup</span><span style=color:#5fb3b3>,
</span><span style=color:#69c>  </span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Cambiar color de cadenas de texto</span><span style=color:#5fb3b3>'
</span><span style=color:#69c>  callback </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_hl</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, '</span><span style=color:#99c794>String</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>fg </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>#FFEB95</span><span style=color:#5fb3b3>'})
</span><span style=color:#69c>  </span><span style=color:#c594c5>end
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Los autocomandos también pueden tener una descripción. Pero al igual que los comandos de usuario sólo estarán disponibles si están vinculadas a una función de lua. Si queremos revisar los autocomandos de un evento podemos ejecutar el comando <code>:autocmd &lt;evento> &lt;patrón></code>. El comando <code>:autocmd ColorScheme rubber</code> debería mostrarnos:<pre style=color:#cccece;background-color:#2b2c2f><code><span>ColorScheme
</span><span>    rubber    Cambiar color de cadenas de texto
</span></code></pre><p>Para conocer más detalles de los autocomandos pueden leer la documentación, <a href=https://neovim.io/doc/user/api.html#nvim_create_autocmd() rel=noopener target=_blank>:help nvim_create_autocmd()</a> y <a href=https://neovim.io/doc/user/autocmd.html#autocommand rel=noopener target=_blank>:help autocmd</a>.<h2 id=plugin-manager>Plugin manager</h2><p>Tal vez quieran usar un plugin manager que este escrito en lua sólo porque sí. Por lo que he visto estas son sus opciones:<ul><li><a href=https://github.com/savq/paq-nvim/ rel=noopener target=_blank>paq-nvim</a></ul><p>Es un manejador de plugins rápido y sencillo. No es broma, tiene alrededor de 500 líneas de código y fue creado para descargar, actualizar y eliminar plugins. Es todo. Si eso es lo único que necesitan no busquen más, este es el manejador que quieren.<ul><li><a href=https://github.com/folke/lazy.nvim rel=noopener target=_blank>lazy.nvim</a></ul><p>Este se caracteriza por optimizar el tiempo de carga de nuestros plugins. Por defecto buscará cargar nuestros plugins sólo cuando sea necesario. Ofrece una interfaz agradable para actualizar, inspeccionar y eliminar plugins. También nos permite declarar nuestros plugins usando módulos de lua. Podemos especificar versión, dependencias, configuración, entre otras cosas.<ul><li><a href=https://github.com/nvim-mini/mini.deps rel=noopener target=_blank>mini.deps</a></ul><p>Ofrece un punto intermedio entre <code>paq-nvim</code> y <code>lazy.nvim</code>. Tiene funcionalidades útiles que no se encuentran en <code>paq.nvim</code>, por ejemplo, la habilidad de devolver un plugin a una version anterior. Pero <code>mini.deps</code> no tiene opciones avanzadas como <code>lazy.nvim</code>.<h2 id=conclusion>Conclusión</h2><p>Aprendimos cómo usar lua desde vimscript. Sabemos cómo usar vimscript desde lua. Ahora tenemos todas las herramientas para activar, desactivar y modificar cualquier tipo de opción o variable disponible en neovim. Conocemos los métodos para crear nuestros atajos de teclado. Aprendimos sobre comandos y autocomandos. Sabemos cómo usar un manejador de plugins desde lua ya sea que esté escrito en lua o no. Ya estamos listos.<p>Para los que quieren ver un ejemplo de la vida real, aquí les algunos recursos.<p>Esta es una "plantilla" que pueden copiar y modificar a su gusto:<ul><li>nvim-light: <a href=https://github.com/VonHeikemen/nvim-light/blob/main/init.lua rel=noopener target=_blank>init.lua</a> | <a href=https://github.com/VonHeikemen/nvim-light rel=noopener target=_blank>github link</a></ul><p>Y esta es mi configuración personal en github:<ul><li><a href=https://github.com/VonHeikemen/dotfiles/tree/master/my-configs/neovim rel=noopener target=_blank>neovim (v0.10)</a></ul><h2 id=fuentes>Fuentes</h2><ul><li><a href=https://learnxinyminutes.com/docs/lua/ rel=noopener target=_blank>learn x in y minutes: where X=lua</a><li><a href=https://github.com/nanotee/nvim-lua-guide rel=noopener target=_blank>nvim-lua-guide</a><li><a href=https://neovim.io/doc/user/lua.html#:lua-heredoc rel=noopener target=_blank>:help lua-heredoc</a><li><a href=https://neovim.io/doc/user/lua.html#lua-vim-variables rel=noopener target=_blank>:help lua-vim-variables</a><li><a href=https://neovim.io/doc/user/lua.html#lua-stdlib rel=noopener target=_blank>:help lua-stdlib</a><li><a href=https://neovim.io/doc/user/usr_41.html#function-list rel=noopener target=_blank>:help function-list</a><li><a href=https://github.com/curist/dotvim/blob/98b161f0759d3316fcf6a776d03665d6ab4827ee/bundles.lua rel=noopener target=_blank>curist's bundle.lua</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/todo-lo-que-necesitan-saber-para-configurar-neovim-usando-lua-2fon rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/everything-you-need-to-know-to-configure-neovim-using-lua-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>