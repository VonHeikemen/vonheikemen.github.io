<!doctype html><html lang=es><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Devlog | Todo lo que necesitan saber para configurar neovim usando lua</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="vim,neovim,shell,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Tus primeros pasos hacia una configuración creada en lua"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>Whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul>© 2020-2021 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Todo lo que necesitan saber para configurar neovim usando lua</h1><span class=post-date>2021-07-29</span><p>Después de mucho tiempo en desarrollo neovim 0.5 por fin fue liberado como una versión estable. Entre las nuevas mejoras tenemos un mejor soporte para lua y la promesa de una api estable para crear nuestra configuración usando este lenguaje. Aprovechando esto, hoy voy compartir con ustedes todo lo que aprendí mientras migraba mi configuración de vimscript a lua.<p>Vamos a hablar de lo que podemos hacer en lua y su interacción con vimscript. Aunque presentaré muchos ejemplos, no les diré qué configuración deben activar o con qué valor. No hablaré de cosas específicas de algún lenguaje, y tampoco abordaré el tema de "convertir neovim en un IDE". Sólo espero darles una buena base para que puedan migrar su propia configuración.<p>Asumiré que su sistema operativo es linux (o algo parecido) y que su configuración está en la ruta <code>~/.config/nvim/init.vim</code>. Todo lo que mencionaré debería funcionar en cada sistema donde pueden instalar neovim, sólo tengan en cuenta que la ruta de <code>init.vim</code> puede ser diferente en su caso.<p>Comencemos.<h2 id=primeros-pasos>Primeros pasos</h2><p>Lo primero que deben saber es que podemos incorporar código escrito en lua directamente en nuestro <code>init.vim</code>. Podemos comenzar la migración de manera gradual desde <code>init.vim</code>, y reemplazar <code>init.vim</code> por <code>init.lua</code> sólo cuando estemos listos.<p>Empezemos con el "hola mundo" para probar que todo funciona de manera correcta. Pueden intentar lo siguiente, coloquen esto en su <code>init.vim</code>:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>lua</span><span style=color:#cccece> &lt;&lt;EOF
</span><span style=color:#69c>print</span><span style=color:#cccece>(</span><span style=color:#99c794>&#39;hola desde lua&#39;</span><span style=color:#cccece>)
EOF
</span></code></pre><p>El mensaje <code>hola desde lua</code> debería aparecer justo debajo de su barra de estado. Aquí estamos utilizando algo llamado <code>lua-heredoc</code>. Todo lo que está encerrado en <code>&lt;&lt;EOF ... EOF</code> es considerado un "script" que será evaluado por el comando <code>lua</code>. Resulta útil cuando queremos ejecutar código con múltiples líneas pero no es estrictamente necesario si sólo necesitamos una. También podemos hacer esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>lua print</span><span style=color:#cccece>(</span><span style=color:#99c794>&#39;esto también funciona&#39;</span><span style=color:#cccece>)
</span></code></pre><p>Pero si vamos a llamar código lua desde vimscript lo que yo recomendaría sería "llamar" un script verdadero. En lua podemos hacer eso con la función <code>require</code>. Para que esto funcione necesitamos colocar nuestro script en un directorio que se encuentre en el <code>runtimepath</code> de neovim.<p>En esta ocasión vamos a crear un script llamado <code>basic.lua</code> en la ruta <code>~/config/nvim/lua/</code>. Por ahora este script sólo tendrá este contenido.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>print</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>hola desde ~/config/nvim/lua/basic.lua</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Ahora desde <code>init.vim</code> podemos invocarlo de esta manera.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>lua require</span><span style=color:#cccece>(</span><span style=color:#99c794>&#39;basic&#39;</span><span style=color:#cccece>)
</span></code></pre><p>Aquí neovim buscará en todos los directorios del <code>runtimepath</code> una carpeta llamada <code>lua</code> y luego dentro de esa carpeta buscará <code>basic.lua</code>. El último script que encuentre que cumpla estas condiciones será ejecutado.<p>Una particularidad de lua que van a encontrar es que podemos usar el <code>.</code> para denotar un separador de ruta. Por ejemplo, imaginemos que tenemos el archivo <code>~/.config/nvim/lua/usermod/settings.lua</code>. Si queremos llamar al archivo <code>usermod/settings.lua</code> podemos hacerlo de la siguiente manera.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>usermod.settings</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Es una convención común que van a encontrar si revisan el código de otras personas. Sólo recuerden que el punto es un separador de ruta.<p>Con este conocimiento ya están preparados para empezar su configuración en lua.<h2 id=opciones-del-editor>Opciones del editor</h2><p>Cada opción en neovim está disponible para nosotros en la variable global llamada <code>vim</code>... bueno, más que una variable es más como un módulo. Con <code>vim</code> tenemos acceso a opciones, a la api de neovim e incluso un conjunto de funciones auxiliares (una librería estándar). Por ahora lo que nos interesa es algo que llaman "meta-accessors", es lo que usaremos para acceder a las opciones del editor.<h3 id=ambitos>Ámbitos</h3><p>Al igual que en vimscript, en lua tenemos diferentes ámbitos para cada opción. Tenemos opciones que son globales, opciones que actúan sólo en una ventana, otras que aplican sólo para los archivos abiertos, etc. Cada uno tiene su propio espacio dentro del módulo <code>vim</code>.<ul><li>vim.o</ul><p>Sirve para leer o modificar opciones generales del editor.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>o</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>background </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>light</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.wo</ul><p>Lee o modifica valores específicos para una ventana.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>wo</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>colorcolumn </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>80</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.bo</ul><p>Lee o modifica valores específicos para un archivo (buffer).<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>bo</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>filetype </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>lua</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.g</ul><p>Lee o modifica valores globales. Aquí más que todo encontrarán valores usados por plugins. La única opción que conozco que no está necesariamente ligada a un plugin es la tecla líder.<pre style=background-color:#2b2c2f>
<code><span style=color:#5f6364>-- espacio como tecla líder
</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>g</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>mapleader </span><span style=color:#5fb3b3>= &#39; &#39;
</span></code></pre><p>Una cosa que deben tener en cuenta es que algunos nombres de variables en vimscript no son válidos en lua. Aún podemos acceder a ellos pero debemos usar una sintaxis diferente. Por ejemplo <a href=https://github.com/dhruvasagar/vim-zoom>vim-zoom</a> tiene una variable llamada <code>zoom#statustext</code> y en vimscript podemos modificarla usando <code>let</code>, así:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>let </span><span style=color:#cccece>g:zoom#statustext = </span><span style=color:#99c794>&#39;Z&#39;
</span></code></pre><p>En lua tendríamos que hacer esto:<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>g</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>zoom#statustext</span><span style=color:#5fb3b3>&#39;] = &#39;</span><span style=color:#99c794>Z</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Esta sintaxis también nos sirve para acceder a propiedades que tienen el nombre de una palabra reservada. Por ejemplo <code>for</code>, <code>do</code> y <code>end</code> son palabras reservadas; entonces si tenemos alguna variable con esas propiedades podemos usar esta sintaxis para evitar un error.<ul><li>vim.env</ul><p>Lee o modifica variables de entorno.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>env</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>FZF_DEFAULT_OPTS </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>--layout=reverse</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Tengo entendido que los cambios a estas variables sólo tendrán efecto en la sesión activa del editor.<p>Pero entonces ¿cómo sabemos qué "ámbito" usar cuando vamos a crear nuestra configuración? No se preocupen por eso, pueden pensar en <code>vim.o</code> y compañía como una especie de acceso rápido a una variable, es mejor usarlo para leer valores. Para realizar modificaciones tenemos otra propiedad.<h3 id=vim-opt>vim.opt</h3><p>Con <code>vim.opt</code> podremos modificar opciones generales, de ventana y de archivo.<pre style=background-color:#2b2c2f>
<code><span style=color:#5f6364>-- opción de buffer
</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>autoindent </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true

</span><span style=color:#5f6364>-- opción de ventana
</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true

</span><span style=color:#5f6364>-- opción general
</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>autowrite </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><p>En este sentido <code>vim.opt</code> actúa como el comando <code>:set</code> en vimscript, nos da una manera consistente de declarar nuestros valores.<p>Puedo decirles que asignar <code>vim.opt</code> a una variable llamada <code>set</code> funciona a la perfección. Por ejemplo, imaginemos que tenemos este fragmento en vimscript.<pre style=background-color:#2b2c2f>
<code><span style=color:#5f6364>&quot; comportamiento de la tecla tab
</span><span style=color:#69c>set</span><span style=color:#cccece> tabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span style=color:#cccece> shiftwidth=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span style=color:#cccece> softtabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set expandtab
</span></code></pre><p>Podemos migrar sin esfuerzo a lua de esta manera.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#cccece>set </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt

</span><span style=color:#5f6364>-- comportamiento de la tecla tab
</span><span style=color:#cccece>set</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>tabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span style=color:#cccece>set</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>shiftwidth </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span style=color:#cccece>set</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>softtabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span style=color:#cccece>set</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>expandtab </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><blockquote><p>Cuando declaran variables en lua no olviden la palabra clave <code>local</code>. En lua las variables son globales por defecto (esto incluye las funciones).</blockquote><p>Para los que están demasiado acostumbrados a vimscript (mi caso) esta puede ser una manera de mantener una sintaxis que resulte familiar.<p>¿Qué pasa con las variables globales o las variables de entorno? Para eso deberían seguir usando <code>vim.g</code> y <code>vim.env</code> respectivamente.<p>Lo interesante de <code>vim.opt</code> es que cada propiedad es como un objeto especial, son lo que llaman "meta-tabla" en lua. Quiere decir que son objetos que implementan sus propias funciones para operaciones comunes.<p>En el primer ejemplo teníamos esto: <code>vim.opt.autoindent = true</code>, tal vez estén pensando que también pueden inspeccionar su valor de manera normal, así:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>)
</span></code></pre><p>No obtendrán el valor que esperan, <code>print</code> les dirá que <code>vim.opt.autoindent</code> es una tabla. Si quieren acceder a su valor deben usar el método <code>:get()</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>:</span><span style=color:#69c>get</span><span style=color:#5fb3b3>())
</span></code></pre><p>Si realmente quieren saber qué hay dentro de <code>vim.opt.autoindent</code> pueden usar <code>vim.inspect</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>inspect</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>))
</span></code></pre><p>Eso les mostrará el estado interno de la propiedad.<h3 id=tipos-de-datos>Tipos de datos</h3><p>Incluso cuando asignamos un valor a una propiedad de <code>vim.opt</code> hay algo de magia en el fondo. Ahora tienen que saber cómo <code>vim.opt</code> maneja los valores en comparación con vimscript.<ul><li>Booleanos</ul><p>Puede que no parezca muy especial pero aún creo que vale la pena mencionarlos.<p>En vimscript para activar o desactivar alguna opción hacemos esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>set</span><span style=color:#cccece> cursorline
</span><span style=color:#69c>set</span><span style=color:#cccece> nocursorline
</span></code></pre><p>Este es el equivalente en lua.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false
</span></code></pre><ul><li>Listas</ul><p>Para algunas opciones se espera una lista separada por comas. En este caso podríamos proveer la cadena texto nosotros mismos.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>wildignore </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>*/cache/*,*/tmp/*</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Ó podríamos usar una tabla.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>wildignore </span><span style=color:#5fb3b3>= {&#39;</span><span style=color:#99c794>*/cache/*</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>*/tmp/*</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>Si revisan el contenido de <code>vim.o.wildignore</code> notarán que es la cadena de texto <code>*/cache/*,*/tmp/*</code>, eso significa que funcionó. Y si quieren estar muy seguros de que funcionó, revisen con este comando dentro de neovim.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>:</span><span style=color:#69c>set</span><span style=color:#cccece> wildignore?
</span></code></pre><p>Obtandrán el mismo resultado.<p>La magia no termina ahí. En ocasiones no necesitamos sobreescribir los valores de la lista, a veces queremos agregar un elemento o tal vez necesitamos eliminarlo. Para facilitar estas tareas <code>vim.opt</code> tiene soporte para las siguientes operaciones:<p><strong>Añadir elemento al final de la lista</strong><p>Tomemos la opción <code>errorformat</code> como ejemplo. Si queremos añadir algo usando vimscript utilizamos este comando.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>set</span><span style=color:#cccece> errorformat+=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua podemos lograr el mismo efecto de dos maneras:<p>Usando el operador <code>+</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>O la función <code>append</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>append</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p><strong>Añadir al inicio</strong><p>En vimscript:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>set</span><span style=color:#cccece> errorformat^=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua:<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>^ &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;

</span><span style=color:#5f6364>-- o su equivalente

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>prepend</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p><strong>Eliminar un elemento</strong><p>En vimscript:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>set</span><span style=color:#cccece> errorformat-=%f\|%l\ col\ %c\|%m
</span></code></pre><p>En lua:<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat </span><span style=color:#5fb3b3>- &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;

</span><span style=color:#5f6364>-- o su equivalente

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><ul><li>Pares</ul><p>Algunas opciones tienen un formato donde se debe especificar una propiedad y el valor para esa propiedad. Como ejemplo tenemos <code>listchars</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>set</span><span style=color:#cccece> listchars=</span><span style=color:#69c>tab</span><span style=color:#cccece>:▸\ ,eol:↲,trail:·
</span></code></pre><p>En lua podemos usar tablas para representar esta opción.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>opt</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>listchars </span><span style=color:#5fb3b3>= {</span><span style=color:#99c794>eol </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>↲</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>tab </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>▸ </span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>trail </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>·</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><blockquote><p>Nota: para que la opción <code>listchars</code> tenga efecto deben activar la opción <code>list</code>. Ver <a href="https://neovim.io/doc/user/options.html#'listchars'">:help listchars</a></blockquote><p>Ya que esto también es una tabla podemos hacer las mismas operaciones que mencioné en la sección anterior.<h2 id=invocando-funciones-de-vim>Invocando funciones de vim</h2><p>Vimscript como cualquier otro lenguaje de programación tiene sus propias funciones nativas (<a href=https://neovim.io/doc/user/usr_41.html#function-list>muchas</a>), y gracias al módulo <code>vim</code> podemos acceder a ellas usando <code>vim.fn</code>. Esta propiedad al igual que <code>vim.opt</code> es una meta-tabla, pero <code>vim.fn</code> en particular nos permite tener una sintaxis conveniente para llamar funciones de vim. Esto significa que podemos invocar funciones nativas, funciones creadas por nosotros mismos e incluso funciones de plugins que no están en escritos en lua.<p>Podríamos por ejemplo validar la versión de neovim de esta manera:<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>if </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>has</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>nvim-0.5</span><span style=color:#5fb3b3>&#39;) == </span><span style=color:#f99157>1 </span><span style=color:#c594c5>then
  </span><span style=color:#69c>print</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>tenemos neovim 0.5</span><span style=color:#5fb3b3>&#39;)
</span><span style=color:#c594c5>end
</span></code></pre><p>¿Por qué estoy comparando el resultado de <code>has</code> con un <code>1</code>? Vimscript no siempre ha tenido booleanos, estos fueron agregados a partir de la versión <code>7.4.1154</code>. Entonces funciones como <code>has</code> devuelven <code>0</code> o <code>1</code> y en lua cualquiera de esos valores pasa la evaluación de un <code>if</code>.<p>Hay casos donde el nombre de la función no es válido en lua. Ya saben que podemos usar corchetes así:<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>&#39;](&#39;</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>Pero también podemos usar la función <code>vim.call</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>En la práctica <code>vim.fn.unafuncion()</code> y <code>vim.call('unafuncion')</code> tienen exactamente el mismo efecto. Son iguales.<p>Ahora déjenme mostrarle algo genial. La integración lua-vimscript es tan buena que podríamos utilizar un "plugin manager" sin necesidad de adaptaciones especiales.<h3 id=vim-plug-en-lua>vim-plug en lua</h3><p>Sé que hay un montón de gente que utiliza <a href=https://github.com/junegunn/vim-plug/>vim-plug</a>, y tal vez se estén preguntando si tienen que migrar a un plugin manager que esté escrito en lua. No tienen que hacerlo, <code>vim.fn</code> y su acompañante <code>vim.call</code> son suficientes para usarlo desde lua.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#cccece>Plug </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>&#39;]

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/.config/nvim/plugged</span><span style=color:#5fb3b3>&#39;)

</span><span style=color:#5f6364>-- Los plugins van aquí
-- ....

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Si todos sus plugins usan la "forma simple" de <code>vim-plug</code> entonces esas tres líneas de código es todo lo que necesitan. Pueden probarlo, esto funciona.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#cccece>Plug </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>&#39;]

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/.config/nvim/plugged</span><span style=color:#5fb3b3>&#39;)

</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>wellle/targets.vim</span><span style=color:#5fb3b3>&#39;
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>tpope/vim-surround</span><span style=color:#5fb3b3>&#39;
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>tpope/vim-repeat</span><span style=color:#5fb3b3>&#39;

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>No se me olvidó nada. Todo eso es válido en lua. Si una función sólo recibe un argumento, y ese argumento es una cadena de texto o una tabla, pueden omitir los paréntesis.<p>Si declaran todos sus plugins de esa manera pueden copiar y pegar su lista de plugins.<p>Si necesitan usar el segundo argumento de <code>Plug</code> deben usar los paréntesis y el segundo argumento debe ser una tabla. Vamos a comparar. Si en vimscript tenemos esto:<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>Plug </span><span style=color:#99c794>&#39;scrooloose/nerdtree&#39;</span><span style=color:#cccece>, {</span><span style=color:#99c794>&#39;on&#39;</span><span style=color:#cccece>: </span><span style=color:#99c794>&#39;NERDTreeToggle&#39;</span><span style=color:#cccece>}
</span></code></pre><p>En lua debemos representarlo así:<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>scrooloose/nerdtree</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>on </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>NERDTreeToggle</span><span style=color:#5fb3b3>&#39;})
</span></code></pre><p>Desafortunadamente <code>vim-plug</code> tiene opciones llamadas <code>for</code> y <code>do</code> que como ya mencioné son palabras reservadas, para estos casos debemos envolver el nombre de la propiedad con corchetes y comillas.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>junegunn/goyo.vim</span><span style=color:#5fb3b3>&#39;, {[&#39;</span><span style=color:#99c794>for</span><span style=color:#5fb3b3>&#39;] = &#39;</span><span style=color:#99c794>markdown</span><span style=color:#5fb3b3>&#39;})
</span></code></pre><p>Una última cosa, la opción <code>do</code> se usa para ejecutar una acción cuando se instala o actualiza un plugin. Esta opción acepta una cadena de texto o una función. Si queremos usar una función no estamos obligados a pasar una "función de vim", podemos usar una función de lua sin ningún problema.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>VonHeikemen/rubber-themes.vim</span><span style=color:#5fb3b3>&#39;, {
  [&#39;</span><span style=color:#99c794>do</span><span style=color:#5fb3b3>&#39;] = </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
    </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>termguicolors </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
    </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>colorscheme rubber</span><span style=color:#5fb3b3>&#39;)
  </span><span style=color:#c594c5>end
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Ahora ya saben, no tienen que preocuparse si su plugin manager no está escrito en lua. Siempre y cuando exponga alguna función podremos usarlo en lua.<h2 id=vimscript-aun-es-nuestro-amigo>Vimscript aún es nuestro amigo</h2><p>Algunos de ustedes habrán notado que en el último ejemplo usé <code>vim.cmd</code> para configurar el tema del editor. Esto es porque aún hay cosas que no podemos hacer en lua. Por los momentos no podemos crear o invocar comandos, y tampoco podemos crear autocomandos.<p>Para sobrepasar estas limitaciones usamos <code>vim.cmd</code>. Esta función es capaz de ejecutar múltiples líneas de vimscript. Significa que puedes hacer múltiples cosas en una sola llamada a <code>vim.cmd</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>[[
</span><span style=color:#99c794>  syntax enable
  colorscheme rubber

  command! Hola echom &quot;hola!!&quot;
</span><span style=color:#5fb3b3>]]
</span></code></pre><p>Básicamente cualquier fragmento de su <code>init.vim</code> que no puedan "traducir" a lua pueden colocarlo una cadena de texto y pasarlo a <code>vim.cmd</code>.<p>Ya que podemos ejecutar cualquier comando de vim tengo que mencionar que eso incluye <code>source</code>, con esto podemos invocar scripts escritos en vimscript. Por ejemplo, en mi configuración yo lo uso para ejecutar un script que modifica algunos colores del tema.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>source ~/.config/nvim/theme.vim</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Y ese script tiene algo así.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>function! </span><span style=color:#69c>MyHighlights</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>) abort
  hi! link Question String
  hi! link NonText LineNr

  hi! link TelescopeMatching Boolean
  hi! link TelescopeSelection CursorLine
endfunction

</span><span style=color:#c594c5>augroup</span><span style=color:#cccece> MyColors
  </span><span style=color:#69c>autocmd</span><span style=color:#cccece>!
  </span><span style=color:#69c>autocmd</span><span style=color:#cccece> ColorScheme * call </span><span style=color:#69c>MyHighlights</span><span style=color:#cccece>()
</span><span style=color:#c594c5>augroup</span><span style=color:#cccece> END
</span></code></pre><p>Me gusta mantener esta parte separada en su propio script porque es muy probable que siga agregando líneas. Eso y porque no hay manera de traducirlo a lua.<h2 id=atajos-de-teclado>Atajos de teclado</h2><p>Aquí nos encontramos en una situación interesante. Actualmente podemos definir nuestros atajos usando lua pero aún no tenemos una api "conveniente". ¿Por qué digo que no es conveniente? La manera en la que se definen los atajos no se parece a lo que estoy acostumbrado en vimscript. No es familiar. Lo otro es que no podemos asignar funciones de lua a un atajo. Sí es posible ejecutar una función de lua con un atajo pero tenemos que hacer trampa (ya les diré cómo).<p>En fin, estas son las dos funciones que tenemos disponibles.<ul><li><code>vim.api.nvim_set_keymap</code><li><code>vim.api.nvim_buf_set_keymap</code></ul><p>La primera asigna atajos globales y la segunda asigna atajos sólamente en un archivo específico.<p>La función <code>nvim_set_keymap</code> acepta 4 argumentos:<ul><li>Modo en el que tendrá efecto. Usualmente es la forma abreviada del modo. Pueden encontrar una lista completa y detallada <a href=https://github.com/nanotee/nvim-lua-guide#defining-mappings>aquí</a>.<li>Atajo que queremos vincular.<li>La acción que queremos ejecutar.<li>Opciones extra. Estas opciones son las mismas que usaríamos en vimscript (exceptuando la opción <code>buffer</code>), pueden encontrar la lista <a href=https://neovim.io/doc/user/map.html#:map-arguments>aquí</a>.</ul><blockquote><p><code>nvim_buf_set_keymap</code> es casi igual, la única diferencia es que su primer argumento es el número (o id) del buffer. Si usan el número <code>0</code> neovim asume que queremos asignar el atajo al buffer que estamos editando.</blockquote><p>Digamos que queremos trasladar este atajo a lua.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader&gt;</span><span style=color:#cccece>w :write</span><span style=color:#fac863>&lt;CR&gt;
</span></code></pre><p>Tendríamos que hacer esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span></code></pre><p>No es lo más cómodo del mundo pero hay un par de cosas que podemos hacer para mejorar la experiencia.<ul><li>Un alias</ul><p>Si prefieren un enfoque minimalista pueden simplemente asignar esta función a una variable con un nombre más corto.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#cccece>map </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>nvim_set_keymap

</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span></code></pre><ul><li>Una función auxiliar</ul><p>Con este enfoque podríamos aprovecharlo para dejar algunos valores por defecto en las opciones extra. Digo esto porque es considerado una buena práctica que nuestros atajos no sean recursivos, es decir, podríamos dejar <code>{noremap = true}</code> por defecto.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#69c>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>key</span><span style=color:#5fb3b3>)
  </span><span style=color:#5f6364>-- extraer opciones
  </span><span style=color:#c594c5>local </span><span style=color:#cccece>opts </span><span style=color:#5fb3b3>= {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
  </span><span style=color:#c594c5>for </span><span style=color:#cccece>i</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>v </span><span style=color:#c594c5>in </span><span style=color:#69c>pairs</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>key</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>do
    if </span><span style=color:#69c>type</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>i</span><span style=color:#5fb3b3>) == &#39;</span><span style=color:#99c794>string</span><span style=color:#5fb3b3>&#39; </span><span style=color:#c594c5>then </span><span style=color:#cccece>opts</span><span style=color:#5fb3b3>[</span><span style=color:#cccece>i</span><span style=color:#5fb3b3>] = </span><span style=color:#cccece>v </span><span style=color:#c594c5>end
  end

  </span><span style=color:#5f6364>-- soporte básico para atajos de buffer
  </span><span style=color:#c594c5>local </span><span style=color:#cccece>buffer </span><span style=color:#5fb3b3>= </span><span style=color:#cccece>opts</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>buffer
  opts</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>buffer </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>nil

  </span><span style=color:#c594c5>if </span><span style=color:#cccece>buffer </span><span style=color:#c594c5>then
    </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_buf_set_keymap</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>3</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>opts</span><span style=color:#5fb3b3>)
  </span><span style=color:#c594c5>else
    </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>3</span><span style=color:#5fb3b3>], </span><span style=color:#cccece>opts</span><span style=color:#5fb3b3>)
  </span><span style=color:#c594c5>end
end
</span></code></pre><p>Uso básico.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>map </span><span style=color:#5fb3b3>{&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>Lo interesante de esta función es que aprovecha la manera en la que podemos crear tablas en lua. Esto es válido.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>map </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;e</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>%</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>Y también esto.<pre style=background-color:#2b2c2f>
<code><span style=color:#69c>map </span><span style=color:#5fb3b3>{&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;e</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>%</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>}
</span></code></pre><h3 id=invocando-funciones-de-lua>Invocando funciones de lua</h3><p>Si aplicamos lo que aprendimos anteriormente sobre cómo llamar código lua desde vimscript podemos hacer lo siguiente:<p>Asumiendo que tenemos un módulo llamado <code>usermod</code> y este módulo tiene una función llamada <code>unafuncion</code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(
  &#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;,
  &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;,
  &quot;</span><span style=color:#99c794>&lt;cmd&gt;lua require(&#39;usermod&#39;).unafuncion()&lt;CR&gt;</span><span style=color:#5fb3b3>&quot;,
  {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
)
</span></code></pre><p>Las cosas cambian un poco cuando necesitamos una expresión, en ese caso no podremos usar el comando <code>&lt;cmd>lua</code>. Tenemos que usar la variable <code>v:lua</code>, la cual nos permite invocar funciones globales.<p>Para ilustrar este proceso haremos un ejemplo común, haremos que la tecla <code>&lt;Tab></code> sea más "inteligente". Cuando el menú de autocompletado sea visible será capaz de navegar entre la lista de opciones, caso contrarío insertará un caracter <code>&lt;Tab></code>.<pre style=background-color:#2b2c2f>
<code><span style=color:#c594c5>local </span><span style=color:#69c>t </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>)
  </span><span style=color:#c594c5>return </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_replace_termcodes</span><span style=color:#5fb3b3>(</span><span style=color:#cccece>str</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>)
</span><span style=color:#c594c5>end

</span><span style=color:#f99157>_G</span><span style=color:#5fb3b3>.</span><span style=color:#69c>smart_tab </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
  </span><span style=color:#c594c5>if </span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pumvisible</span><span style=color:#5fb3b3>() == </span><span style=color:#f99157>1 </span><span style=color:#c594c5>then
    return </span><span style=color:#69c>t</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;C-n&gt;</span><span style=color:#5fb3b3>&#39;
  </span><span style=color:#c594c5>else
    return </span><span style=color:#69c>t</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;Tab&gt;</span><span style=color:#5fb3b3>&#39;
  </span><span style=color:#c594c5>end
end

</span><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#cccece>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(
  &#39;</span><span style=color:#99c794>i</span><span style=color:#5fb3b3>&#39;,
  &#39;</span><span style=color:#99c794>&lt;Tab&gt;</span><span style=color:#5fb3b3>&#39;,
  &#39;</span><span style=color:#99c794>v:lua.smart_tab()</span><span style=color:#5fb3b3>&#39;,
  {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#99c794>expr </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
)
</span></code></pre><blockquote><p>En lua <code>_G</code> es la variable global que contiene todas las variables globales. No es necesario usarla pero de esa manera queda claro que estoy declarando una variable global a propósito.</blockquote><p>Si se preguntan porque uso <code>t'&lt;C-n>'</code>, es porque no necesitamos retornar el texto <code>&lt;C-n></code>, necesitamos retornar el código que representa <code>&lt;C-n></code> y lo mismo ocurre con <code>&lt;Tab></code>.<p>Si esta api no les parece lo suficientemente buena siempre pueden elegir no migrar sus atajos a lua. Pueden simplemente poner sus atajos en un script <code>.vim</code> y llamarlo desde lua.<pre style=background-color:#2b2c2f>
<code><span style=color:#cccece>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>source ~/.config/nvim/keymap.vim</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Para los que quieren huir de vimscript tanto como sea posible puedo recomendarles algunos plugins:<ul><li><a href=https://github.com/tjdevries/astronauta.nvim>astronauta.nvim</a><li><a href=https://github.com/svermeulen/vimpeccable>Vimpeccable</a><li><a href=https://github.com/bkoropoff/bex.nvim>bex.nvim</a></ul><p>No necesitan descargarlos todos. Cada uno tiene una manera diferente de declarar atajos usando lua. Elijan el que tiene el diseño que más les guste.<h2 id=plugin-manager>Plugin manager</h2><p>Hablando de plugins. Tal vez quieran usar un plugin manager que este escrito en lua sólo porque sí. Por lo que he visto estas son sus opciones:<ul><li><a href=https://github.com/savq/paq-nvim/>paq</a></ul><p>Es un manejador de plugins rápido y sencillo. No es broma, tiene menos de 300 líneas de código y fue creado para descargar, actualizar y eliminar plugins. Es todo. Si eso es todo lo que necesitan no busquen más, este es el manejador que quieren.<ul><li><a href=https://github.com/wbthomason/packer.nvim>packer</a></ul><p>Si quieren algo con más funcionalidades <code>packer</code> es la alternativa. Aparte de lo básico este manejador ofrece opciones para cargar plugins sólo cuando son necesarios, tiene soporte para declarar y manejar plugins con dependencias, tiene soporte para <code>luarocks</code> (este es como un repositorio de paquetes de lua) y también puede manejar "plugins locales". Hace otras cosas pero creo que ya entienden el punto, es bastante completo.<ul><li><a href=https://github.com/kristijanhusak/vim-packager>vim-packager</a></ul><p>No está escrito en lua pero quise agregarlo porque ofrece una interfaz para lua. También quise listarlo porque ofrece más funcionalidades que <code>paq</code> pero menos que <code>packer</code>, así que si buscan un punto intermedio este puede ser una buena opción.<h2 id=conclusion>Conclusión</h2><p>Aprendimos cómo usar lua desde vimscript. Sabemos cómo usar vimscript desde lua. Ahora tenemos todas las herramientas para activar, desactivar y modificar cualquier tipo de opción o variable disponible en neovim. Conocemos los métodos para crear nuestros atajos de teclado, sus limitaciones. Sabemos cómo usar un manejador de plugins desde lua ya sea que esté escrito en lua o no. Ya estamos listos.<p>Para los que quieran ver un ejemplo de la vida real, aquí les dejo un enlace a mi configuración en github: <a href=https://github.com/VonHeikemen/dotfiles/tree/master/my-configs/neovim>neovim</a>.<h2 id=fuentes>Fuentes</h2><ul><li><a href=https://learnxinyminutes.com/docs/lua/>learn x in y minutes: where X=lua</a><li><a href=https://github.com/nanotee/nvim-lua-guide>nvim-lua-guide</a><li><a href=https://neovim.io/doc/user/lua.html#:lua-heredoc>:help lua-heredoc</a><li><a href=https://neovim.io/doc/user/lua.html#lua-vim-variables>:help lua-vim-variables</a><li><a href=https://neovim.io/doc/user/lua.html#lua-stdlib>:help lua-stdlib</a><li><a href=https://neovim.io/doc/user/usr_41.html#function-list>:help function-list</a><li><a href=https://neovim.io/doc/user/api.html#nvim_set_keymap()>:help nvim_set_keymap()</a><li><a href=https://github.com/curist/dotvim/blob/98b161f0759d3316fcf6a776d03665d6ab4827ee/bundles.lua>curist's bundle.lua</a></ul><hr><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>