<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Usando 'abbreviations' en vim | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, shell, software, coding, development" name=keywords><meta content="Buscando usos interesantes para abbreviations en vim" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a></ul> © 2020-2024 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Usando 'abbreviations' en vim</h1><span class=post-date>2020-11-14 | 10 minutos | <a href=https://vonheikemen.github.io/devlog/tools/using-vim-abbreviations/> Read in english </a> </span><p>Una de las cosas que vim hace extremadamente bien es la automatización. Con esto en mente hoy exploraremos una funcionalidad llamada "abbreviations" (abreviación) y cómo podemos usarlas para automatizar cosas en el modo de inserción (se puede usar en otros modos pero sólo nos enfocaremos en el modo de inserción). Primero veremos unos casos básicos y luego nos moveremos hacia áreas más complejas. Pero no se preocupen, haremos todo de manera progresiva, paso a paso.<h2 id=paso-0>Paso 0</h2><p>Para crear una abreviación podemos usar el comando <code>:ab[breviate]</code>. Pero ya que sólo queremos que estén disponibles en el modo de inserción usaremos el comando <code>:iabbrev</code>. Esta es la sintaxis.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev [&LTexpr>] [&LTbuffer>] {abreviación} {expansión}
</span></code></pre><p>En este comando todo lo que se encuentre dentro de un par de <code>[]</code> es opcional. El argumento <code>&LTexpr></code> es para indicar que queremos usar una "expresión" (lo que se considere una expresión en vimscript) para crear la expansión. <code>&LTbuffer></code> es para indicar que queremos que esta abreviación sólo este disponible para el buffer actual. <code>abreviación</code> es el argumento que uno ingresa en modo de inserción y que será remplazado por <code>expansión</code>.<p>El comando anterior puede usarse en conjunto con un <a href=https://learnvimscriptthehardway.stevelosh.com/chapters/12.html rel=noopener target=_blank>autocommand</a> para crear abreviaciones que sólo apliquen a un tipo específico de archivo. Algo así.<pre style=background:#2b2c2f;color:#cccece><code><span>:autocmd FileType html,javascript,typescript,vue
</span><span>  \ :iabbrev &LTbuffer> una-abreviación una-expansión
</span></code></pre><p>En este ejemplo <code>una-abreviación</code> estará disponible en el buffer que sea considerado de tipo <code>html</code>, <code>javascript</code>, <code>typescript</code> o <code>vue</code>. Usando eso en su <code>.vimrc</code> pueden crear sus abreviaciones automáticamente.<h2 id=hola-munod>Hola munod</h2><p>Errores tipográficos. ¿Acaso no les molestan? ¿No les a pasado por lo menos que su código no funciona porque escribieron <code>heigth</code> en lugar de <code>height</code>? Bueno, ya no más. Ahora tenemos las herramientas para arreglar este tipo de errores automáticamente.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev heigth height
</span></code></pre><p>Después de ejecutar ese comando, cuando escriban <code>heigth</code> y presionen <code>espacio</code> se convertirá en <code>height</code>.<p><img alt="arreglando un error" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604437302/devlog/using-vim-abbreviations/1-typos_03-11-2020_16-51.gif><p>Pero la diversión no termina ahí.<h2 id=no-solo-es-para-las-letras>No sólo es para las letras</h2><p>Resulta que también podemos usar secuencias especiales como <code>&LTCR></code> (la tecla <code>enter</code>), <code>&LTUp></code>, <code>&LTTab></code> y muchas otras más. Esto nos da la posibilidad de mover la posición del cursor y crear "snippets" más elaborados.<p>Intentemos con algo común. Una de las cosas que hago en javascript con mucha frecuencia es escribir <code>console.log()</code>, y no sólo soy yo, esto es tan común que algunos editores ya cuentan con un atajo para generarlo. Vim no tiene un atajo para esto pero nosotros podemos hacer uno.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> con@ console.log();&LTLeft>&LTLeft>
</span></code></pre><p><img alt="un snippet simple" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604438822/devlog/using-vim-abbreviations/2-simple-snippet_03-11-2020_17-26.gif><p>El símbolo <code>@</code> no tiene importancia en este caso, es sólo una convención que yo sigo en mi configuración, sólo para recordar que será reemplazado por otra cosa. Uso <code>&LTbuffer></code> porque no quiero que esta abreviación esté presente en cada buffer, sólo en los que pueda usar javascript. Generalmente lo uso con un autocommand con el que mostré anteriormente.<p>Notarán que hay un espacio entre los paréntesis en el método <code>log</code>, eso es porque elegí expandir la abreviación con la tecla <code>espacio</code>. Vim comienza la expansión cuando presiono un "non-keyword character" y ese caracter es agregado al final de la expansión. Por si preguntan, todas las letras y unos caracteres especiales son considerados "keyword character", y cualquier cosa que no sea parte de ese conjunto comenzará la expansión. Si quieren saber más detalles revisen la documentación con <code>:help 'iskeyword'</code>.<p>En fin, si no quieren ese espacio extra pueden comenzar la expansión con la secuencia <code>&LTC-]></code> (<code>control + corchete de cierre</code>) ó con la tecla <code>&LTEsc></code>.<h2 id=espera-alguien-dijo-snippet>Espera... ¿alguien dijo snippet?</h2><p>Sí, claro que sí. Con esta funcionalidad podemos crear snippets complejos como los que encontrarías en un IDE súper avanzado.<p>¿Se encuentran editando un archivo de javascript y quieren crear una expresión de función ejecutada inmediatamente (un <a href=https://developer.mozilla.org/es/docs/Glossary/IIFE rel=noopener target=_blank>iife</a>)? No hay problema.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> iife@ (async function() {})();&LTLeft>&LTLeft>&LTLeft>&LTLeft>&LTLeft>&LTCR>&LTCR>&LTUp>
</span></code></pre><p><img alt="iife snippet" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604442411/devlog/using-vim-abbreviations/3-another-snippet_03-11-2020_18-25.gif><p>Ah, no, ¿saben qué? Sí hay un problema. Tantos <code>&LTLeft></code> molestan un poco. ¿Pueden imaginarse hacer algo así pero con un snippet más complejo, como <code>switch/case</code>? Escribirlo con ese estilo sería tedioso, funcionaría pero sería tedioso. Pero no se preocupen hay una solución para esto.<h3 id=un-escape-del-modo-de-insercion>Un escape del modo de inserción</h3><p>Ya que básicamente estamos automatizando pulsaciones de teclas podemos hacer algo gracioso, podemos "presionar" escape (<code>&LTEsc></code>) para ir al modo normal y tomar ventaja de todas las bondades que trae vim en ese modo. Podríamos reescribir el snippet anterior así.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> iife@ (async function() {})();&LTEsc>4hi&LTCR>&LTCR>&LTUp>
</span></code></pre><p>Con esto tenemos el mismo snippet pero con menos ruido. Reemplazamos todos los <code>&LTLeft></code> con <code>&LTEsc>4hi</code>, es más enigmático pero más corto. Aunque me atrevo a decir que si han usado vim por un tiempo ya deben saber qué pasa si presionan <code>4hi</code> manualmente. Y ya que básicamente sólo entramos en modo normal para ejecutar un comando (<code>4h</code>) y volver nuevamente al modo de inserción, podemos simplificar aún más esa abreviación.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> iife@ (async function() {})();&LTC-o>4h&LTCR>&LTCR>&LTUp>
</span></code></pre><p>En esta ocasión usamos <code>&LTC-o></code> (<code>control</code> + o) para ir al modo normal, también hace que vim entre en modo de inserción luego de ejecutar un comando.<h2 id=ahora-a-las-extravagancias>Ahora a las extravagancias</h2><p>¿Qué tal si llevamos esto un paso más adelante? Hagamos un snippet que deje el cursor en un lugar conveniente sin necesidad de usar direcciones explicitas como <code>&LTLeft></code> y <code>&LTRight></code>.<p>Podría mostrarles otra versión de la abreviación <code>iife@</code> pero quiero darles más ideas. Hagamos un ciclo <code>for</code> "tradicional". Ya saben, como este.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>let </span><span>i </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>; </span><span>i </span><span style=color:#5fb3b3>< {</span><span>PLACEHOLDER</span><span style=color:#5fb3b3>}; </span><span>i</span><span style=color:#5fb3b3>++</span><span>) </span><span style=color:#5fb3b3>{
</span><span>
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Al final de la expansión quiero que el cursor quede donde dice <code>{PLACEHOLDER}</code>, pero sin tanta ceremonia, sólo quiero llegar ahí. ¿Cómo lo logramos? Con una búsqueda. Sí, también podemos iniciar una búsqueda, ya sea con <code>/</code> o con <code>?</code>.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> forii@ for(let i = 0; i &LTz; i++) {&LTCR>&LTCR>}&LTEsc>?z&LTCR>xi
</span></code></pre><p>¿Notaron la <code>z</code>? Ese sería mi placeholder. Luego de que todo ya está escrito presiono <code>&LTEsc></code>, luego <code>?</code> (una búsqueda en reverso), buscamos la <code>z</code>, presionamos <code>enter</code> y eso me lleva a donde quiero, finalmente presionamos <code>xi</code> para borrar la <code>z</code> e ir nuevamente al modo de inserción.<p><img alt="un bonito ciclo for" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604449379/devlog/using-vim-abbreviations/4-with-placeholder_03-11-2020_20-17.gif><h2 id=mas-poder>Más Poder</h2><p>¿Qué más podemos hacer? Podríamos usar argumentos. Usar una palabra como si fuera el argumento de una función. Suena interesante. Sé exactamente dónde necesito algo como eso. Empecemos.<p>¿Alguno de ustedes conoce <a href=https://github.com/sdras/vue-vscode-snippets rel=noopener target=_blank>vue-vscode-snippets</a>? ¿No? Está bien, igual les diré. Esos son snippets de vue para vscode. Uno de esos snippets se llama <code>vimport-export</code>, que es responsable de crear este código.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>import </span><span>Name </span><span style=color:#c594c5>from </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>@/components/Name.vue</span><span style=color:#5fb3b3>';
</span><span>
</span><span style=color:#c594c5>export default </span><span style=color:#5fb3b3>{
</span><span>  component</span><span style=color:#5fb3b3>: {
</span><span>    Name</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>};
</span></code></pre><p>La parte genial de ese snippet es que usa la funcionalidad de cursores múltiples para remplazar <code>Name</code> con el nombre del componente. Tengo que ser sincero, estoy celoso, quisiera tener esa funcionalidad en vim. Ya sé que existe un plugin, pero quiero que sea una funcionalidad nativa. En fin, no necesitamos múltiples cursores, sólo tenemos que usar la misma palabra en lugares diferentes.<p>Esto es lo que va a pasar: voy a poner una palabra (el nombre de mi componente) y luego la abreviación. Así.<pre style=background:#2b2c2f;color:#cccece><code><span>MyComponent vcomp@
</span></code></pre><p>Cuando la expansión comience lo que haré será poner <code>MyComponent</code> en un registro y simplemente lo pegaré en los lugares que necesite. ¿Están listos? Empecemos con el <code>import</code>.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> vcomp@ &LTEsc>bvediimport &LTC-o>P from '@/components/&LTC-o>P.vue';
</span></code></pre><p>El componente principal de esto es <code>&LTEsc>bved</code>. <code>&LTEsc></code> nos lleva al modo normal, <code>b</code> toma el cursor y lo coloca al principio de la palabra anterior (el nombre del componente) y <code>ved</code> seleccionará toda la palabra y la borrará. Gracias a la manera en la que <code>d</code> funciona tendremos el nombre del componente en un registro listo para ser copiado cuando sea necesario.<p>Okey, esa es la primera parte del problema, y para ser justos podríamos resolver la otra parte de la misma manera pero vamos a tomar otro rumbo. El caso común para esto sería cuando vamos a registrar un componente dentro de otro componente, en este caso ya debería existir <code>export default</code> y lo que queremos es agregarlo en la propiedad <code>components</code>. Lo que haremos será automatizar este proceso:<p><img alt="registrando un componente" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604454412/devlog/using-vim-abbreviations/5-vexport_03-11-2020_21-40.gif><p>Esta segunda fase comienza con <code>&LTEsc></code>, luego usamos <code>/</code> para buscar la cadena <code>components: {</code>, terminamos la búsqueda y entramos en modo de inserción en la linea que está debajo usando <code>o</code>, luego usamos <code>&LTTab></code> para llegar al lugar correcto y pegar el nombre del componente (que aún tenemos en un registro) y ponemos una coma. Podríamos terminar en ese punto pero quisiera preservar el mismo orden de los <code>import</code>. Entonces, lo que hacemos es tomar toda la linea donde está el componente con <code>&LTEsc>dd</code>, luego vamos al final de la linea con <code>k$</code>. Para ir al fondo del objeto usamos <code>%</code>, una vez ahí vamos a la última linea con <code>k</code> y creamos otra linea con <code>o</code>. Ya estamos en el lugar que queremos, presionamos <code>&LTEsc></code> para ir al modo normal y pegamos la linea con el componente usando <code>P</code> (<code>p</code> mayúscula). Ahora todo está listo pero queda una linea extra, la borramos usando <code>jdd</code>. Finalmente nos devolvemos al lugar del import con <code>2&LTC-o></code> (necesitamos hacer dos saltos, por eso el 2). Entonces... necesitamos esto:<pre style=background:#2b2c2f;color:#cccece><code><span>&LTEsc>/components: {&LTCR>o&LTTab>&LTEsc>pa,&LTEsc>ddk$%ko&LTEsc>Pjdd2&LTC-o>a
</span></code></pre><p>Y todo junto es así.<pre style=background:#2b2c2f;color:#cccece><code><span>:iabbrev &LTbuffer> vcomp@ &LTEsc>bvediimport &LTC-o>P from '@/components/&LTC-o>P.vue';&LTEsc>/components: {&LTCR>o&LTTab>&LTEsc>pa,&LTEsc>ddk$%ko&LTEsc>Pjdd2&LTC-o>a
</span></code></pre><p><img alt="registrar un componente" src=https://res.cloudinary.com/vonheikemen/image/upload/v1604456390/devlog/using-vim-abbreviations/6-vcomp_03-11-2020_22-15.gif><p>Si tienen tiempo para un ejercicio intenten crear una abreviación que transforme esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Example vvcomp@
</span><span>
</span><span style=color:#c594c5>export default </span><span style=color:#5fb3b3>{
</span><span>
</span><span style=color:#5fb3b3>};
</span></code></pre><p>En esto.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>import </span><span>Example </span><span style=color:#c594c5>from </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>@/components/Example.vue</span><span style=color:#5fb3b3>';
</span><span>
</span><span style=color:#c594c5>export default </span><span style=color:#5fb3b3>{
</span><span>  components</span><span style=color:#5fb3b3>: {
</span><span>    Example</span><span style=color:#5fb3b3>,
</span><span>  </span><span style=color:#5fb3b3>},
</span><span style=color:#5fb3b3>};
</span></code></pre><h3 id=la-cereza-del-pastel>La cereza del pastel</h3><p>Las abreviaciones funcionan incluso dentro un macro. Intenten grabar este macro y úsenlo varias veces.<pre style=background:#2b2c2f;color:#cccece><code><span>0ea vcomp@^]^]j
</span></code></pre><p><code>^]</code> es la tecla <code>&LTEsc></code>.<p><img alt=macros src=https://res.cloudinary.com/vonheikemen/image/upload/v1604457566/devlog/using-vim-abbreviations/7-macro_03-11-2020_22-34.gif><h2 id=conclusion>Conclusión</h2><p>Eso es todo. Es todo lo que tengo por ahora. Espero que hayan encontrado algo útil o al menos algo gracioso que jamás utilizarán.<p>Si necesitan más ideas pueden revisar <a href=https://github.com/VonHeikemen/dotfiles/blob/master/my-configs/vim/snippets.vim rel=noopener target=_blank>mis snippets</a>. Si ustedes tienen alguna idea interesante, díganme.<h2 id=fuentes>Fuentes</h2><ul><li><a href=https://vimhelp.org/map.txt.html#Abbreviations rel=noopener target=_blank>:help abbreviations</a><li><a href=https://learnvimscriptthehardway.stevelosh.com/chapters/08.html rel=noopener target=_blank>Learn Vimscript the Hard Way: Abbreviations</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/usando-abbreviations-en-vim-569i rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/using-vim-abbreviations-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png style=height:60px!important;width:217px!important> </a></div></div>