<!doctype html><html lang=es><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Neovim: Plugins para empezar | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="neovim, vim, shell, software, coding, development" name=keywords><meta content="Explorando plugins para mejorar nuestra experiencia en Neovim" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/es/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/tags/>Explorar tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/>Devlog in english</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Neovim: Plugins para empezar</h1><span class=post-date>2022-09-03 | 18 minutos | <a href=https://vonheikemen.github.io/devlog/tools/neovim-plugins-to-get-started/> Read in english </a> </span><blockquote>Última actualización: 2026-02-02</blockquote><p>Suele pasar que una persona quiere usar Neovim para escribir código pero hay ciertas funcionalidades de otros editores que extrañan. Como por ejemplo tener la lista de archivos abiertos en pestañas, un explorador de archivos con una estructura de árbol, un indicador que muestre la rama de git, entre otras cosas. Bueno, aquí quiero mostrarles algunos plugins que pueden usar para implementar esas funcionalidades en Neovim.<p>Lo único que no cubriré será el autocompletado de código. Configurar un autocompletado inteligente involucra instalar herramientas externas. Esto conlleva una buena cantidad de detalles que deben ser explicados. Para eso les recomiendo leer esto: <a rel="noopener external" href=https://dev.to/vonheikemen/getting-started-with-neovims-native-lsp-client-in-the-year-of-2022-the-easy-way-bp3 target=_blank>Getting started with Neovim's LSP client</a>.<p>Todo el código de configuración que mostraré en esta guía estará este repositorio: <a rel="noopener external" href=https://github.com/VonHeikemen/nvim-starter/tree/02-opinionated target=_blank>nvim-starter - branch: 02-opinionated</a>.<h2 id=requisitos>Requisitos</h2><p>Si ustedes son completamente nuevos en Neovim les recomiendo que aprendan <a rel="noopener external" href=https://learnxinyminutes.com/docs/lua/ target=_blank>la sintaxis de lua</a>. No es necesario saber todo o dominar el lenguaje, como mínimo tengan a la mano una referencia de la sintaxis para saber qué es válido. Casi todos los plugins que presentaré se configuran en ese lenguaje.<p>Si todavía no han creado un archivo de configuración para Neovim, háganlo ahora. Aquí les dejo una guía con todo lo que necesitan saber: <a href=https://vonheikemen.github.io/devlog/es/tools/build-your-first-lua-config-for-neovim/>Cómo crear tu primera configuración de Neovim usando lua</a>.<p>También sería una buena idea descargar la versión estable más reciente de Neovim. Pueden descargarla desde la <a rel="noopener external" href=https://github.com/neovim/neovim/releases target=_blank>sección releases</a> en github. De aquí en adelante voy a asumir que están usando la versión 0.9.5 o mayor.<h2 id=como-instalamos-un-plugin>¿Cómo instalamos un plugin?</h2><p>Lo primero que deben saber es cómo instalar un plugin de forma manual.<p>Para instalar un plugin sólo debemos descargarlo en una ubicación específica.<p>La manera "tradicional" de conocer los directorios disponibles para nuestros plugins es usando este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:set</span><span style=color:#7aa89f> packpath</span><span style=color:#e6c384>?</span></span></code></pre><p>Neovim nos muestra una lista separada por comas. A mi parecer este formato resulta difícil de leer. Podemos hacer algo mejor aprovechando las capacidades de lua.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>:lua vim.</span><span style=color:#7e9cd8>tbl_map</span><span>(</span><span style=color:#7e9cd8>print</span><span>, vim.opt.</span><span style=color:#7aa89f>packpath</span><span>:</span><span style=color:#7e9cd8>get</span><span>())</span></span></code></pre><p>Con esto Neovim les mostrará la misma lista pero cada directorio se muestra en una línea.<p>En uno de esos directorios debemos crear una carpeta llamada <code>pack</code>, y dentro de pack debemos crear el directorio que tendrá nuestros plugins.<p>La estructura de archivos debe ser algo como esto:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>pack</span></span>
<span class=giallo-l><span>└── plugins-de-github</span></span>
<span class=giallo-l><span>    ├── opt</span></span>
<span class=giallo-l><span>    │   ├── [plugin 1]</span></span>
<span class=giallo-l><span>    │   └── [plugin 2]</span></span>
<span class=giallo-l><span>    └── start</span></span>
<span class=giallo-l><span>        └── [plugin 3]</span></span></code></pre><p>Los plugins en el directorio <code>opt</code> son considerados opcionales, Neovim no los usará hasta que nosotros invoquemos el comando <code>:packadd</code> con el nombre del plugin. Los plugins en el directorio <code>start</code> se cargarán de manera automática durante el proceso de inicialización de Neovim.<p>Vamos a suponer que tenemos este directorio en nuestro <code>packpath</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>/home/dev/.local/share/nvim/site</span></span></code></pre><p>Entonces el primer paso será crear el directorio <code>pack</code>. Luego, dentro de pack, creamos otro directorio. A ese directorio podemos darle cualquier nombre. Vamos a usar el nombre <code>github</code> en este ejemplo. Quiere decir que esta es una ubicación válida para nuestros plugins.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>/home/dev/.local/share/nvim/site/pack/github</span></span></code></pre><p>Para instalar un plugin como <a rel="noopener external" href=https://github.com/nvim-mini/mini.nvim target=_blank>mini.nvim</a> y poder usarlo de manera inmediata debemos descargarlo aquí.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>/home/dev/.local/share/nvim/site/pack/github/start/mini.nvim</span></span></code></pre><p>Y eso es todo.<p>Para conocer más detalles de cómo usar plugins desde el directorio <code>pack</code> pueden leer la documentación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help packages</span></span></code></pre><h3 id=manejador-de-plugins>Manejador de plugins</h3><p>Pero claro nadie está obligado a descargar plugins manualmente. Pueden automatizar todo el proceso con un manejador de plugins.<p>En la actualidad estos son los más manejadores de plugins más populares en el ecosistema de Neovim.<ul><li><a rel="noopener external" href=https://github.com/folke/lazy.nvim target=_blank>lazy.nvim</a><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/readmes/mini-deps.html target=_blank>mini.deps</a><li><a rel="noopener external" href=https://github.com/savq/paq-nvim target=_blank>paq.nvim</a></ul><p>Recuerden leer bien la documentación del manejador de plugin que decidan usar.<h2 id=plugins>Plugins</h2><h3 id=tokyonight>Tokyonight</h3><p>Github: <a rel="noopener external" href=https://github.com/folke/tokyonight.nvim target=_blank>folke/tokyonight.nvim</a><p>Para cambiar el tema que Neovim trae por defecto debemos invocar el comando <code>colorscheme</code> seguido del nombre del tema.<p>Ahora bien, en lua para ejecutar comandos usamos <code>vim.cmd</code>. Ejemplo:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.</span><span style=color:#7e9cd8>cmd</span><span>(</span><span style=color:#98bb6c>'colorscheme nombre-tema'</span><span>)</span></span></code></pre><p>En nuestro caso queremos usar tokyonight, así que nuestro comando sería este.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>colorscheme tokyonight</span></span></code></pre><h3 id=bufferline>Bufferline</h3><p>Github: <a rel="noopener external" href=https://github.com/akinsho/bufferline.nvim target=_blank>akinsho/bufferline.nvim</a><p>En Neovim las pestañas son como espacios de trabajo, pueden mostrar varios archivos en una pestaña e incluso cambiar el directorio de trabajo por pestaña. Muchas personas prefieren mostrar un archivo por pestaña, como en otros editores. Eso es exactamente lo que hace <code>bufferline</code>, modifica las pestañas para mostrar todos los archivos abiertos.<p>En este caso nos encontramos con un plugin que debe ser "activado" manualmente. Aquí debemos invocar la función <code>.setup()</code> del módulo principal del plugin. Entonces para que bufferline funcione debemos agregar esta línea de código a nuestra configuración.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'bufferline'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({})</span></span></code></pre><p>La función <code>require</code> es parte del lenguaje lua, es el mecanismo que usamos para cargar un módulo. La cadena de texto <code>bufferline</code> es el nombre del módulo. Y <code>.setup()</code> es la función que queremos ejecutar.<p>Para configurar el plugin debemos colocar nuestras preferencias en una "tabla de lua" dentro de la función <code>.setup()</code>. ¿Cómo sabemos qué opciones tenemos disponibles? Debemos leer la documentación del plugin.<p>Pueden encontrar una referencia con todas las opciones con este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:help bufferline-configuration</span></span></code></pre><p>Este es un ejemplo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'bufferline'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  options</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'buffers'</span><span>,</span></span>
<span class=giallo-l><span>    offsets</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>      {filetype</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'snacks_layout_box'</span><span>}</span></span>
<span class=giallo-l><span>    },</span></span>
<span class=giallo-l><span>  }</span></span>
<span class=giallo-l><span>  highlights</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    buffer_selected</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>      italic</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span>
<span class=giallo-l><span>    },</span></span>
<span class=giallo-l><span>    indicator_selected</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>      fg</span><span style=color:#e6c384> =</span><span> {attribute</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'fg'</span><span>, highlight</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Function'</span><span>},</span></span>
<span class=giallo-l><span>      italic</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>  }</span></span>
<span class=giallo-l><span>})</span></span></code></pre><ul><li><p><code>options.mode</code>: Con el valor <code>'buffers'</code> indicamos que queremos "pestañas tradicionales" que muestran la lista archivos abiertos.</p><li><p><code>options.offsets</code>: Es una lista de tipos de archivos. Cuando aparece una ventana de este tipo <code>bufferline</code> evita colocar una pestaña sobre ella. Aquí le indicamos el tipo de archivo <code>snacks_layout_box</code> porque es el tipo de archivo que tendrá el explorador de archivos que usaremos. Esto hará que se logre el efecto de barra lateral.</p><li><p><code>highlights</code>: Nos permite modificar los colores en ciertas áreas. Cada sección (como <code>buffer_selected</code>) se refiere a un área. En este ejemplo coloco <code>italic = false</code> para desactivar las letras cursivas. La opción <code>fg</code> cambia el color de las letras. En este ejemplo le indico que debe tomar el mismo color que utiliza mi tema para las funciones. Pueden ver los detalles de la opción highlights usando el comando <code>:help bufferline-highlights</code>.</p></ul><p>Vale la pena mencionar que bufferline ofrece varios comandos que podemos usar para navegar entre archivos abiertos. Entre esos comandos está <code>BufferLinePick</code>. Con esto podremos seleccionar cualquier archivo que esté en una pestaña visible en pantalla. Podemos utilizar este comando en un atajo de teclado.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'gt'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>BufferLinePick&lt;cr>'</span><span>, {})</span></span></code></pre><h3 id=mini-nvim>mini.nvim</h3><p>Github: <a rel="noopener external" href=https://github.com/nvim-mini/mini.nvim target=_blank>nvim-mini/mini.nvim</a><p>Website: <a rel="noopener external" href=https://nvim-mini.org target=_blank>nvim-mini.org</a><p><code>mini.nvim</code> es una colección de módulos escritos en lua. Este proyecto tiene el objetivo de complementar las capacidades nativas de Neovim, y en algunos casos también busca implementar nuevas funcionalidades.<p>mini.nvim tiene más de 40 módulos pero aquí sólo les mostraré 7.<ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-statusline.html target=_blank>mini.statusline</a></ul><p>El "statusline" es una parte de la interfaz de Neovim. Es esa línea que se encuentra casi al final de la pantalla, donde se muestra el nombre del archivo actual y la ubicación del cursor. Usualmente se encuentra por encima del área de mensajes.<p><code>mini.statusline</code> modifica la opción <a href="https://neovim.io/doc/user/options.html#'statusline'" rel="noopener external" target=_blank>statusline</a> con una implementación que muestra más información. También puede mostrar información que proviene de otros módulos en mini.nvim.<p>Igual que como ocurre con el plugin bufferline, en mini.nvim debemos habilitar cada módulo de manera explícita. Esto quiere decir que debemos ejecutar la función <code>.setup()</code> del módulo que queremos usar.<p>En el caso de <code>mini.statusline</code> esto sería suficiente para hacer que funcione.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.statusline'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({})</span></span></code></pre><p>Si desean saber más detalles de un módulo en mini.nvim usen el comando <code>:help</code> seguido del nombre del módulo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>:help mini.statusline</span></span></code></pre><ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-git.html target=_blank>mini.git</a></ul><p>Si nos encontramos en un repositorio de git <code>mini.git</code> puede ayudarnos a obtener información sobre el estado actual del repositorio. También ofrece un comando (<code>:Git</code>) con el cual podemos usar git dentro de Neovim.<p>Por defecto <code>mini.statusline</code> puede mostrar la rama de git si activamos <code>mini.git</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.git'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({})</span></span></code></pre><p>El comando <code>:Git</code> que nos ofrece este plugin intenta tanto como sea posible integrar Neovim con git. Por ejemplo, el comando <code>:Git diff</code> muestra el resultado dentro de Neovim. <code>:Git commit</code> intentará usar la instancia actual de Neovim para escribir el mensaje del commit. Para conocer más detalles pueden revisar la documentación.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>:help mini.git</span></span></code></pre><ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-diff.html target=_blank>mini.diff</a></ul><p><code>mini.diff</code> es otro módulo que depende de git. En este caso se muestra las modificaciones que se hicieron en el archivo actual. Puede mostrar cuando una línea ha sido modificada, borrada o si se añadió una línea nueva. Todo en tiempo real.<p>Aquí les comparto mi configuración personal.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.o.signcolumn</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'yes'</span></span>
<span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.diff'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  view</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    style</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'sign'</span><span>,</span></span>
<span class=giallo-l><span>    signs</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>      add</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '▎'</span><span>,</span></span>
<span class=giallo-l><span>      change</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '▎'</span><span>,</span></span>
<span class=giallo-l><span>      delete</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '➤'</span><span>,</span></span>
<span class=giallo-l><span>    },</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Aquí antes de habilitar el plugin modificamos la opción <code>signcolumn</code> con el valor <code>yes</code>, esto lo hacemos para reservar un espacio para los íconos de <code>mini.diff</code>. Dentro de las opciones para <code>mini.diff</code> especificamos el estilo "sign" que es lo que nos permite usar íconos como indicadores.<ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-comment.html target=_blank>mini.comment</a></ul><p><code>mini.comment</code> provee atajos de teclado para comentar o "descomentar" líneas de código. Por defecto utiliza el atajo <code>gc</code> como un operador en modo normal. Por ejemplo, la combinación <code>gci{</code> puede comentar (o descomentar) todas las líneas de comentario dentro de un bloque de código delimitado por llaves. Cualquier combinación que uno puede hacer con un operador nativo, como <code>d</code> o <code>y</code>, también lo podemos hacer con el operador <code>gc</code> que <code>mini.comment</code> provee.<p>Adicionalmente <code>mini.comment</code> crea el atajo <code>gcc</code>. Con <code>gcc</code> podemos comentar la línea actual.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.comment'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({})</span></span></code></pre><p>Vale la pena mencionar que esta funcionalidad que ofrece <code>mini.comment</code> ya forma parte de Neovim. Fue agregada en la versión v0.10 de Neovim. Pero la implementación de Neovim no es muy flexible, no se puede cambiar o extender de ninguna manera. El beneficio de <code>mini.comment</code> es que funciona incluso en Neovim v0.9 y nos da la oportunidad de cambiar algunas opciones, e incluso podemos crear nuestra propia implementación para la función que decide la sintaxis del comentario.<ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-notify.html target=_blank>mini.notify</a></ul><p><code>mini.notify</code> es una implementación para la función <code>vim.notify</code>.<p><code>vim.notify</code> es una función de lua que cualquier plugin puede usar para mostrar un mensaje a un usuario final. La implementación nativa de Neovim muestra los mensajes en el área de mensajes. <code>mini.notify</code> muestra los mensajes en una ventana flotante en una esquina de la pantalla.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.notify'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({})</span></span></code></pre><ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-clue.html target=_blank>mini.clue</a></ul><p><code>mini.clue</code> puede ayudarles a recordar (o tal vez descubrir) atajos de teclado mostrándoles posibles combinaciones en una ventana flotante.<p>La mayoría de los módulos en mini.nvim tienen una buena configuración por defecto. Quiere decir que sólo debemos invocar la función <code>.setup()</code> y usar el plugin. Pero <code>mini.clue</code> es una excepción, aquí debemos especificar las teclas que activan la ventana flotante. Este es un ejemplo:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local mini_clue</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'mini.clue'</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>mini_clue.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  triggers</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'g'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '&lt;leader>'</span><span>},</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  clues</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    mini_clue.gen_clues.</span><span style=color:#7e9cd8>g</span><span>(),</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>En la opción <code>triggers</code> agregamos la combinación que activa la ventana flotante. En <code>clues</code> es donde agregamos la descripción de la acción que hace un atajo de teclado en caso de ser necesario.<p>Lo bueno de <code>mini.clue</code> es que se integra muy bien con Neovim. Cuando creamos nuestros atajos de teclado personales. Si creamos nuestros atajos con la función <code>vim.keymap.set()</code> y proveemos una descripción, eso será suficiente para que <code>mini.clue</code> muestre nuestro atajo en la ventana flotante.<p>Consideren este código.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- Usar tecla Espacio como &lt;leader></span></span>
<span class=giallo-l><span>vim.g.mapleader</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> ' '</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>w'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>write&lt;cr>'</span><span>, {desc</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Guardar'</span><span>})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>q'</span><span>, </span><span style=color:#98bb6c>'&lt;cmd>quit&lt;cr>'</span><span>, {desc</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'Cerrar ventana'</span><span>})</span></span></code></pre><p>Aquí creamos dos atajos de teclado que empiezan con la tecla líder (<code>&lt;leader></code>), que en este caso es <code>Espacio</code>. Como ya tenemos <code>&lt;leader></code> en la opción <code>triggers</code> de <code>mini.clue</code> nuestros atajos aparecerán en la ventana flotante.<p>Para agregar descripciones a los atajos nativos de Neovim debemos usar la propiedad <a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-clue.html#miniclue.gen_clues target=_blank>gen_clues</a>.<p>Una configuración más completa para <code>mini.clue</code> sería algo así:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local mini_clue</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'mini.clue'</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>mini_clue.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  window</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    delay</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 600</span><span>,</span></span>
<span class=giallo-l><span>    config</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>      width</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 50</span><span>,</span></span>
<span class=giallo-l><span>    },</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  triggers</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '['</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> ']'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'g'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'x'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'g'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'z'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'x'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'z'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '&lt;C-w>'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'i'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '&lt;C-x>'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'n'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '&lt;leader>'</span><span>},</span></span>
<span class=giallo-l><span>    {mode</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'x'</span><span>, keys</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '&lt;leader>'</span><span>},</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  clues</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    mini_clue.gen_clues.</span><span style=color:#7e9cd8>g</span><span>(),</span></span>
<span class=giallo-l><span>    mini_clue.gen_clues.</span><span style=color:#7e9cd8>z</span><span>(),</span></span>
<span class=giallo-l><span>    mini_clue.gen_clues.</span><span style=color:#7e9cd8>windows</span><span>(),</span></span>
<span class=giallo-l><span>    mini_clue.gen_clues.</span><span style=color:#7e9cd8>builtin_completion</span><span>(),</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Noten que en este ejemplo tenemos una nueva sección, <code>windows</code>. Aquí especificamos las opciones que controlan el comportamiento de la ventana flotante.<p>Ahora hablemos de limitaciones. Deben saber que <code>mini.clue</code> no funciona con operadores en modo normal. No podremos ver la ventana flotante para combinaciones como <code>ciw</code> o <code>dap</code>. Esto sucede porque los operadores como <code>c</code> y <code>d</code> no se pueden extender. No hay un mecanismo para ejecutar una acción en medio de un operador. Técnicamente es posible lograr el efecto pero requiere un esfuerzo enorme, y mini.nvim se especializa en módulos "ligeros" donde se busca un balance entre funcionalidad y líneas de código.<ul><li><a rel="noopener external" href=https://nvim-mini.org/mini.nvim/doc/mini-icons.html target=_blank>mini.icons</a></ul><p><code>mini.icons</code> podríamos considerarlo como un módulo multi-propósito.<p>Puede ser usado en plugins para mostrar íconos de manera fácil. Recuerden que Neovim funciona en emuladores de terminal. Para un emulador de terminal todo es texto. Un ícono no es una imagen es un código especial.<p>Para nosotros los usuarios casuales <code>mini.icons</code> nos da la oportunidad de habilitar o deshabilitar íconos. Verán, en ocasiones un plugin puede mostrar íconos en ciertas partes de la interfaz pero no ofrece una manera de ocultarlos o reemplazarlos con caracteres normales. <code>mini.icons</code> nos ofrece la posibilidad de desactivar íconos incluso si los plugins que usamos no ofrecen esa opción.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'mini.icons'</span><span>).</span><span style=color:#7e9cd8>setup</span><span>({style</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'glyph'</span><span>})</span></span></code></pre><p>Aquí la opción <code>style</code> es la que controla la clase de íconos que queremos usar. <code>glyph</code> es el valor por defecto, este hará que <code>mini.icons</code> muestre glifos que parecen íconos. Si cambiamos <code>style</code> con el valor <code>ascii</code> entonces los glifos serán reemplazados con caracteres normales que cualquier terminal puede mostrar.<h3 id=vim-repeat>vim-repeat</h3><p>Github: <a rel="noopener external" href=https://github.com/tpope/vim-repeat target=_blank>tpope/vim-repeat</a><p>Agrega soporte para repeticiones a comandos creados por plugins. Si no lo saben, si presionamos <code>.</code> Neovim repite la última acción que hicimos. Por ejemplo, si borramos una palabra usando <code>diw</code> podemos repetir esta acción simplemente presionando <code>.</code>. <code>vim-repeat</code> permite que las acciones de los plugins también pueda repetirse con <code>.</code>.<h3 id=treesitter>Treesitter</h3><p>Github: <a rel="noopener external" href=https://github.com/nvim-treesitter/nvim-treesitter target=_blank>nvim-treesitter/nvim-treesitter</a><p>Treesitter es un componente que se encuentra dentro de Neovim, este le permite a Neovim leer código de la misma manera que un compilador. ¿Cómo es eso? Escanea el código, va recolectando información de cada símbolo y al final genera un árbol de sintaxis. En otras palabras, convierte tu código en una estructura de datos que Neovim puede consultar.<p>Por sí solo treesitter no nos trae ningún beneficio, es más una herramienta para los desarrolladores de Neovim y los autores de plugins. Son ellos los que usan treesitter para crear las funcionalidades con las que nosotros interactuamos.<p>Por ejemplo, dentro de Neovim existe un mecanismo alternativo para el resaltado de sintaxis. En ese caso se utiliza treesitter para asignar los "highlight groups" que serán utilizados por el tema del editor.<p>Ahora bien, para que treesitter funcione necesitamos algo llamado "treesitter parser." Este es el componente que se encarga de leer el código del archivo actual. Cada lenguaje de programación tiene su propio treesitter parser. Para instalar un parser podemos usar el comando <code>:TSInstall</code> seguido del nombre del lenguaje.<p>Si queremos instalar el parser para javascript utilizamos este comando.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:TSInstall javascript</span></span></code></pre><p>Para funcionalidades como tal, en la actualidad no tenemos una interfaz para "habilitar treesitter." Lo que hacemos es revisar la documentación de la funcionalidad que queremos usar y seguimos las instrucciones.<p>Si queremos utilizar el resaltado de sintaxis basado en treesitter tenemos la opción de crear un autocomando o un "filetype plugin." Luego debemos invocar la función <code>vim.treesitter.start()</code>. Este es un ejemplo que usa un autocomando en los tipos de archivos relacionados con javascript.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.api.</span><span style=color:#7e9cd8>nvim_create_autocmd</span><span>(</span><span style=color:#98bb6c>'FileType'</span><span>, {</span></span>
<span class=giallo-l><span>  pattern</span><span style=color:#e6c384> =</span><span> {</span><span style=color:#98bb6c>'javascript'</span><span>, </span><span style=color:#98bb6c>'javascriptreact'</span><span>, </span><span style=color:#98bb6c>'js'</span><span>, </span><span style=color:#98bb6c>'jsx'</span><span>},</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  callback</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>    vim.treesitter.</span><span style=color:#7e9cd8>start</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>  end</span><span>,</span></span>
<span class=giallo-l><span>})</span></span></code></pre><h3 id=ts-enable-nvim>ts-enable.nvim</h3><p>Github: <a rel="noopener external" href=https://github.com/VonHeikemen/ts-enable.nvim target=_blank>VonHeikemen/ts-enable.nvim</a><p><code>nvim-treesitter</code> requiere de cierta cantidad de conocimiento sobre Neovim. Ciertamente no es nada del otro mundo si estamos dispuestos a instalar los parsers manualmente. Pero la cosa se pone complicada si queremos automatizar todo el proceso. Por eso existe <code>ts-enable.nvim</code>, este plugin implementa el código necesario para habilitar algunas funcionalidades basadas en treesitter y también puede instalar parsers cuando es necesario.<p>La configuración básica puede ser tan simple como esto:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- See :help ts-enable-config</span></span>
<span class=giallo-l><span>vim.g.ts_enable</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>  parsers</span><span style=color:#e6c384> =</span><span> {</span><span style=color:#98bb6c>'lua'</span><span>, </span><span style=color:#98bb6c>'vim'</span><span>, </span><span style=color:#98bb6c>'vimdoc'</span><span>, </span><span style=color:#98bb6c>'c'</span><span>, </span><span style=color:#98bb6c>'query'</span><span>},</span></span>
<span class=giallo-l><span>  auto_install</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>  highlights</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>  indents</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>,</span></span>
<span class=giallo-l><span>  folds</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>,</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>La idea aquí es poder especificar los nombres de los parsers que queremos usar y las funcionalidades que queremos habilitar. <code>ts-enable.nvim</code> se encarga de crear los autocomandos e invocar las funciones necesarias, para que nosotros no tengamos que preocuparnos por los detalles técnicos.<h3 id=snacks-nvim>Snacks.nvim</h3><p>Github: <a rel="noopener external" href=https://github.com/folke/snacks.nvim target=_blank>folke/snacks.nvim</a><p>Snacks.nvim es una colección de módulos escritos en lua, al igual que mini.nvim. Pero en este caso Snacks.nvim tiene un diseño diferente. Por ejemplo, Snacks.nvim tiene un solo punto de entrada que es el módulo <code>snacks</code>, pero en <code>mini.nvim</code> cada módulo tiene su propio punto de entrada. Snacks.nvim es más ambicioso con sus funcionalidades, no intenta ser un plugin "ligero."<p>Para habilitar las funcionalidades en Snacks.nvim usamos la función <code>.setup()</code> del módulo <code>snacks</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local Snacks</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'snacks'</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span style=color:#727169>  ---</span></span>
<span class=giallo-l><span style=color:#727169>  -- Aquí debemos colocar nuestra configuración</span></span>
<span class=giallo-l><span style=color:#727169>  ---</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Además de la función <code>.setup()</code> también podemos acceder a otros módulos a través de <code>snacks</code>.<ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/input.md target=_blank>Snacks.input</a></ul><p><code>Snacks.input</code> es una implementación para la función <code>vim.ui.input()</code>.<p><code>vim.ui.input()</code> es una función que podemos usar en lua, los autores de plugins la usan para pedir información al usuario. Por ejemplo, en un explorador archivos, cuando se intenta renombrar un archivo tiene sentido preguntar el nuevo nombre del archivo.<p>La implementación de <code>Snacks.input</code> muestra una ventana flotante donde podemos ingresar una cadena de texto. A diferencia de la implementación de Neovim donde ingresamos el texto en el área de mensajes.<p>Para habilitar el módulo agregamos esta configuración en la función <code>.setup()</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  input</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    icon</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '❯'</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/picker.md target=_blank>Snacks.picker</a></ul><p><code>Snacks.picker</code> hace tres cosas: 1) ofrece una interfaz para filtrar items de una lista. 2) implementa más de 50 filtros. 3) provee una implementación para la función <code>vim.ui.select()</code>.<p>Este tipo de plugins han ganado popularidad en la comunidad porque podemos usarlos para navegar rápidamente entre varios archivos. Y lo mejor de todo es que la idea de filtrar items es útil en otros escenarios. Por eso es que Snacks.nvim viene con varios tipos de filtros ya implementados. Podemos buscar archivos, proyectos, historial de cambios, atajos de teclado, temas para el editor... y mucho más.<p><code>vim.ui.select()</code> es una función que podemos usar en lua para pedir a un usuario que elija un item entre varias opciones. La implementación de <code>Snacks.picker</code> usa la interfaz interactiva de <code>Snacks</code>.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  picker</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    ui_select</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    prompt</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '❯ '</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Vale la pena mencionar que configurar <code>picker</code> es opcional si no queremos usar la implementación de <code>vim.ui.select()</code>. Todos los filtros en Snacks funcionan incluso si no habilitamos el módulo de manera explícita en la función <code>.setup()</code>.<p>¿Cómo usamos estos filtros? La manera más conveniente sería invocarlos con un atajo de teclado.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/picker.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>&lt;space>'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'buffers'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>ff'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'files'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fh'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'recent'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fg'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'grep'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fd'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'diagnostics'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fs'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'lines'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>u'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'undo'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>/'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'pickers'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>?'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'keymaps'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span></code></pre><ul><li><code>&lt;leader>&lt;space></code>: Muestra la lista de archivos abiertos.<li><code>&lt;leader>ff</code>: Muestra los archivos del directorio de trabajo actual.<li><code>&lt;leader>fh</code>: Muestra el historial de archivos.<li><code>&lt;leader>fg</code>: Ejecuta una búsqueda interactiva en cada línea código de cada archivo en el directorio actual.<li><code>&lt;leader>fd</code>: Muestra la lista de "diagnósticos" del archivo actual. Un diagnóstico puede ser un error de sintaxis, una advertencia o una sugerencia.<li><code>&lt;leader>fs</code>: Ejecuta una búsqueda interactiva en el archivo actual.<li><code>&lt;leader>u</code>: Muestra el historial de cambios.<li><code>&lt;leader>/</code>: Muestra una lista de todos los filtros disponibles en Snacks.<li><code>&lt;leader>?</code>: Muestra una lista de atajos de teclado.</ul><ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/indent.md target=_blank>Snacks.indent</a></ul><p><code>Snacks.indent</code> añade guías de indentación a todas las líneas del archivo.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  indent</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    char</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '▏'</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>Por defecto el bloque de código donde está el cursor tendrá una animación extra. Si queremos desactivarla debemos agregar esta variable global.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>vim.g.snacks_animate</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span></code></pre><ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/bigfile.md target=_blank>Snacks.bigfile</a></ul><p>Este módulo resulta más útil en versiones de Neovim anterior a v0.11.<p>Podemos usar <code>Snacks.bigfile</code> para deshabilitar funcinalidades que hacen que el editor disminuya el tiempo de respuesta o se congele completamente. La mayor parte del tiempo es el resaltado de sintaxis lo que hace al editor lento cuando abrimos archivos grandes. En Neovim v0.11 se ha agregado una funcionalidad de resaltado asíncrono, es por eso que recomiendo este módulo para aquellas personas que utilizan una versión de Neovim más antigua.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  bigfile</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span style=color:#727169>    -- Only use `bigfile` module on older Neovim versions</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span> vim.fn.</span><span style=color:#7e9cd8>has</span><span>(</span><span style=color:#98bb6c>'nvim-0.11'</span><span>) </span><span style=color:#e6c384>==</span><span style=color:#d27e99> 0</span><span>,</span></span>
<span class=giallo-l><span>    notify</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>,</span></span>
<span class=giallo-l><span>    size</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 1024</span><span style=color:#e6c384> *</span><span style=color:#d27e99> 1024</span><span>, </span><span style=color:#727169>-- 1MB</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    setup</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>ctx</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span>      vim.</span><span style=color:#7e9cd8>cmd</span><span>(</span><span style=color:#98bb6c>'syntax clear'</span><span>)</span></span>
<span class=giallo-l><span>      vim.opt_local.syntax</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'OFF'</span></span>
<span class=giallo-l><span>      local buffer</span><span style=color:#e6c384> =</span><span> vim.b[ctx.buf]</span></span>
<span class=giallo-l><span style=color:#957fb8>      if</span><span> buffer.ts_highlight</span><span style=color:#957fb8> then</span></span>
<span class=giallo-l><span>        vim.treesitter.</span><span style=color:#7e9cd8>stop</span><span>(ctx.buf)</span></span>
<span class=giallo-l><span style=color:#957fb8>      end</span></span>
<span class=giallo-l><span style=color:#957fb8>    end</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span></code></pre><p>La idea aquí es que en archivos que superan <code>1MB</code> de tamaño deshabilitamos el resaltado de sintaxis. Noten que en el campo <code>enabled</code> usamos una condición dinámica, esta sólo retorna <code>true</code> si nuestra versión de Neovim es menor a v0.11.<ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/bufdelete.md target=_blank>Snacks.bufdelete</a></ul><p>Nos permiten cerrar archivos sin modificar las ventanas abiertas. Por ejemplo, si tienen 2 ventanas abiertas e intentan cerrar un archivo usando el comando <code>bdelete</code> Neovim cerrará el archivo y la ventana. Con la función <code>Snacks.bufdelete()</code> podemos cerrar el archivo y dejar la ventana abierta.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/bufdelete.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>bc'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.</span><span style=color:#7e9cd8>bufdelete</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span></code></pre><ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/terminal.md target=_blank>Snacks.terminal</a></ul><p>La buena noticia es que Neovim tiene una terminal integrada, en teoría no necesitamos ningún plugin para usarla. La mala noticia es que no es "componente" que uno puede ocultar fácilmente, es más como un buffer especial.<p><code>Snacks.terminal</code> provee funciones que nos permite manejar ventanas con buffers de terminal. La funcionalidad más sencilla que podemos usar es abrir y cerrar una ventana con una terminal.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/terminal.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'t'</span><span>}, </span><span style=color:#98bb6c>'&lt;C-g>'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.terminal.</span><span style=color:#7e9cd8>toggle</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span></code></pre><ul><li><a rel="noopener external" href=https://github.com/folke/snacks.nvim/blob/main/docs/explorer.md target=_blank>Snacks.explorer</a></ul><p><code>Snacks.explorer</code> es un explorador de archivos. Puede mostrar los archivos en una estructura de árbol como en otros editores. Lo curioso de este explorador es que técnicamente es "filtro" de <code>Snacks.picker</code>, en la documentación podrán ver que algunas opciones van en el campo <code>picker</code> de la función <code>.setup()</code>.<p>Para empezar a usarlo agregamos esta configuración en la función <code>.setup()</code>. Y para hacerlo más conveniente podemos crear un atajo de teclado que muestre el explorador.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  explorer</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    replace_netrw</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>e'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.</span><span style=color:#7e9cd8>explorer</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span></code></pre><p>Ahora si colocamos todo el código relacionado con Snacks.nvim tendremos algo así:<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local Snacks</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'snacks'</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Snacks.</span><span style=color:#7e9cd8>setup</span><span>({</span></span>
<span class=giallo-l><span>  indent</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    char</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '▏'</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  explorer</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    replace_netrw</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  input</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    icon</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '❯'</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  picker</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    ui_select</span><span style=color:#e6c384> =</span><span style=color:#ffa066> true</span><span>,</span></span>
<span class=giallo-l><span>    prompt</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> '❯ '</span><span>,</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>  bigfile</span><span style=color:#e6c384> =</span><span> {</span></span>
<span class=giallo-l><span style=color:#727169>    -- Only use `bigfile` module on older Neovim versions</span></span>
<span class=giallo-l><span>    enabled</span><span style=color:#e6c384> =</span><span> vim.fn.</span><span style=color:#7e9cd8>has</span><span>(</span><span style=color:#98bb6c>'nvim-0.11'</span><span>) </span><span style=color:#e6c384>==</span><span style=color:#d27e99> 0</span><span>,</span></span>
<span class=giallo-l><span>    notify</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span><span>,</span></span>
<span class=giallo-l><span>    size</span><span style=color:#e6c384> =</span><span style=color:#d27e99> 1024</span><span style=color:#e6c384> *</span><span style=color:#d27e99> 1024</span><span>, </span><span style=color:#727169>-- 1MB</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    setup</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>(</span><span>ctx</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span>      vim.</span><span style=color:#7e9cd8>cmd</span><span>(</span><span style=color:#98bb6c>'syntax clear'</span><span>)</span></span>
<span class=giallo-l><span>      vim.opt_local.syntax</span><span style=color:#e6c384> =</span><span style=color:#98bb6c> 'OFF'</span></span>
<span class=giallo-l><span>      local buffer</span><span style=color:#e6c384> =</span><span> vim.b[ctx.buf]</span></span>
<span class=giallo-l><span style=color:#957fb8>      if</span><span> buffer.ts_highlight</span><span style=color:#957fb8> then</span></span>
<span class=giallo-l><span>        vim.treesitter.</span><span style=color:#7e9cd8>stop</span><span>(ctx.buf)</span></span>
<span class=giallo-l><span style=color:#957fb8>      end</span></span>
<span class=giallo-l><span style=color:#957fb8>    end</span></span>
<span class=giallo-l><span>  },</span></span>
<span class=giallo-l><span>})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>-- Disable indent guide animation</span></span>
<span class=giallo-l><span>vim.g.snacks_animate</span><span style=color:#e6c384> =</span><span style=color:#ffa066> false</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/explorer.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>e'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.</span><span style=color:#7e9cd8>explorer</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/terminal.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>({</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'t'</span><span>}, </span><span style=color:#98bb6c>'&lt;C-g>'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.terminal.</span><span style=color:#7e9cd8>toggle</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>-- Close while preserving window layout</span></span>
<span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/bufdelete.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>bc'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span></span>
<span class=giallo-l><span>  Snacks.</span><span style=color:#7e9cd8>bufdelete</span><span>()</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#727169>-- Fuzzy finders</span></span>
<span class=giallo-l><span style=color:#727169>-- docs: https://github.com/folke/snacks.nvim/blob/main/docs/picker.md</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>&lt;space>'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'buffers'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>ff'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'files'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fh'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'recent'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fg'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'grep'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fd'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'diagnostics'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>fs'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'lines'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>u'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'undo'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>/'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'pickers'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span>
<span class=giallo-l><span>vim.keymap.</span><span style=color:#7e9cd8>set</span><span>(</span><span style=color:#98bb6c>'n'</span><span>, </span><span style=color:#98bb6c>'&lt;leader>?'</span><span>, </span><span style=color:#957fb8>function</span><span style=color:#9cabca>()</span><span> Snacks.</span><span style=color:#7e9cd8>picker</span><span>(</span><span style=color:#98bb6c>'keymaps'</span><span>) </span><span style=color:#957fb8>end</span><span>, {})</span></span></code></pre><h2 id=que-sigue>¿Qué sigue?</h2><p>El siguiente paso sería lograr que Neovim entienda el código de nuestro proyecto: que autocomplete variables, nos permita saltar a la definición de una función, que pueda renombrar una variable, cosas así. Para esto recomiendo el plugin <a rel="noopener external" href=https://github.com/neovim/nvim-lspconfig target=_blank>nvim-lspconfig</a>. Como hay muchos detalles que necesitan explicación les recomiendo leer este post:<ul><li><a rel="noopener external" href=https://dev.to/vonheikemen/getting-started-with-neovims-native-lsp-client-in-the-year-of-2022-the-easy-way-bp3 target=_blank>Getting started with neovim's native LSP client</a></ul><hr><p>¿Tienen alguna pregunta? Pueden dejar un comentario en cualquiera de estas plataformas:<ul><li><a href=https://dev.to/vonheikemen/neovim-plugins-para-empezar-c39 rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/neovim-plugins-to-get-started-es rel=noopener target=_blank>Hashnode</a></ul><p>Pueden contactarme por las redes sociales:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Gracias por su tiempo. Si este artículo les pareció útil y quieren apoyar mis esfuerzos para crear más contenido, pueden dejar una propina en buy me a coffee ☕.</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>