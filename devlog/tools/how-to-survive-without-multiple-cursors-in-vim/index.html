<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  How to survive without multiple cursors in vim | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://vonheikemen.github.io/devlog/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, neovim, shell, software, coding, development" name=keywords><meta content="Alternatives we can use in vim instead of multiple cursors" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2026 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>How to survive without multiple cursors in vim</h1><span class=post-date>2023-01-15 | 11 min read | <a href=https://vonheikemen.github.io/devlog/es/tools/how-to-survive-without-multiple-cursors-in-vim/> Leer en español </a> </span><p>Yes, multiple cursors are magical. They are convenient, easy to use and every modern editor has them. Now vim on the other hand doesn't have this feature. It's fine. We can be happy without them. Well... I can and I'm going to tell you how.<p>We'll go throught a few scenarios where multiple cursors can be useful and I'll tell you what alternatives we have in vim.<h2 id=replace-word-under-the-cursor>Replace word under the cursor</h2><p>In vim we begin this process by searching the word under the cursor, for this we press the <code>*</code> key. Then we press the sequence <code>cgn</code> to replace the next match. If we want to repeat this action we press the <code>.</code> key. If we want to ignore a match we move to the next with <code>n</code>.<p>We can make this process a lot more convenient by making a keybinding.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>nnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>leader</span><span style=color:#9cabca>></span><span>j *``cgn</span></span></code></pre><p>With this we can use the leader key + j to replace the word under the cursor. We can navigate to other matches with <code>n</code> or <code>N</code>, then use the <code>.</code> key when we want to replace the text.<p><script async data-preload=false data-size=small id=asciicast-qxb6feyI4ieLUlFUwO2kXzV4I src=https://asciinema.org/a/qxb6feyI4ieLUlFUwO2kXzV4I.js></script><blockquote><p>See in <a rel="noopener external" href=https://asciinema.org/a/540516 target=_blank>asciinema</a>.</blockquote><h2 id=rename-a-variable>Rename a variable</h2><p>Maybe the thing we want to change is a variable in our code, in this case we only need to change the valid references. Things get complicated here. Since vim isn't an IDE this kind of features are not available out of the box. But it doesn't mean is impossible, we can still do it, there are plugins that allow us to use LSP servers. It just so happens that rename variables is one the things an LSP server can do.<p>I use neovim btw, not vim. I just need something like this in my config.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>lua </span><span style=color:#7e9cd8>require</span><span style=color:#9cabca>(</span><span style=color:#98bb6c>'lspconfig'</span><span style=color:#9cabca>)</span><span style=color:#7e9cd8>.tsserver.setup</span><span style=color:#9cabca>(</span><span>{}</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#957fb8>nnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>F2</span><span style=color:#9cabca>> &lt;</span><span>cmd</span><span style=color:#9cabca>></span><span>lua </span><span style=color:#7e9cd8>vim.lsp.buf.rename</span><span style=color:#9cabca>()&lt;</span><span style=color:#ffa066>cr</span><span style=color:#9cabca>></span></span></code></pre><p>Here I'm using <a rel="noopener external" href=https://github.com/neovim/nvim-lspconfig target=_blank>nvim-lspconfig</a> to configure <a rel="noopener external" href=https://github.com/theia-ide/typescript-language-server target=_blank>tsserver</a>. Then I create the keybinding <code>&lt;F2></code> to rename the variable under the cursor.<p><script async data-preload=false data-size=small id=asciicast-217Yk9e9HtmuPi0t8HsNPHOAN src=https://asciinema.org/a/217Yk9e9HtmuPi0t8HsNPHOAN.js></script><blockquote><p>See in <a rel="noopener external" href=https://asciinema.org/a/540539 target=_blank>asciinema</a>.</blockquote><p>If you use vim you can try out one these plugins:<ul><li><a rel="noopener external" href=https://github.com/prabirshrestha/vim-lsp target=_blank>vim-lsp</a><li><a rel="noopener external" href=https://github.com/neoclide/coc.nvim target=_blank>coc.nvim</a></ul><h2 id=replace-a-selection>Replace a selection</h2><p>So maybe the thing we want to change is not a word, maybe is a sentence or an html attribute. For this we don't have a built-in tool, we need to implement something ourselves. So let's do that.<p>First thing we should do is add the current selection to the "search register".<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>let @</span><span style=color:#c0a36e>/=escape(@", '/</span><span style=color:#98bb6c>')</span></span></code></pre><p>Here we take the text inside the <code>"</code> register, where our selection is stored, and put it in the <code>/</code> register.<p>The next step would be to delete the selection and enter insert mode. We use this sequence.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>"_cgn</span></span></code></pre><p>With <code>"_</code> we tell vim that our next operation should store text in the <code>_</code> register. With <code>cgn</code> we replace the closest match to our search.<p>If we put the pieces together in a keybinding, we get this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>xnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>leader</span><span style=color:#9cabca>></span><span>j y</span><span style=color:#9cabca>&lt;</span><span>cmd</span><span style=color:#9cabca>></span><span>let @</span><span style=color:#c0a36e>/=escape(@", '/</span><span style=color:#98bb6c>')&lt;cr>"_cgn</span></span></code></pre><p>But this command doesn't handle newlines. It won't work with selection with multiple lines. But we can handle that.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>xnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>leader</span><span style=color:#9cabca>></span><span>j y</span><span style=color:#9cabca>&lt;</span><span>cmd</span><span style=color:#9cabca>></span><span style=color:#7e9cd8>substitute</span><span style=color:#9cabca>(</span><span style=color:#7e9cd8>escape</span><span style=color:#9cabca>(</span><span>@</span><span style=color:#98bb6c>", '/'), '\n', '\\n', 'g')&lt;cr>"</span><span>_cgn</span></span></code></pre><p>Now here we use the <code>substitute</code> function to replace the newline character with <code>\n</code>, this way our search term will always be one line.<p>How do we use this? Same way we did with the previous keybinding <code>&lt;leader>j</code> in the section "Replace word under the cursor". But here we must first enter visual mode and select something. Everything else works the same, if we want to replace we use the <code>.</code> key, then we move to the next match with <code>n</code>.<h2 id=add-text-to-the-beginning-of-a-list>Add text to the beginning of a list</h2><p>Let's say we have a list of words and we want to convert them to an ordered list in markdown.<p>Want to turn this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>volar</span></span>
<span class=giallo-l><span>html</span></span>
<span class=giallo-l><span>cssls</span></span></code></pre><p>Into this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>1. volar</span></span>
<span class=giallo-l><span>1. html</span></span>
<span class=giallo-l><span>1. cssls</span></span></code></pre><p>In vim we have a mode called Visual Block, when in this mode we can add text to each line selected if we go to insert mode using <code>I</code> or <code>A</code>. After you added the text and exit insert mode vim will repeat the action on every line.<p>Let's go step by step how to use this feature.<p><script async data-preload=false data-size=small id=asciicast-tjCikrHM5d1QsoSk00u9iUQMa src=https://asciinema.org/a/tjCikrHM5d1QsoSk00u9iUQMa.js></script><blockquote><p>See in <a rel="noopener external" href=https://asciinema.org/a/539909 target=_blank>asciinema</a>.</blockquote><ol><li>We go to the first character in the line.<li>Press <code>Ctrl + v</code> to enter visual block mode.<li>Select the lines we want to change.<li>Press <code>I</code> to place the cursor at the beginning of the selection.<li>Add the text.<li>Press <code>Esc</code>.</ol><h2 id=append-to-the-end-of-a-list>Append to the end of a list</h2><p>We can do that too. The steps are almost identical to the previous section, the only difference is we need to extend the selection until the end of the line.<p>Let's add something to the previous example.<p>Okay, we have our ordered list but now we want to append <code>(is supported)</code> to the end of each item.<p><script async data-preload=false data-size=small id=asciicast-eF1Pdf34IY4Sj5PixzjCqPIxz src=https://asciinema.org/a/eF1Pdf34IY4Sj5PixzjCqPIxz.js></script><blockquote><p>See in <a rel="noopener external" href=https://asciinema.org/a/539912 target=_blank>asciinema</a>.</blockquote><ol><li>We go to the first character in the line.<li>Press <code>Ctrl + v</code> to enter visual block mode.<li>Select the lines we want to change.<li>Expand the selection to the end of the line using <code>$</code>.<li>Press <code>A</code> to place the cursor at the end of the selection.<li>Add the text.<li>Press <code>Esc</code>.</ol><h2 id=repeat-movements>Repeat movements</h2><p>Visual block mode can be useful but is very limited. We can only add text in one place. What do we do in more complex scenarios? We use macros. A macro is a piece of text that describes a sequence of keypresses. We can "record" a macro and repeat the sequence as many times as we want.<p>How do we use macros? We need to pick a register so the first step is to press <code>q</code> followed by a letter. Then we go and do whatever actions we want. We stop recording the macro by pressing <code>q</code> again. To repeat these actions we press <code>@</code> followed by the register we chose in the first step.<p>Example time.<p>We have this list.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>volar</span></span>
<span class=giallo-l><span>html</span></span>
<span class=giallo-l><span>cssls</span></span>
<span class=giallo-l><span>eslint</span></span></code></pre><p>And we want to turn it into an ordered list of links.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>1. [volar](http://localhost/how-to-configure-volar-lsp)</span></span>
<span class=giallo-l><span>1. [html](http://localhost/how-to-configure-html-lsp)</span></span>
<span class=giallo-l><span>1. [cssls](http://localhost/how-to-configure-cssls-lsp)</span></span>
<span class=giallo-l><span>1. [eslint](http://localhost/how-to-configure-eslint-lsp)</span></span></code></pre><p>Notice here we need to add text to the beginning and the end of the list. Additionally, we need to copy the item in the middle of the link.<p>What do we do? We record a macro, modify the first item then repeat the macro to convert the rest of the list. These are the steps.<ol><li>Record the macro in the register <code>i</code>. Press <code>qi</code>.<li>Modify the first item.<li>We stop recording the macro by pressing <code>q</code> again.<li>We repeat the macro three times using <code>3@i</code>.</ol><p><script async data-preload=false data-size=small id=asciicast-85qQ7TtkOclesgMJNBDcKk5BK src=https://asciinema.org/a/85qQ7TtkOclesgMJNBDcKk5BK.js></script><blockquote><p>See in <a rel="noopener external" href=https://asciinema.org/a/540581 target=_blank>asciinema</a>.</blockquote><p>When we apply a macro using a count we need to consider the position of the cursor. In this particular case I begin the macro by pressing <code>0</code>, to make sure the cursor is at the beginning of the line. Then at the very end of the macro I press <code>j</code>, so the last movement can place the cursor in the next line.<h3 id=apply-macro-in-specific-lines>Apply macro in specific lines</h3><p>Another interesting way to apply a macro is by using the <code>g</code> command. With it we can begin a search and then execute a command in each line there is a match. In our case we want to apply a macro, we can do that with the command <code>normal @i</code> (where <code>i</code> can be any register).<p>Say we want to look for every line with the word <code>vim</code> then apply a macro. We do this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:g</span><span style=color:#c0a36e>/vim/</span><span style=color:#957fb8>normal</span><span> @i</span></span></code></pre><p>Now, you might want to inspect the result of the search before doing anything you'll regret. If you omit the last section with the command then <code>:g</code> will just print the lines.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>:g</span><span style=color:#c0a36e>/vim/</span></span></code></pre><p>If everything looks okay then add the <code>normal @i</code> bit.<h3 id=apply-a-macro-in-a-selection>Apply a macro in a selection</h3><p>We don't have to use the <code>g</code> command. The <code>normal</code> commands supports ranges, this means we can select any amount of lines then execute this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#98bb6c>'&lt;,'</span><span>></span><span style=color:#957fb8>normal</span><span> @i</span></span></code></pre><blockquote><p>Note: Don't worry about writing <code>'&lt;,'></code>, vim will add that for you when you go from visual mode to command mode.</blockquote><p>That command will execute the macro in each line of the selection. Keep in mind the cursor will be placed at the beginning of the line automatically.<h3 id=search-selection-and-apply-macro>Search selection and apply macro</h3><p>Yet another alternative to the <code>g</code> command. Because maybe we don't want to make a regular expresion to search. Most of the time I just want to select something, search it, then apply a macro. We already know how to do all those things, let's just put the pieces together.<p>Remember this guy?<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>y</span><span style=color:#9cabca>&lt;</span><span>cmd</span><span style=color:#9cabca>></span><span>let @</span><span style=color:#c0a36e>/=substitute(escape(@", '/</span><span style=color:#98bb6c>'), '</span><span style=color:#e6c384>\</span><span>n</span><span style=color:#98bb6c>', '</span><span style=color:#e6c384>\\</span><span>n</span><span style=color:#98bb6c>', '</span><span>g</span><span style=color:#98bb6c>')&lt;cr></span></span></code></pre><p>Is the thing we use to search the current selection. After this sequence we need to begin the macro. So we will add this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>gvqi</span></span></code></pre><p>Since we lose the selection when pressing <code>y</code> we need to reselect everything, so we use <code>gv</code>. Then <code>qi</code> just begins to record the macro in the register <code>i</code>.<p>Now everything together.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>xnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>leader</span><span style=color:#9cabca>></span><span>i y</span><span style=color:#9cabca>&lt;</span><span>cmd</span><span style=color:#9cabca>></span><span>let @</span><span style=color:#c0a36e>/=substitute(escape(@", '/</span><span style=color:#98bb6c>'), '</span><span style=color:#e6c384>\</span><span>n</span><span style=color:#98bb6c>', '</span><span style=color:#e6c384>\\</span><span>n</span><span style=color:#98bb6c>', '</span><span>g</span><span style=color:#98bb6c>')&lt;cr>gvqi</span></span></code></pre><p>The story is not over yet. We need to apply the macro in each match. We will use <code>gn</code> to navigate to the match and select it. Once the cursor is in the match we apply the macro with <code>@i</code>. We are not doing that manually, no, we are going to create a keybinding.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>nnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>F8</span><span style=color:#9cabca>></span><span> gn@i</span></span></code></pre><p>Story time.<p>A few months ago I was trying this plugin manager, <a rel="noopener external" href=https://github.com/wbthomason/packer.nvim target=_blank>packer.nvim</a>. I had something like this in my configuration.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span style=color:#7e9cd8>require</span><span>(</span><span style=color:#98bb6c>'packer'</span><span>).</span><span style=color:#7e9cd8>startup</span><span>(</span><span style=color:#957fb8>function</span><span style=color:#9cabca>(</span><span>use</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  use</span><span>({</span></span>
<span class=giallo-l><span style=color:#98bb6c>    'nvim-lualine/lualine.nvim'</span><span>,</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    config</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>()</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'plugins.lualine'</span><span>) </span><span style=color:#957fb8>end</span><span>,</span></span>
<span class=giallo-l><span>  })</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  use</span><span>({</span></span>
<span class=giallo-l><span style=color:#98bb6c>    'akinsho/bufferline.nvim'</span><span>,</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    config</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>()</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'plugins.bufferline'</span><span>) </span><span style=color:#957fb8>end</span><span>,</span></span>
<span class=giallo-l><span>  })</span></span>
<span class=giallo-l><span style=color:#7e9cd8>  use</span><span>({</span></span>
<span class=giallo-l><span style=color:#98bb6c>    'lukas-reineke/indent-blankline.nvim'</span><span>,</span></span>
<span class=giallo-l><span style=color:#7e9cd8>    config</span><span style=color:#e6c384> =</span><span style=color:#957fb8> function</span><span style=color:#9cabca>()</span><span style=color:#7e9cd8> require</span><span>(</span><span style=color:#98bb6c>'plugins.indent-blankline'</span><span>) </span><span style=color:#957fb8>end</span><span>,</span></span>
<span class=giallo-l><span>  })</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span><span>)</span></span></code></pre><p>It bothered me that I had to repeat <code>function() require...</code> for each plugin. And yes, it's packer thing. They do weird stuff with functions. Anyway, I looked around in a few places and found a way to reduce the boilerplate. I wrote this function.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>local</span><span style=color:#957fb8> function</span><span style=color:#7e9cd8> load</span><span style=color:#9cabca>(</span><span>name</span><span style=color:#9cabca>)</span></span>
<span class=giallo-l><span style=color:#957fb8>  return</span><span style=color:#7e9cd8> string.format</span><span>(</span><span style=color:#98bb6c>[[pcall(require, 'plugins.%s')]]</span><span>, name)</span></span>
<span class=giallo-l><span style=color:#957fb8>end</span></span></code></pre><p>And with it I could write the <code>config</code> option like this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=lua><span class=giallo-l><span>config</span><span style=color:#e6c384> =</span><span style=color:#7e9cd8> load</span><span>(</span><span style=color:#98bb6c>'lualine'</span><span>)</span></span></code></pre><p>Now it's refactor time. I had to change each <code>config</code> option and this is how I did it.<p><script async data-preload=false data-size=small id=asciicast-OUlPjhimpPKIDxEqPJgoxHcYt src=https://asciinema.org/a/OUlPjhimpPKIDxEqPJgoxHcYt.js></script><blockquote><p>Ver en <a rel="noopener external" href=https://asciinema.org/a/OUlPjhimpPKIDxEqPJgoxHcYt target=_blank>asciinema</a>.</blockquote><ol><li>I select the pattern I want to search. Go to visual mode and select <code>config = </code>.<li>I start recording the macro using <code>&lt;leader>i</code>.<li>I replace the old function with <code>load</code>.<li>End the macro by pressing <code>q</code>.<li>Press <code>n</code> to go to the next match.<li>Press <code>&lt;F8></code> to apply the macro.</ol><h2 id=the-good-old-search-and-replace>The Good Old Search and Replace</h2><p>Sometimes a simple tool can do the job.<p>So vim has the <code>substitute</code> command. This is the syntax.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>%s</span><span style=color:#c0a36e>/&lt;pattern>/</span><span style=color:#9cabca>&lt;</span><span>replacement</span><span style=color:#9cabca>></span><span>/g</span></span></code></pre><p>In here <code>%</code> is a range, it means the current buffer. Basically, search the entire buffer. The <code>s</code> is the actual command, 'cause we don't need to type <code>substitute</code>. <code>&lt;pattern></code> is the regular expression we want to search. <code>&lt;replacement></code> is the new text. And <code>g</code> is a flag, it tells vim to search the entire line. And notice that each item is separated by <code>/</code>, we could use other characters (like <code>#</code>) if we wanted to.<p>Say want to change the word <code>config</code> with <code>setup</code>. We just do this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span>%s</span><span style=color:#c0a36e>/config/</span><span>setup/g</span></span></code></pre><p>It wasn't that difficult. We don't need to know regular expressions to use <code>substitute</code>.<h3 id=fighting-kirby>Fighting Kirby</h3><p>Okay. But there is something you should learn about regular expressions. Is just one simple trick, I swear.<p>What's this fighting Kirby deal? Is a way to remember this.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>\(.*\)</span></span></code></pre><blockquote><p>I learned this from <a rel="noopener external" href=https://github.com/ThePrimeagen target=_blank>ThePrimeagen</a>.</blockquote><p>With this pattern we can create a "group". Groups can capture the text in the search pattern, and we can reuse that text in the replacement pattern.<p>Consider this pattern.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=plain><span class=giallo-l><span>%s/`\(.*\)`/[\1](#how-to-configure-\1-lsp)</span></span></code></pre><p>Here we capture the text that's surrounded by backticks. Then we reference that text using <code>\1</code> and the replacement pattern. Here's a demo.<p><script async data-preload=false data-size=small id=asciicast-odouPFLqH5SSHkJuSVhp28yjR src=https://asciinema.org/a/odouPFLqH5SSHkJuSVhp28yjR.js></script><blockquote><p>Ver en <a rel="noopener external" href=https://asciinema.org/a/542501 target=_blank>asciinema</a>.</blockquote><p>This demo shows how neovim makes a live preview, showing me the effects of the command in realtime. And yes, because of this feature I think search and replace is a decent alternative to multiple cursors.<p>If you liked the fighting Kirby consider making a keybinding for it.<pre class=giallo style=color:#dcd7ba;background-color:#1f1f28><code data-lang=viml><span class=giallo-l><span style=color:#957fb8>cnoremap</span><span style=color:#9cabca> &lt;</span><span style=color:#ffa066>F2</span><span style=color:#9cabca>></span><span style=color:#e6c384> \</span><span style=color:#9cabca>(</span><span>.*</span><span style=color:#e6c384>\</span><span style=color:#9cabca>)</span></span></code></pre><p>This way you can press <code>&lt;F2></code> in command mode and it'll type it for you.<h2 id=conclusion>Conclusion</h2><p>You are ready. You can go out to the world and be productive in vim. I can't guarantee your happiness but you will survive. And its okay if you think multiple cursors are superior to all of this. Doesn't matter, now you can live without them when using vim.<hr><p>If you have a question you can reach out to me on social media:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>