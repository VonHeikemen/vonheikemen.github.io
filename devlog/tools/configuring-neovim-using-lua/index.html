<!doctype html><html lang=en><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Everything you need to know to configure neovim using lua | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="vim,neovim,shell,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Your first steps into a lua configuration"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a></ul>© 2020-2021 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Everything you need to know to configure neovim using lua</h1><span class=post-date>2021-08-01
| 19 min read
| <a href=https://vonheikemen.github.io/devlog/es/tools/configuring-neovim-using-lua/>Leer en español</a></span><p>After a long time in development neovim 0.5 was finally released as a stable version. Among the new exciting features we have better lua support and the promise of a stable api to create our configuration using this language. So today I'm going to share with you everything I learned while I was migrating my own configuration from vimscript to lua.<p>I'm going to talk about the things we can do with lua and its interaction with vimscript. I will be showing a lot of examples but I will not tell you what options you should set with what value. Also, this won't be a tutorial on "how to turn neovim into an IDE", I'll avoid anything that is language specific. What I want to do is teach you enough about lua and the neovim api so you can migrate your own configuration.<p>I will assume your operating system is linux (or something close to it) and that your configuration is located at <code>~/.config/nvim/init.vim</code>. Everything that I will show should work on every system in which neovim can be installed, just keep in mind that the path to the <code>init.vim</code> file might be different in your case.<p>Let us begin.<h2 id=first-steps>First steps</h2><p>The first thing you need to know is that we can embed lua code directly in <code>init.vim</code>. So we can migrate our config piece by piece and only change from <code>init.vim</code> to <code>init.lua</code> when we are ready.<p>Let's do the "hello world" to test that everything works as expected. Try this in your <code>init.vim</code>.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>lua</span><span> &lt;&lt;EOF
</span><span style=color:#69c>print</span><span>(</span><span style=color:#99c794>&#39;hello from lua&#39;</span><span>)
</span><span>EOF
</span></code></pre><p>After "sourcing" the file or restarting neovim the message <code>hello from lua</code> should appear right below your statusline. In here we are using something called <code>lua-heredoc</code>, so everything that's between <code>&lt;&lt;EOF ... EOF</code> will be considered a lua script and will be executed by the <code>lua</code> command. This is useful when we want to execute multiple lines of code but it's not necessary when we only need one. This is valid.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>lua print</span><span>(</span><span style=color:#99c794>&#39;this also works&#39;</span><span>)
</span></code></pre><p>But if we are going to call lua code from vimscript I say we use a real script. In lua we can do this by using the <code>require</code> function. For this to work we need to create a <code>lua</code> folder somewhere in the <code>runtimepath</code> of neovim.<p>You'll probably want to use the same folder where <code>init.vim</code> is located, so we will create <code>~/.config/nvim/lua</code>, and inside that we'll create a script called <code>basic.lua</code>. For now we will only print a message.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>hello from ~/config/nvim/lua/basic.lua</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Now from our <code>init.vim</code> we can call it like this.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>lua require</span><span>(</span><span style=color:#99c794>&#39;basic&#39;</span><span>)
</span></code></pre><p>When we do this neovim will search in every directory in the <code>runtimepath</code> for a folder called <code>lua</code> and inside that it'll look for <code>basic.lua</code>. Neovim will run the last script that meets those conditions.<p>If you go around and check other people's code you'll notice that they use a <code>.</code> as a path separator. For example, let's say they have the file <code>~/.config/nvim/lua/usermod/settings.lua</code>. If they want to call <code>settings.lua</code> they do this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>require</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>usermod.settings</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Is a very common convention. Just remember that the dot is a path separator.<p>With all this knowledge we are ready to begin our configuration using lua.<h2 id=editor-settings>Editor settings</h2><p>Each option in neovim is available to us in the global variable called <code>vim</code>... well more than just a variable try think of this as a global module. With <code>vim</code> we have access to the editor's settings, we also have the neovim api and even a set of helper functions (a standard library if you will). For now, we only need to care about something they call "meta-accessors", is what we'll use to access all the options we need.<h3 id=scopes>Scopes</h3><p>Just like in vimscript, in lua we have different scopes for each option. We have global settings, window settings, buffer settings and a few others. Each one has its own namespace inside the <code>vim</code> module.<ul><li>vim.o</ul><p>Gets or sets general settings.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>o</span><span style=color:#5fb3b3>.</span><span>background </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>light</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.wo</ul><p>Gets or sets window-scoped options.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>wo</span><span style=color:#5fb3b3>.</span><span>colorcolumn </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>80</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.bo</ul><p>Gets or sets buffer-scoped options.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>bo</span><span style=color:#5fb3b3>.</span><span>filetype </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>lua</span><span style=color:#5fb3b3>&#39;
</span></code></pre><ul><li>vim.g</ul><p>Gets or sets global variables. This is usually the namespace where you'll find variables set by plugins. The only one I know isn't tied to a plugin is the leader key.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#5f6364>-- use space as a the leader key
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>mapleader </span><span style=color:#5fb3b3>= &#39; &#39;
</span></code></pre><p>You should know that some variable names in vimscript are not valid in lua. We still have access to them but we can't use the dot notation. For example, <a rel=noopener target=_blank href=https://github.com/dhruvasagar/vim-zoom>vim-zoom</a> has a variable called <code>zoom#statustext</code> and in vimscript we use it like this.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>g:zoom#statustext = </span><span style=color:#99c794>&#39;Z&#39;
</span></code></pre><p>In lua we would have to do this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>zoom#statustext</span><span style=color:#5fb3b3>&#39;] = &#39;</span><span style=color:#99c794>Z</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>As you might have guessed this also gives us an oportunity to access properties which have the name of keywords. You may find yourselves in a situation where you need to access a property called <code>for</code>, <code>do</code> or <code>end</code> which are reserved keywords, in those cases remember this bracket syntax.<ul><li>vim.env</ul><p>Gets or sets environment variables.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>env</span><span style=color:#5fb3b3>.</span><span>FZF_DEFAULT_OPTS </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>--layout=reverse</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>As far as I know if you make a change in an environment variables the change will only apply in the active neovim session.<p>But now how do we know which "scope" we need to use when we're writting our config? Don't worry about that, think of <code>vim.o</code> and company just as a way to read values. When it's time set values we can use another method.<h3 id=vim-opt>vim.opt</h3><p>With <code>vim.opt</code> we can set global, window and buffer settings.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#5f6364>-- buffer-scoped
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>autoindent </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>
</span><span style=color:#5f6364>-- window-scoped
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>
</span><span style=color:#5f6364>-- global scope
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>autowrite </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><p>When we use it like this <code>vim.opt</code> acts like the <code>:set</code> command in vimscript, it give us a consistent way to modify neovim's options.<p>A funny thing you can do is assign <code>vim.opt</code> to a variable called <code>set</code>.<p>Say we have this piece of vimscript.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#5f6364>&quot; Set the behavior of tab
</span><span style=color:#69c>set</span><span> tabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span> shiftwidth=</span><span style=color:#f99157>2
</span><span style=color:#69c>set</span><span> softtabstop=</span><span style=color:#f99157>2
</span><span style=color:#69c>set expandtab
</span></code></pre><p>We could translate this easily in lua like this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>set </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt
</span><span>
</span><span style=color:#5f6364>-- Set the behavior of tab
</span><span>set</span><span style=color:#5fb3b3>.</span><span>tabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>shiftwidth </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>softtabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span><span>set</span><span style=color:#5fb3b3>.</span><span>expandtab </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><blockquote><p>When you declare a variable do not forget the <code>local</code> keyword. In lua variables are global by default (that includes functions).</blockquote><p>Anyway, what about global variables or the environment variables? For those you should keep using <code>vim.g</code> and <code>vim.env</code> respectively<p>What's interesting about <code>vim.opt</code> is that each property is a kind of special object, they are "meta-tables". It means that these objects implement their own behavior for certain common operations.<p>In the first example we had something like this: <code>vim.opt.autoindent = true</code>, and now you might think you can inspect the current value by doing this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>)
</span></code></pre><p>You won't get the value you expect, <code>print</code> will tell you <code>vim.opt.autoindent</code> is a table. If you want to know the value of an option you'll need to use the <code>:get()</code> method.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>:</span><span style=color:#69c>get</span><span style=color:#5fb3b3>())
</span></code></pre><p>If you really, really want to know what's inside <code>vim.out.autoindent</code> you need to use <code>vim.inspect</code>.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>print</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>inspect</span><span style=color:#5fb3b3>(</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>autoindent</span><span style=color:#5fb3b3>))
</span></code></pre><p>Now that will show you the internal state of this property.<h3 id=types-of-data>Types of data</h3><p>Even when we assign a value inside <code>vim.opt</code> there is a little bit of magic going on in the background. I think is important to know how <code>vim.opt</code> can handle different types of data and compare it with vimscript.<ul><li>Booleans</ul><p>These might not seem like a big deal but there is still a difference that is worth mention.<p>In vimscript we can activate or deactivate an option like this.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> cursorline
</span><span style=color:#69c>set</span><span> nocursorline
</span></code></pre><p>This is the equivalent in lua.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>cursorline </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false
</span></code></pre><ul><li>Lists</ul><p>For some options neovim expects a comma separated list. In this case we could provide it as a string ourselves.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>wildignore </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>*/cache/*,*/tmp/*</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Or we could use a table.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>wildignore </span><span style=color:#5fb3b3>= {&#39;</span><span style=color:#99c794>*/cache/*</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>*/tmp/*</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>If you check the content of <code>vim.o.wildignore</code> you'll notice is the thing we want <code>*/cache/*,*/tmp/*</code>. If you really want to be sure you can check with this command.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>:</span><span style=color:#69c>set</span><span> wildignore?
</span></code></pre><p>You'll get the same result.<p>But the magic does not end there. Sometimes we don't need to override the list, sometimes we need to add an item or maybe delete it. To makes things easier <code>vim.opt</code> offers support for the following operations:<p><strong>Add an item to the end of the list</strong><p>Let's take <code>errorformat</code> as an example. If we want to add to this list using vimscript we do this.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat+=%f\|%l\ col\ %c\|%m
</span></code></pre><p>In lua we have a couple of ways to achieve the same goal:<p>Using the <code>+</code> operator.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>Or the <code>:append</code> method.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>append</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p><strong>Add to the beginning</strong><p>In vimscript:<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat^=%f\|%l\ col\ %c\|%m
</span></code></pre><p>Lua:<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>^ &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;
</span><span>
</span><span style=color:#5f6364>-- or try the equivalent
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>prepend</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p><strong>Delete an item</strong><p>Vimscript:<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat-=%f\|%l\ col\ %c\|%m
</span></code></pre><p>Lua:<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat </span><span style=color:#5fb3b3>- &#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;
</span><span>
</span><span style=color:#5f6364>-- or the equivalent
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>errorformat</span><span style=color:#5fb3b3>:</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>%f|%l col %c|%m</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><ul><li>Pairs</ul><p>Some options expect a list of key-value pairs. To ilustrate this we'll use <code>listchars</code>.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> listchars=</span><span style=color:#69c>tab</span><span>:▸\ ,eol:↲,trail:·
</span></code></pre><p>In lua we can use tables for this too.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>listchars </span><span style=color:#5fb3b3>= {</span><span style=color:#99c794>eol </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>↲</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>tab </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>▸ </span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>trail </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>·</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><blockquote><p>Note: to actually see this on your screen you need to enable the <code>list</code> option. See <a rel=noopener target=_blank href="https://neovim.io/doc/user/options.html#'listchars'">:help listchars</a>.</blockquote><p>Since we are still using tables this option also supports the same operations mentioned in the previous section.<h2 id=calling-vim-functions>Calling vim functions</h2><p>Vimscript like any other programming language it has its own built-in functions (<a rel=noopener target=_blank href=https://neovim.io/doc/user/usr_41.html#function-list>many functions</a>) and thanks to the <code>vim</code> module we can call them throught <code>vim.fn</code>. Just like <code>vim.opt</code>, <code>vim.fn</code> is a meta-table, but this one is meant to provide a convenient syntax for us to call vim functions. We use it to call built-in functions, user defined functions and even functions of plugins that are not written in lua.<p>We could for example check the neovim version like this:<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>if </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>has</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>nvim-0.5</span><span style=color:#5fb3b3>&#39;) == </span><span style=color:#f99157>1 </span><span style=color:#c594c5>then
</span><span>  </span><span style=color:#69c>print</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>we got neovim 0.5</span><span style=color:#5fb3b3>&#39;)
</span><span style=color:#c594c5>end
</span></code></pre><p>Wait, hold up, why are we comparing the result of <code>has</code> with a <code>1</code>? Ah, well, it turns out vimscript only included booleans in the <code>7.4.1154</code> version. So functions like <code>has</code> return <code>0</code> or <code>1</code>, and in lua both are truthy.<p>I've already mentioned that vimscript can have variable names that are valid in lua, in that case you know you can use square brackets like this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>&#39;](&#39;</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>But what you need to know now is that we can also use <code>vim.call</code>.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>fzf#vim#files</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/projects</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>)
</span></code></pre><p>Those two do the exact same thing. In practice <code>vim.fn.somefunction()</code> and <code>vim.call('somefunction')</code> have the same effect. They are the same.<p>Now let me show you something cool. In this particular case the lua-vimscript integration is so good we can use a plugin manager without any special adapters.<h3 id=vim-plug-in-lua>vim-plug in lua</h3><p>I know there is a lot of people out there who use <a rel=noopener target=_blank href=https://github.com/junegunn/vim-plug/>vim-plug</a>, you might think you need to migrate to a plugin manager that is written in lua, but that's not the case. We can use <code>vim.fn</code> and <code>vim.call</code> to bring vim-plug to lua.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>Plug </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>&#39;]
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/.config/nvim/plugged</span><span style=color:#5fb3b3>&#39;)
</span><span>
</span><span style=color:#5f6364>-- List of plugins goes here
</span><span style=color:#5f6364>-- ....
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Those 3 lines of code are the only thing you need. You can try it, this works.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>Plug </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>plug#</span><span style=color:#5fb3b3>&#39;]
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#begin</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>~/.config/nvim/plugged</span><span style=color:#5fb3b3>&#39;)
</span><span>
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>wellle/targets.vim</span><span style=color:#5fb3b3>&#39;
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>tpope/vim-surround</span><span style=color:#5fb3b3>&#39;
</span><span style=color:#69c>Plug </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>tpope/vim-repeat</span><span style=color:#5fb3b3>&#39;
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>call</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>plug#end</span><span style=color:#5fb3b3>&#39;)
</span></code></pre><p>Before you say anything, yes, all of that is valid lua. If a function only recieves a single argument, and that argument is a string or a table, you can omit the parenthesis.<p>If you use the second argument of <code>Plug</code> you'll need the parenthesis and the second argument must be a table. Let me show you. If you have this in vimscript.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>Plug </span><span style=color:#99c794>&#39;scrooloose/nerdtree&#39;</span><span>, {</span><span style=color:#99c794>&#39;on&#39;</span><span>: </span><span style=color:#99c794>&#39;NERDTreeToggle&#39;</span><span>}
</span></code></pre><p>In lua you'll need to do this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>scrooloose/nerdtree</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>on </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>NERDTreeToggle</span><span style=color:#5fb3b3>&#39;})
</span></code></pre><p>Unfortunately <code>vim-plug</code> has a couple of options that will cause an error if we use this syntax, those are <code>for</code> and <code>do</code>. In this case we need to wrap the key in quotes and square brackets.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>junegunn/goyo.vim</span><span style=color:#5fb3b3>&#39;, {[&#39;</span><span style=color:#99c794>for</span><span style=color:#5fb3b3>&#39;] = &#39;</span><span style=color:#99c794>markdown</span><span style=color:#5fb3b3>&#39;})
</span></code></pre><p>You might know that the <code>do</code> option takes a string or a function which will be executed when the plugin is updated or installed. But what you might not know is that we are not forced to use a "vim function", we can use lua function and it'll work just fine.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>Plug</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>VonHeikemen/rubber-themes.vim</span><span style=color:#5fb3b3>&#39;, {
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>[&#39;</span><span style=color:#99c794>do</span><span style=color:#5fb3b3>&#39;] = </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>opt</span><span style=color:#5fb3b3>.</span><span style=color:#69c>termguicolors </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span style=color:#69c>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>colorscheme rubber</span><span style=color:#5fb3b3>&#39;)
</span><span style=color:#69c>  </span><span style=color:#c594c5>end
</span><span style=color:#5fb3b3>})
</span></code></pre><p>There you have it. You don't need to use a plugin manager written in lua if you don't want to.<h2 id=vimscript-is-still-our-friend>Vimscript is still our friend</h2><p>You might have notice in that last example I used <code>vim.cmd</code> to set the color scheme, this is because there are still things we can't do with lua. Right now we can't create or call ex-commands, same goes for autocommands.<p>To overcome these limitations we usually use <code>vim.cmd</code>. This function can execute multiple lines of vimscript. It means that we can do lots of things in a single call.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>[[
</span><span style=color:#99c794>  syntax enable
</span><span style=color:#99c794>  colorscheme rubber
</span><span style=color:#99c794>
</span><span style=color:#99c794>  command! Hello echom &quot;hello!!&quot;
</span><span style=color:#5fb3b3>]]
</span></code></pre><p>So anything that you can't "translate" to lua you can put it in a string and pass that to <code>vim.cmd</code>.<p>I told you we can execute any vim command, right? I feel compelled to tell you this includes the <code>source</code> command. For those who don't know, <code>source</code> allows us to call other files written in vimscript. For example, in my config I use this to make some tweaks to the colorscheme. I do this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>source ~/.config/nvim/theme.vim</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>And <code>theme.vim</code> creates an autocommand that will be triggered everytime there is a <code>ColorScheme</code> event.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span>function! </span><span style=color:#69c>MyHighlights</span><span style=color:#5fb3b3>(</span><span>) abort
</span><span>  hi! link Question String
</span><span>  hi! link NonText LineNr
</span><span>
</span><span>  hi! link TelescopeMatching Boolean
</span><span>  hi! link TelescopeSelection CursorLine
</span><span>endfunction
</span><span>
</span><span style=color:#c594c5>augroup</span><span> MyColors
</span><span>  </span><span style=color:#69c>autocmd</span><span>!
</span><span>  </span><span style=color:#69c>autocmd</span><span> ColorScheme * call </span><span style=color:#69c>MyHighlights</span><span>()
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><p>I like to keep this snippet in a separate file because is very likely I will keep adding lines to it. Also, there is no way to this in lua yet.<h2 id=keybindings>Keybindings</h2><p>Here we find ourselves in an interesting situation. We actually can define our keybindings in lua but we don't have a "convenient" api just yet. Why do I say that? First thing is that the current way doesn't feel familiar, it's very different from vimscript. The other thing is that we can't bind a lua function to a key. We can call a lua function from a keyboard shortcut, but we basically have to cheat (I'll tell you how).<p>Anyway, these are the two functions we have available right now.<ul><li><code>vim.api.nvim_set_keymap</code><li><code>vim.api.nvim_buf_set_keymap</code></ul><p>The first one can be used to set global keybindings and the other sets keybindings only in a buffer.<p><code>nvim_set_keymap</code> takes 4 arguments:<ul><li>Mode. But not the name of the mode, we need the abbreviation. You can find a list of valid options <a rel=noopener target=_blank href=https://github.com/nanotee/nvim-lua-guide#defining-mappings>here</a>.<li>Key we want to bind.<li>Action we want to execute.<li>Extra arguments. These are the same options we would use in vimscript (except for <code>buffer</code>), you can find the list <a rel=noopener target=_blank href=https://neovim.io/doc/user/map.html#:map-arguments>here</a>.</ul><blockquote><p><code>nvim_buf_set_keymap</code> is the same, the only difference is that the first argument should be the number of the buffer. If you use the number <code>0</code> neovim will asume you want the keybinding to take effect in the current buffer.</blockquote><p>So if we wanted to translate this to lua.<pre data-lang=vim style=background-color:#2b2c2f;color:#cccece class=language-vim><code class=language-vim data-lang=vim><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader&gt;</span><span>w :write</span><span style=color:#fac863>&lt;CR&gt;
</span></code></pre><p>We would have to do this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span></code></pre><p>Not the greatest thing in the world but there something we can do to make it a bit more convenient.<ul><li>Make an alias</ul><p>If you prefer a simple approach you could assign this function to a variable with a short name.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>map </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span>nvim_set_keymap
</span><span>
</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;, {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span></code></pre><ul><li>Make a helper function</ul><p>If you're willing to put more lines of code you could create another function, one that has the default values you want. I mention this because it is considered a good practice to make our keybindings non-recursive by default.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span style=color:#69c>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>key</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#5f6364>-- get the extra options
</span><span>  </span><span style=color:#c594c5>local </span><span>opts </span><span style=color:#5fb3b3>= {</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#c594c5>for </span><span>i</span><span style=color:#5fb3b3>, </span><span>v </span><span style=color:#c594c5>in </span><span style=color:#69c>pairs</span><span style=color:#5fb3b3>(</span><span>key</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>do
</span><span>    </span><span style=color:#c594c5>if </span><span style=color:#69c>type</span><span style=color:#5fb3b3>(</span><span>i</span><span style=color:#5fb3b3>) == &#39;</span><span style=color:#99c794>string</span><span style=color:#5fb3b3>&#39; </span><span style=color:#c594c5>then </span><span>opts</span><span style=color:#5fb3b3>[</span><span>i</span><span style=color:#5fb3b3>] = </span><span>v </span><span style=color:#c594c5>end
</span><span>  </span><span style=color:#c594c5>end
</span><span>
</span><span>  </span><span style=color:#5f6364>-- basic support for buffer-scoped keybindings
</span><span>  </span><span style=color:#c594c5>local </span><span>buffer </span><span style=color:#5fb3b3>= </span><span>opts</span><span style=color:#5fb3b3>.</span><span>buffer
</span><span>  opts</span><span style=color:#5fb3b3>.</span><span>buffer </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>nil
</span><span>
</span><span>  </span><span style=color:#c594c5>if </span><span>buffer </span><span style=color:#c594c5>then
</span><span>    vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_buf_set_keymap</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, </span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>], </span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>], </span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>3</span><span style=color:#5fb3b3>], </span><span>opts</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>else
</span><span>    vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(</span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>], </span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>2</span><span style=color:#5fb3b3>], </span><span>key</span><span style=color:#5fb3b3>[</span><span style=color:#f99157>3</span><span style=color:#5fb3b3>], </span><span>opts</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>end
</span><span style=color:#c594c5>end
</span></code></pre><p>Basic usage.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>map </span><span style=color:#5fb3b3>{&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>:write&lt;CR&gt;</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>A cool thing about this function is that it takes advantage of the way we can create tables in lua. So this is valid.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>map </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>, &#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;e</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>%</span><span style=color:#5fb3b3>&#39;}
</span></code></pre><p>And so is this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#69c>map </span><span style=color:#5fb3b3>{&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>&lt;Leader&gt;e</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>%</span><span style=color:#5fb3b3>&#39;, </span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>}
</span></code></pre><h3 id=calling-lua-functions>Calling lua functions</h3><p>If we apply the knowledge we gained already about calling lua from vimscript, then we can do this.<p>Assuming we have a lua module called <code>usermod</code> and this module has a function called <code>somefunction</code>.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>M </span><span style=color:#5fb3b3>= {}
</span><span>
</span><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>somefunction </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span>  </span><span style=color:#69c>print</span><span style=color:#5fb3b3>(&#39;</span><span style=color:#99c794>all good</span><span style=color:#5fb3b3>&#39;)
</span><span style=color:#c594c5>end
</span><span>
</span><span style=color:#c594c5>return </span><span>M
</span></code></pre><p>We can call it like this.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;Leader&gt;w</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&quot;</span><span style=color:#99c794>&lt;cmd&gt;lua require(&#39;usermod&#39;).somefunction()&lt;CR&gt;</span><span style=color:#5fb3b3>&quot;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>)
</span></code></pre><p>Now, things change a little bit if we need an expression. In that case we can't use <code>&lt;cmd>lua</code>. We would need the variable <code>v:lua</code>, with this variable we can call lua functions that exists in the global scope.<p>To show you how this would work I'll try to make a smart <code>&lt;Tab></code> key. When the autocomplete menu is visible I want to navigate throught the list of results, otherwise it'll act like a regular <code>&lt;Tab></code>.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span style=color:#69c>t </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>return </span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_replace_termcodes</span><span style=color:#5fb3b3>(</span><span>str</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>)
</span><span style=color:#c594c5>end
</span><span>
</span><span style=color:#f99157>_G</span><span style=color:#5fb3b3>.</span><span style=color:#69c>smart_tab </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>()
</span><span>  </span><span style=color:#c594c5>if </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pumvisible</span><span style=color:#5fb3b3>() == </span><span style=color:#f99157>1 </span><span style=color:#c594c5>then
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>t</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;C-n&gt;</span><span style=color:#5fb3b3>&#39;
</span><span>  </span><span style=color:#c594c5>else
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>t</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;Tab&gt;</span><span style=color:#5fb3b3>&#39;
</span><span>  </span><span style=color:#c594c5>end
</span><span style=color:#c594c5>end
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#69c>nvim_set_keymap</span><span style=color:#5fb3b3>(
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>i</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>&lt;Tab&gt;</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>v:lua.smart_tab()</span><span style=color:#5fb3b3>&#39;,
</span><span style=color:#69c>  </span><span style=color:#5fb3b3>{</span><span style=color:#99c794>noremap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>, </span><span style=color:#99c794>expr </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>)
</span></code></pre><blockquote><p>In lua <code>_G</code> is the global table that holds all the global variables. It's not strictly necessary but I'm using it to make it clear that I'm creating a global function on purpose.</blockquote><p>If you're asking why I return <code>t'&lt;C-n>'</code>, is because we don't need the string <code>&lt;C-n></code> we need the code that represents <code>ctrl+n</code>, same thing with <code>&lt;Tab></code>.<p>If this api is not good enough for you, consider not migrating your keybindings. Leave them in a script and call it from lua.<pre data-lang=lua style=background-color:#2b2c2f;color:#cccece class=language-lua><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#69c>cmd </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>source ~/.config/nvim/keymap.vim</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>For those of you who are actually trying to run away from vimscript I could recommend some plugins:<ul><li><a rel=noopener target=_blank href=https://github.com/tjdevries/astronauta.nvim>astronauta.nvim</a><li><a rel=noopener target=_blank href=https://github.com/svermeulen/vimpeccable>Vimpeccable</a><li><a rel=noopener target=_blank href=https://github.com/bkoropoff/bex.nvim>bex.nvim</a></ul><p>No need to download them all. Each one has a different way to create keybindings. Pick the one you like the most.<h2 id=plugin-manager>Plugin manager</h2><p>Speaking of plugins. You might want a plugin manager that is written in lua, just because. It appears that right now these are your options:<ul><li><a rel=noopener target=_blank href=https://github.com/savq/paq-nvim/>paq</a></ul><p>A plugin manager that is simple and fast. I'm serious, this thing has less than 300 lines of code. It was created to download, update and remove plugins. That's it. If you don't need anything else, look no further, this is the plugin manager you want.<ul><li><a rel=noopener target=_blank href=https://github.com/wbthomason/packer.nvim>packer</a></ul><p>If you want more features <code>packer</code> is the alternative. It has the basic features you would expect, it offers lazy-loading capabilities, has support for <code>luarocks</code> (which is like a package manager for lua), it can handle "local plugins". And does other things I don't understand, but the point is that is a feature complete plugin manager.<ul><li><a rel=noopener target=_blank href=https://github.com/kristijanhusak/vim-packager>vim-packager</a></ul><p>This one is not written in lua but I want to add it because it does offer a lua api. It offers more features than <code>paq</code> but not as much a <code>packer</code>, so if you are looking for a middle ground between those two, this might be a good choice.<h2 id=conclusion>Conclusion</h2><p>Recap time. We learned how to use lua from vimscript. We now know how to use vimscript from lua. We have the tools to activate, deactivate and modify all sorts of options and variables in neovim. We got to know the methods we have available to create our keymaps, and we know their limitations. We figure out how to use plugin managers that aren't written in lua, and saw a few alternatives that are written in lua. I say we are ready to use lua in neovim.<p>For those who want to see a real world usage or whatever, I'll share a link to my current config in github: <a rel=noopener target=_blank href=https://github.com/VonHeikemen/dotfiles/tree/master/my-configs/neovim>neovim</a>.<h2 id=sources>Sources</h2><ul><li><a rel=noopener target=_blank href=https://learnxinyminutes.com/docs/lua/>learn x in y minutes: where X=lua</a><li><a rel=noopener target=_blank href=https://github.com/nanotee/nvim-lua-guide>nvim-lua-guide</a><li><a rel=noopener target=_blank href=https://neovim.io/doc/user/lua.html#:lua-heredoc>:help lua-heredoc</a><li><a rel=noopener target=_blank href=https://neovim.io/doc/user/lua.html#lua-vim-variables>:help lua-vim-variables</a><li><a rel=noopener target=_blank href=https://neovim.io/doc/user/lua.html#lua-stdlib>:help lua-stdlib</a><li><a rel=noopener target=_blank href=https://neovim.io/doc/user/usr_41.html#function-list>:help function-list</a><li><a rel=noopener target=_blank href=https://neovim.io/doc/user/api.html#nvim_set_keymap()>:help nvim_set_keymap()</a><li><a rel=noopener target=_blank href=https://github.com/curist/dotvim/blob/98b161f0759d3316fcf6a776d03665d6ab4827ee/bundles.lua>curist's bundle.lua</a></ul><hr><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>