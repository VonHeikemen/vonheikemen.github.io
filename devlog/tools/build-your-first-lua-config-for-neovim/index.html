<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Build your first Neovim configuration in lua | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, neovim, shell, software, coding, development" name=keywords><meta content="The one where we learn how to customize Neovim and add plugins" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a></ul> © 2020-2023 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Build your first Neovim configuration in lua</h1><span class=post-date>2022-07-04 | 20 min read | <a href=https://vonheikemen.github.io/devlog/es/tools/build-your-first-lua-config-for-neovim/> Leer en español </a> </span><blockquote>Last updated: 2023-09-26</blockquote><p>Neovim is a tool both powerful and extensible. With some effort it can do more than just modify text in a file. Today I hope I can teach you enough about Neovim's <code>lua</code> api to be able to build your own configuration.<p>We will create a configuration file called <code>init.lua</code>, add a couple of plugins and I'll tell you how to make your own commands.<p>This tutorial is meant for people totally new to Neovim. If you already have a configuration written in vimscript and want to migrate to lua, you might find this other article more useful: <a href=https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/>Everything you need to know to configure neovim using lua</a>.<h2 id=some-advice>Some advice</h2><p>Before we start, I suggest you install the latest stable version of Neovim. You can go to the <a href=https://github.com/neovim/neovim/releases rel=noopener target=_blank>release page</a> in the github repository and download it from there. From now on I will assume you are using version 0.8 or greater.<p>If you don't feel comfortable using Neovim as an editor, follow the tutorial that comes bundled with it. You can start it using this command in the terminal.<pre class=language-sh data-lang=sh style=background:#2b2c2f;color:#cccece><code class=language-sh data-lang=sh><span style=color:#6699cc>nvim +Tutor
</span></code></pre><p>I will assume you know all the features <code>Tutor</code> teaches.<h2 id=the-entry-point>The entry point</h2><p>First things first, we need to create a configuration file, the famous <code>init.lua</code>. And where that might be? Well, it depends on your operating system and also your environment variables. I can tell you a way of creating it using Neovim, that way we don't have to worry about those details.<blockquote><p>Fun fact: Some articles online call the configuration file <code>vimrc</code>. That is the name it has in Vim.</blockquote><p>For this task we won't be using lua, we'll use the language created specifically for Vim: vimscript.<p>Let's open Neovim and execute this command.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:call </span><span style=color:#6699cc>mkdir</span><span>(</span><span style=color:#6699cc>stdpath</span><span>(</span><span style=color:#99c794>"config"</span><span>), </span><span style=color:#99c794>"p"</span><span>)
</span></code></pre><p>It'll create the folder where the configuration file needs to be. If you want to know what folder it created use this.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:</span><span style=color:#6699cc>echo stdpath</span><span>(</span><span style=color:#99c794>"config"</span><span>)
</span></code></pre><p>Now we are going to edit the configuration file.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:</span><span style=color:#6699cc>exe </span><span style=color:#99c794>"edit" </span><span style=color:#6699cc>stdpath</span><span>(</span><span style=color:#99c794>"config"</span><span>) . </span><span style=color:#99c794>"/init.lua"
</span></code></pre><p>After doing that we'll be in a "blank page". At this point the file doesn't exists on the system just yet. We need to save it with this command.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:write
</span></code></pre><p>Once the file actually exists we can edit it anytime we want using this.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:edit $MYVIMRC
</span></code></pre><p>If you are the kind of person that likes to automate things in scripts you'll be happy to know you can do all of it with one command.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>nvim --headless -c </span><span style=color:#99c794>'call mkdir(stdpath("config"), "p") | exe "edit" stdpath("config") . "/init.lua" | write | quit'
</span></code></pre><h2 id=editor-settings>Editor settings</h2><p>To access the editor's setting we need to use the global variable <code>vim</code>. Okay, more than a variable this thing is a module, you'll find all sorts of utilities in there. Right now we are going to focus on the <code>opt</code> property, with it we can modify all 351 options Neovim has (in version 0.7).<p>This is the syntax you should follow.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>option_name </span><span style=color:#5fb3b3>= </span><span>value
</span></code></pre><p>Where <code>option_name</code> can be anything in <a href=https://neovim.io/doc/user/quickref.html#option-list rel=noopener target=_blank>this list</a>. And <code>value</code> must be whatever that option expects.<blockquote><p>You can see the list in Neovim using <code>:help option-list</code>.</blockquote><p>One thing you should know is that every option has a scope. Some options are global, some only apply in the current window or file. The scope of every option is mentioned in their help page. To navigate to the help page of an option follow this pattern.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help </span><span style=color:#99c794>'option_name'
</span></code></pre><h3 id=useful-options>Useful options</h3><ul><li><code>number</code></ul><p>This option expects a boolean value. This means it can only have two possible values: <code>true</code> or <code>false</code>. If we assign <code>true</code> we enable it, <code>false</code> does the opposite.<p>When we enable <code>number</code> Neovim starts showing the line number in the gutter.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>number </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><ul><li><code>mouse</code></ul><p>Neovim (and Vim) can let you use the mouse for some things, like select text or change the size of window. <code>mouse</code> expects a data type called a string (a piece of text wrapped in quotes) with a combination of modes. We are not going to worry about those modes now, we can just enable it for every mode.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>mouse </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>a</span><span style=color:#5fb3b3>'
</span></code></pre><ul><li><code>ignorecase</code></ul><p>With this we can tell Neovim to ignore uppercase letters when executing a search. For example, if we search the word <code>two</code> the results can contain any variations like <code>Two</code>, <code>tWo</code> or <code>two</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>ignorecase </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><ul><li><code>smartcase</code></ul><p>Makes our search ignore uppercase letters unless the search term has an uppercase letter. Most of the time this is used in combination with <code>ignorecase</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>smartcase </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><ul><li><code>hlsearch</code></ul><p>Highlights the results of the previous search. It can get annoying really fast, this is how we disable it.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>hlsearch </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false
</span></code></pre><ul><li><code>wrap</code></ul><p>Makes the text of long lines always visible. Long lines are those that exceed the width of the screen. The default value is <code>true</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>wrap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><ul><li><code>breakindent</code></ul><p>Preserve the indentation of a virtual line. These "virtual lines" are the ones only visible when <code>wrap</code> is enabled.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>breakindent </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span></code></pre><ul><li><code>tabstop</code></ul><p>The amount of space on screen a <code>Tab</code> character can occupy. The default value is 8. I think 2 is fine.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>tabstop </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span></code></pre><ul><li><code>shiftwidth</code></ul><p>Amount of characters Neovim will use to indent a line. This option influences the keybindings <code><<</code> and <code>>></code>. The default value is 8. Most of the time we want to set this with same value as <code>tabstop</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>shiftwidth </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>2
</span></code></pre><ul><li><code>expandtab</code></ul><p>Controls whether or not Neovim should transform a <code>Tab</code> character to spaces. The default value is <code>false</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>expandtab </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false
</span></code></pre><p>There are a few other things in the <code>vim</code> module we can use to modify variables, but we have other things to do right now. I talk about this topic in more detail here: <a href=https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/#editor-settings>Configuring Neovim - Editor Settings</a>.<h2 id=keybindings>Keybindings</h2><p>Because Neovim clearly doesn't have enough, we need to create more. To do it we need to learn about <code>vim.keymap.set</code>. Here is a basic usage example.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTspace>w</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTcmd>write&LTcr></span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Save</span><span style=color:#5fb3b3>'})
</span></code></pre><p>After executing this, the sequence <code>Space</code> + <code>w</code> will call the <code>write</code> command. Basically, we can save changes made to a file with <code>Space</code> + <code>w</code>.<p>Now let me explain <code>vim.keymap.set</code> parameters.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>({</span><span>mode</span><span style=color:#5fb3b3>}, {</span><span>lhs</span><span style=color:#5fb3b3>}, {</span><span>rhs</span><span style=color:#5fb3b3>}, {</span><span>opts</span><span style=color:#5fb3b3>})
</span></code></pre><ul><li><p><code>{mode}</code> mode where the keybinding should execute. It can be a list of modes. We need to specify the mode's short name. Here are some of the most common.</p> <ul><li><code>n</code>: Normal mode.<li><code>i</code>: Insert mode.<li><code>x</code>: Visual mode.<li><code>s</code>: Selection mode.<li><code>v</code>: Visual + Selection.<li><code>t</code>: Terminal mode.<li><code>o</code>: Operator-pending.<li><code>''</code>: Yes, an empty string. Is the equivalent of <code>n</code> + <code>v</code> + <code>o</code>.</ul><li><p><code>{lhs}</code> is the key we want to bind.</p><li><p><code>{rhs}</code> is the action we want to execute. It can be a string with a command or an expression. You can also provide a lua function.</p><li><p><code>{opts}</code> this must be a lua table. If you don't know what is a "lua table" just think is a way of storing several values in one place. Anyway, it can have these properties.</p> <ul><li><p><code>desc</code>: A string that describes what the keybinding does. You can write anything you want.</p><li><p><code>remap</code>: A boolean that determines if our keybinding can be recursive. The default value is <code>false</code>. Recursive keybindings can cause some conflicts if used incorrectly. Don't enable it unless you know what you're doing. I will explain this recursive thing later.</p><li><p><code>buffer</code>: It can be a boolean or a number. If we assign the boolean <code>true</code> it means the keybinding will only be effective in the current file. If we assign a number, it needs to be the "id" of an open buffer.</p><li><p><code>silent</code>: A boolean. Determines whether or not the keybindings can show a message. The default value is <code>false</code>.</p><li><p><code>expr</code>: A boolean. If enabled it gives the chance to use vimscript or lua to calculate the value of <code>{rhs}</code>. The default value is <code>false</code>.</p></ul></ul><h3 id=the-leader-key>The leader key</h3><p>When creating keybindings we can use the special sequence <code>&LTleader></code> in the <code>{lhs}</code> parameter, it'll take the value of the global variable <code>mapleader</code>.<p>So <code>mapleader</code> is a global variable in vimscript that can be string. For example.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>mapleader </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>,</span><span style=color:#5fb3b3>'
</span></code></pre><p>After defining it we can use it as a prefix in our keybindings.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTleader>w</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTcmd>write&LTcr></span><span style=color:#5fb3b3>')
</span></code></pre><p>This will make <code>,</code> + <code>w</code> save the current file.<p>What happens if we don't define it? The default value is <code>\</code>, clearly not the best choice. I can recommend using the space key as leader. Like this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>mapleader </span><span style=color:#5fb3b3>= ' '
</span></code></pre><h3 id=mappings>Mappings</h3><p>I'll show you just a few keybindings that you might find useful.<ul><li>Copy/paste from clipboard</ul><p>The default behavior in Neovim (and Vim) doesn't take into account the system clipboard. It has its own mechanism to store text. When we copy something using the <code>y</code> keybinding that text goes to an internal register. I prefer to keep it that way, and what I do is create dedicated bindings to interact with the clipboard.<p>Copy to clipboard.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>({'</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>'}, '</span><span style=color:#99c794>cp</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>"+y</span><span style=color:#5fb3b3>')
</span></code></pre><p>Paste from clipboard.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>({'</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>'}, '</span><span style=color:#99c794>cv</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>"+p</span><span style=color:#5fb3b3>')
</span></code></pre><ul><li>Delete without changing the registers</ul><p>When we delete text in normal mode or visual mode using <code>c</code>, <code>d</code> or <code>x</code> that text goes to a register. This affects the text we paste with the keybinding <code>p</code>. What I do is modify <code>x</code> to delete text without changing the internal registers.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>({'</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>'}, '</span><span style=color:#99c794>x</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>"_x</span><span style=color:#5fb3b3>')
</span></code></pre><ul><li>Select all text in current buffer</ul><pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTleader>a</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>:keepjumps normal! ggVG&LTcr></span><span style=color:#5fb3b3>')
</span></code></pre><h2 id=plugin-manager>Plugin manager</h2><p>We are going to use <a href=https://github.com/folke/lazy.nvim rel=noopener target=_blank>lazy.nvim</a>. This plugin manager allows for "simple" configurations but also supports splitting your plugin config in modules. Today I'll just show some basic usage examples.<p>First step is to install it from github. It just so happens we can do this using lua. In lazy.nvim's documentation they show us how to do it.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>lazy </span><span style=color:#5fb3b3>= {}
</span><span>
</span><span style=color:#c594c5>function </span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>install</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>path</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>if </span><span style=color:#5fb3b3>not </span><span>vim</span><span style=color:#5fb3b3>.</span><span>loop</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>fs_stat</span><span style=color:#5fb3b3>(</span><span>path</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>then
</span><span>    </span><span style=color:#6699cc>print</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>Installing lazy.nvim....</span><span style=color:#5fb3b3>')
</span><span>    vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>system</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>      </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>git</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>      </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>clone</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>      </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>--filter=blob:none</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>      </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>https://github.com/folke/lazy.nvim.git</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>      </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>--branch=stable</span><span style=color:#5fb3b3>', </span><span style=color:#5f6364>-- latest stable release
</span><span style=color:#6699cc>      </span><span>path</span><span style=color:#5fb3b3>,
</span><span style=color:#6699cc>    </span><span style=color:#5fb3b3>})
</span><span>  </span><span style=color:#c594c5>end
</span><span style=color:#c594c5>end
</span><span>
</span><span style=color:#c594c5>function </span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>plugins</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#c594c5>if </span><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>plugins_ready </span><span style=color:#c594c5>then
</span><span>    </span><span style=color:#c594c5>return
</span><span>  </span><span style=color:#c594c5>end
</span><span>
</span><span>  </span><span style=color:#5f6364>-- You can "comment out" the line below after lazy.nvim is installed
</span><span>  lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>install</span><span style=color:#5fb3b3>(</span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>path</span><span style=color:#5fb3b3>)
</span><span>
</span><span>  vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>rtp</span><span style=color:#5fb3b3>:</span><span style=color:#6699cc>prepend</span><span style=color:#5fb3b3>(</span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>path</span><span style=color:#5fb3b3>)
</span><span>
</span><span>  </span><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>lazy</span><span style=color:#5fb3b3>').</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>(</span><span>plugins</span><span style=color:#5fb3b3>, </span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>opts</span><span style=color:#5fb3b3>)
</span><span>  vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>plugins_ready </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span style=color:#c594c5>end
</span></code></pre><p>For the moment this piece of code doesn't do anything. They are functions waiting to be called. Why do this? Is my personal preference. This way I can isolate the boilerplate needed to get the plugin manager working.<p>Now we are free to place our configuration. We need to specify the path where our plugins are going to live, that is <code>lazy.path</code>. If you want to configure lazy.nvim itself, use the variable <code>lazy.opts</code> (I don't do anything with it so for me is an empty table). Finally we add the list of plugins as an argument to <code>lazy.setup</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>lazy</span><span style=color:#5fb3b3>.</span><span>path </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>stdpath</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>data</span><span style=color:#5fb3b3>') .. '</span><span style=color:#99c794>/lazy/lazy.nvim</span><span style=color:#5fb3b3>'
</span><span>lazy</span><span style=color:#5fb3b3>.</span><span>opts </span><span style=color:#5fb3b3>= {}
</span><span>
</span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>  </span><span style=color:#5f6364>---
</span><span style=color:#6699cc>  </span><span style=color:#5f6364>-- List of plugins
</span><span style=color:#6699cc>  </span><span style=color:#5f6364>---
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Notice in <code>lazy.path</code> we use <code>stdpath('data')</code>, this will return the path to Neovim's data folder. So now we don't need to worry changing our paths depending on the operating system, Neovim will do that for us. If you want to inspect the path, use this command.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:</span><span style=color:#6699cc>echo stdpath</span><span>(</span><span style=color:#99c794>'data'</span><span>) . </span><span style=color:#99c794>'/lazy/lazy.nvim'
</span></code></pre><p>Now let's download a plugin, a colorscheme to make Neovim look better. We are going to add this in <code>lazy.setup</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#5fb3b3>{'</span><span style=color:#99c794>folke/tokyonight.nvim</span><span style=color:#5fb3b3>'}</span><span>,
</span></code></pre><p>This is the minimum data lazy.nvim needs to download a plugin from github. Which is just the name of the user in github and the name of the repository.<p>Your configuration should look like this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>lazy</span><span style=color:#5fb3b3>.</span><span>path </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>fn</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>stdpath</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>data</span><span style=color:#5fb3b3>') .. '</span><span style=color:#99c794>/lazy/lazy.nvim</span><span style=color:#5fb3b3>'
</span><span>lazy</span><span style=color:#5fb3b3>.</span><span>opts </span><span style=color:#5fb3b3>= {}
</span><span>
</span><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>  </span><span style=color:#5fb3b3>{'</span><span style=color:#99c794>folke/tokyonight.nvim</span><span style=color:#5fb3b3>'},
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Now let's add the code to apply the theme. Add the end of the file put this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>opt</span><span style=color:#5fb3b3>.</span><span>termguicolors </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>cmd</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>colorscheme</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>tokyonight</span><span style=color:#5fb3b3>')
</span></code></pre><p>We enable <code>termguicolors</code> so Neovim can show the "best" version of the colorscheme. Each colorscheme can have two versions: one that works for terminals which only support 256 colors and another that specifies colors in hexadecimal code (has way more colors).<p>We tell Neovim which theme we want using the <code>colorscheme</code> command. And yes, it looks like a lua function (it is). But under the hood is executing this vim command.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>colorscheme</span><span> tokyonight
</span></code></pre><p>We save these changes and restart Neovim, to trigger the download of lazy.nvim. When Neovim starts it should show a message telling us is cloning the plugin manager. After it's done another window will show up, it'll tell us the progress of the plugins download. After plugins are installed they will be loaded.<h2 id=plugin-configuration>Plugin configuration</h2><p>Each plugin author has the freedom to create the configuration method they want. But then how do we know what to do? We have to rely on the documentation the plugin provides, we have no other choice.<p>Most plugins have a file called <code>README.md</code> in their repository, github is kind enough to render that file in the main page. It's the first place you should look for configuration instructions.<p>If for some reason the README doesn't have the information we are after, look for a folder called <code>doc</code>. Inside there should be a <code>txt</code> file, this is the help page. We can read it using Neovim executing the command <code>:help name-of-file</code>.<h3 id=conventions-of-lua-plugins>Conventions of lua plugins</h3><p>Lucky for us a huge amount of plugins written in lua follow a certain pattern. They use a function called <code>.setup</code>, and that function expects a lua table with some options. If there is something you should learn about the syntax of lua is how to create tables.<p>Let's configure a plugin. For this example I'll use <a href=https://github.com/nvim-lualine/lualine.nvim rel=noopener target=_blank>lualine</a>, a plugin that can give us a good looking statusline. First step, add <code>nvim-lualine/lualine.nvim</code> to the list of plugins.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>lazy</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>  </span><span style=color:#5fb3b3>{'</span><span style=color:#99c794>folke/tokyonight.nvim</span><span style=color:#5fb3b3>'},
</span><span style=color:#6699cc>  </span><span style=color:#5fb3b3>{'</span><span style=color:#99c794>nvim-lualine/lualine.nvim</span><span style=color:#5fb3b3>'},
</span><span style=color:#5fb3b3>})
</span></code></pre><p>In lualine's repository we can find a <code>doc</code> folder and inside there is a file called <code>lualine.txt</code>. We can read it in Neovim using this.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help lualine
</span></code></pre><p>This documentation shows we can make the plugin work just by calling <code>setup</code> on the lualine module. Like this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>lualine</span><span style=color:#5fb3b3>').</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>()
</span></code></pre><p>Add that to the end of your configuration.<p>If we save the changes and restart Neovim, lazy.nvim will install the plugin and apply the default configuration.<p>But now lets pretend we want to change some options. For example, say we hate icons, we want them gone. In the documentation there is a section called <code>lualine-Default-configuration</code>, in there I can see some code that says <code>icon_enabled = true</code>. Great, let's copy all the necessary properties to modify that.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>lualine</span><span style=color:#5fb3b3>').</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>  </span><span style=color:#99c794>options </span><span style=color:#5fb3b3>= {
</span><span style=color:#6699cc>    </span><span style=color:#99c794>icons_enabled </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>,
</span><span style=color:#6699cc>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>})
</span></code></pre><p>We can save the changes and reload the config using <code>:source $MYVIMRC</code>.<p>Now we don't like "component separators", how do we get rid of them? Check the docs again, there is a section <code>lualine-Disabling-separators</code>, it shows this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>options </span><span style=color:#5fb3b3>= { </span><span style=color:#99c794>section_separators </span><span style=color:#5fb3b3>= '', </span><span style=color:#99c794>component_separators </span><span style=color:#5fb3b3>= '' }
</span></code></pre><p>Looks promising but we should not copy/paste that code as is. We need to really read it. It shows an <code>options</code> property, we already have one of those, what we should do is add the new properties to the thing we have.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>lualine</span><span style=color:#5fb3b3>').</span><span style=color:#6699cc>setup</span><span style=color:#5fb3b3>({
</span><span style=color:#6699cc>  </span><span style=color:#99c794>options </span><span style=color:#5fb3b3>= {
</span><span style=color:#6699cc>    </span><span style=color:#99c794>icons_enabled </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>,
</span><span style=color:#6699cc>    </span><span style=color:#99c794>section_separators </span><span style=color:#5fb3b3>= '',
</span><span style=color:#6699cc>    </span><span style=color:#99c794>component_separators </span><span style=color:#5fb3b3>= ''
</span><span style=color:#6699cc>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Save and reload to verify the changes.<p>So... what did we learned? To configure some plugins we need know: how to navigate to the documentation and the syntax used to create lua tables.<h3 id=vimscript-plugins>Vimscript plugins</h3><p>There are a lot of useful plugins written in vimscript. Most of them we can configure modifying global variables. In lua we change global variables of vimscript using <code>vim.g</code>.<p>Did you know Neovim has a file explorer? Yeah, it's a plugin that comes bundled in Neovim. We can use it with the command <code>:Lexplore</code>. It is written in vimscript, so there is no <code>.setup</code> function. To know how to configure it we need to check the documentation.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help netrw
</span></code></pre><p>If you check the table of content in the help page, you'll notice a section called <code>netrw-browser-settings</code>. Once there we get a list of variables and their descriptions. Let's focus on the ones that start with <code>g:</code>.<p>For example, if we want to hide the help text in the banner we use <code>netrw_banner</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>netrw_banner </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0
</span></code></pre><p>Another thing we can do is change the size of the window. For that we need <code>netrw_winsize</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>g</span><span style=color:#5fb3b3>.</span><span>netrw_winsize </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>30
</span></code></pre><p>That's it... well no, there are more variables, but like this is the basic stuff you need to know. You check the docs, see the thing you want to change and use <code>vim.g</code>.<h2 id=bonus-content>Bonus content</h2><h3 id=recursive-mappings>Recursive mappings</h3><p>If you are familiar with the word "recursive" you might be able to guess what kind of consequences they can have. If not, let me try to explain with an example.<p>Let's say we have a keybinding that opens the file explorer.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTF2></span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTcmd>Lexplore&LTcr></span><span style=color:#5fb3b3>')
</span></code></pre><p>Now let's add a recursive keybinding that uses <code>F2</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTspace>&LTspace></span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>&LTF2></span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>remap </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span></code></pre><p>If we press <code>Space</code> twice the file explorer will show up. But if we change <code>remap</code> to <code>false</code> then nothing happens.<p>With recursive mappings we can use previous keybindings in the <code>{rhs}</code> argument. Those keybindings could be created by us or by other plugins. Non recursive mappings only give us access to keybindings defined by Neovim.<p>Probably the only time when you want a recursive mapping is when you want to use a feature defined by a plugin.<p>Why is it that recursive mappings can cause conflicts? Consider this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>keymap</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>set</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>n</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>*</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>*zz</span><span style=color:#5fb3b3>')
</span></code></pre><p>Notice here we are using <code>*</code> in <code>{lhs}</code> and also <code>{rhs}</code>. If we make this recursive we create an endless cycle. Neovim will try to call <code>*</code> and never executes <code>zz</code>.<h3 id=user-commands>User commands</h3><p>Yes, we can create our own commands. In lua we use this function.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_user_command</span><span style=color:#5fb3b3>({</span><span>name</span><span style=color:#5fb3b3>}, {</span><span>command</span><span style=color:#5fb3b3>}, {</span><span>opts</span><span style=color:#5fb3b3>})
</span></code></pre><ul><li><p><code>{name}</code> must be a string. It has to start with an uppercase letter.</p><li><p><code>{command}</code> if it's a string it must be valid vimscript. Or it can be a lua function.</p><li><p><code>{opts}</code> must be a lua table. Is not optional. If you don't use any options you provide an empty table.</p></ul><p>So we could create a function that "reloads" our configuration.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_user_command</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>ReloadConfig</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>source $MYVIMRC</span><span style=color:#5fb3b3>', {})
</span></code></pre><p>User commands are a fairly advance topic so if you want to know more details you can check the documentation.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help </span><span style=color:#6699cc>nvim_create_user_command</span><span>()
</span><span>:help user-commands
</span></code></pre><h3 id=autocommands>Autocommands</h3><p>With autocommands we can execute actions when Neovim triggers an event. You can check the complete list of events with this command <code>:help events</code>.<p>We can create autocommands with this function.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_autocmd</span><span style=color:#5fb3b3>({</span><span>event</span><span style=color:#5fb3b3>}, {</span><span>opts</span><span style=color:#5fb3b3>})
</span></code></pre><ul><li><p><code>{event}</code> must be a string with the name of an event.</p><li><p><code>{opts}</code> must be a lua table, its properties will determine the behavior of the autocommand. These are some of the most useful options.</p> <ul><li><p><code>desc</code> a string that describes what the autocommand does.</p><li><p><code>group</code> it can be a number or a string. If you provide a string it must be the name of an existing group. If you provide a number it must be the "id" of a group.</p><li><p><code>pattern</code> can be a lua table or a string. This allows us to control when we want to trigger the autocommand. Its value depends on the event. Check the documentation of the event to know the possible values.</p><li><p><code>once</code> it can be a boolean. If enabled the autocommand will only execute once. The default value is <code>false</code>.</p><li><p><code>command</code> a string. Must be valid vimscript. Is the action we want to execute.</p><li><p><code>callback</code> it can be a string or a lua function. If you provide a string it must be the name of a function written in vimscript. This is the action we want to execute. It can't be used with <code>command</code>.</p></ul></ul><p>Here is an example. I'll create a group called <code>user_cmds</code> and add two autocommands to it.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span>augroup </span><span style=color:#5fb3b3>= </span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_augroup</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user_cmds</span><span style=color:#5fb3b3>', {</span><span style=color:#99c794>clear </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>})
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_autocmd</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>FileType</span><span style=color:#5fb3b3>', {
</span><span style=color:#6699cc>  </span><span style=color:#99c794>pattern </span><span style=color:#5fb3b3>= {'</span><span style=color:#99c794>help</span><span style=color:#5fb3b3>', '</span><span style=color:#99c794>man</span><span style=color:#5fb3b3>'},
</span><span style=color:#6699cc>  </span><span style=color:#99c794>group </span><span style=color:#5fb3b3>= </span><span>augroup</span><span style=color:#5fb3b3>,
</span><span style=color:#6699cc>  </span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Use q to close the window</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>  </span><span style=color:#99c794>command </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>nnoremap &LTbuffer> q &LTcmd>quit&LTcr></span><span style=color:#5fb3b3>'
</span><span style=color:#5fb3b3>})
</span><span>
</span><span>vim</span><span style=color:#5fb3b3>.</span><span>api</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>nvim_create_autocmd</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>TextYankPost</span><span style=color:#5fb3b3>', {
</span><span style=color:#6699cc>  </span><span style=color:#99c794>group </span><span style=color:#5fb3b3>= </span><span>augroup</span><span style=color:#5fb3b3>,
</span><span style=color:#6699cc>  </span><span style=color:#99c794>desc </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Highlight on yank</span><span style=color:#5fb3b3>',
</span><span style=color:#6699cc>  callback </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>event</span><span style=color:#5fb3b3>)
</span><span style=color:#6699cc>    </span><span>vim</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>highlight</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>on_yank</span><span style=color:#5fb3b3>({</span><span style=color:#99c794>higroup </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Visual</span><span style=color:#5fb3b3>', </span><span style=color:#99c794>timeout </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>200</span><span style=color:#5fb3b3>})
</span><span style=color:#6699cc>  </span><span style=color:#c594c5>end
</span><span style=color:#5fb3b3>})
</span></code></pre><p>Creating the group is optional by the way.<p>The first autocommand will make a keymap <code>q</code> to close the current window, but only if the filetype is <code>help</code> or <code>man</code>. In this example I'm using vimscript but I could have done it with a lua function.<p>The second autocommand will highlight the text we copy using <code>y</code>. If you want to test the effect try copying a line using <code>yy</code>.<p>To know more about autocommands in general check the documentation.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help </span><span style=color:#6699cc>autocmd</span><span>-intro
</span></code></pre><h3 id=user-modules>User modules</h3><p>We can use lua modules to split our configuration into smaller pieces.<p>A common convention is to put every module we create into a single folder. We do this to avoid any potential conflict with a plugin. Lots of people call this module <code>user</code> (you can use another name). To make this module we need to create a couple of folders inside our config folder. First create a <code>lua</code> folder, and inside that create a <code>user</code> folder. You can do it with this command.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#5fb3b3>:</span><span>call </span><span style=color:#6699cc>mkdir</span><span style=color:#5fb3b3>(</span><span style=color:#6699cc>stdpath</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>config</span><span style=color:#5fb3b3>") . "</span><span style=color:#99c794>/lua/user</span><span style=color:#5fb3b3>", "</span><span style=color:#99c794>p</span><span style=color:#5fb3b3>")
</span></code></pre><p>Inside <code>/lua/user</code> we create our lua scripts.<p>Let's pretend we have one called <code>settings.lua</code>. Neovim doesn't know it exists, it won't be executed automatically. We need to call it from <code>init.lua</code>.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user.settings</span><span style=color:#5fb3b3>')
</span></code></pre><p>If you want to know more details about <code>require</code>'s behavior inside Neovim checkout.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>:help </span><span style=color:#6699cc>lua</span><span>-require
</span></code></pre><h3 id=the-require-function>The require function</h3><p>There is something you should know about <code>require</code>, it only executes code once. What does mean?<p>Consider this code.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user.settings</span><span style=color:#5fb3b3>')
</span><span style=color:#6699cc>require</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user.settings</span><span style=color:#5fb3b3>')
</span></code></pre><p>In here the script <code>settings.lua</code> will only be executed once. If you want to create plugins or create a feature that depends on a plugin, this behavior is good. The bad news is if want to use <code>:source $MYVIMRC</code> to reload our config the results might not be what we expect.<p>There is a very simple hack we can do to make it <code>source</code> friendly. We can empty <code>require</code>'s cache before using it. Like this.<pre class=language-lua data-lang=lua style=background:#2b2c2f;color:#cccece><code class=language-lua data-lang=lua><span style=color:#c594c5>local </span><span style=color:#6699cc>load </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>mod</span><span style=color:#5fb3b3>)
</span><span>  </span><span style=color:#f99157>package</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>loaded</span><span style=color:#5fb3b3>[</span><span>mod</span><span style=color:#5fb3b3>] = </span><span style=color:#f99157>nil
</span><span>  </span><span style=color:#6699cc>require</span><span style=color:#5fb3b3>(</span><span>mod</span><span style=color:#5fb3b3>)
</span><span style=color:#c594c5>end
</span><span>
</span><span style=color:#6699cc>load</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user.settings</span><span style=color:#5fb3b3>')
</span><span style=color:#6699cc>load</span><span style=color:#5fb3b3>('</span><span style=color:#99c794>user.keymaps</span><span style=color:#5fb3b3>')
</span></code></pre><p>If we do this in <code>init.lua</code> the <code>source</code> command will be able to execute all the files in our config.<p><strong>WARNING</strong>. Be careful with this. Some plugins might act weird if you configure them twice. What do I mean? If we use <code>source</code> and call the <code>.setup</code> function of a plugin a second time it might have unexpected effects.<h2 id=init-lua>init.lua</h2><p>If we apply (almost) everything we learned here in a single configuration file this would be the result.<ul><li><a href=https://github.com/VonHeikemen/nvim-starter/blob/01-base/init.lua rel=noopener target=_blank>init.lua</a></ul><h2 id=what-s-next>What's next?</h2><p>Maybe install some popular plugins to add fancy features to Neovim.<ul><li><a href=https://vonheikemen.github.io/devlog/tools/neovim-plugins-to-get-started/>Plugins to get started</a></ul><p>If you feel prepared to tackle more advanced topics you can read this other tutorial. It teaches how to setup an autocompletion engine and also add support for LSP:<ul><li><a href=https://vonheikemen.github.io/devlog/tools/setup-nvim-lspconfig-plus-nvim-cmp/>Setup nvim-lspconfig + nvim-cmp</a></ul><p>If you want recommendations for plugins and other configurations I suggest you check these configuration templates.<ul><li><a href=https://github.com/nvim-lua/kickstart.nvim rel=noopener target=_blank>kickstart.nvim</a><li><a href=https://github.com/VonHeikemen/nvim-starter/tree/xx-light rel=noopener target=_blank>nvim-starter - light</a><li><a href=https://github.com/NvChad/tinyvim rel=noopener target=_blank>tinyvim</a><li><a href=https://github.com/glepnir/dope rel=noopener target=_blank>dope</a><li><a href=https://github.com/LunarVim/nvim-basic-ide rel=noopener target=_blank>nvim-basic-ide</a></ul><p>You can also check my personal configuration if you like.<ul><li><a href=https://github.com/VonHeikemen/dotfiles/tree/master/my-configs/neovim rel=noopener target=_blank>neovim config</a></ul><h2 id=conclusion>Conclusion</h2><p>Now we know how to configure some basic options in Neovim. We learned how to create our very own keybindings. We know how to get plugins from github. We manage to configure a couple of plugins, a lua plugin and one written in vimscript. We took a brief look at some advance topics like recursive mappings, user commands, autocommands and lua modules.<p>I'd say you have everything you need to start exploring plugins, check other people's config and learn from them.<hr><p>Have any question? Feel free to leave a comment in one of these platform where I have shared this:<ul><li><a href=https://dev.to/vonheikemen/build-your-first-neovim-configuration-in-lua-177b rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/build-your-first-neovim-configuration-in-lua rel=noopener target=_blank>Hashnode</a></ul><p>You can reach out to me on social media:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png style=height:60px!important;width:217px!important> </a></div></div>