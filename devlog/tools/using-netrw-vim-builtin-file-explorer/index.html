<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  Using Netrw, vim's builtin file explorer | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, shell, software, coding, development" name=keywords><meta content="Where we learn how to use Netrw" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a></ul> © 2020-2023 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Using Netrw, vim's builtin file explorer</h1><span class=post-date>2021-01-10 | 14 min read | <a href=https://vonheikemen.github.io/devlog/es/tools/using-netrw-vim-builtin-file-explorer/> Leer en español </a> </span><p>Did you know that vim has a file explorer? It's a plugin that comes bundled with vim. It's called Netrw... and it's not very popular, at least not if you compare it with something like NERDtree. The reasons for this could include 1) is not very intuitive. 2) has a few annoying limitations. 3) doesn't look cool. Today we are going to learn how to use it, how to get around those limitations and in the process we're going to turn it into something more intuitive and easier to use.<h2 id=meeting-netrw>Meeting Netrw</h2><p>Let's begin our exploration by taking a quick look at it. We can do this if we try to open a directory using vim (something like this: <code>vim .</code>). Assuming you don't have a heavily customized <code>vimrc</code>, Netrw should look like this.<p><img alt="netrw in full screen" src=https://res.cloudinary.com/vonheikemen/image/upload/v1609938838/devlog/using-vim-netrw/netrw-full-screen_2021-01-06_09-13-11.png><p>The first thing we see is a banner with information about the current directory. This is what is shows us.<ul><li>Information about Netrw, the name and version (v156).<li>The path of the current directory.<li>The criteria it's using to sort the files, in this case is doing it by name.<li>Another sort criteria. This time is a sequence that describes the priority it gives to a file according to its suffix.<li>"Quick help". In here you can see a few hints about actions that Netrw can perform.</ul><p>Fun fact, you can actually interact with some of the "options" in the banner. So, if you put the cursor on the line that says "sorted" and press <code>Enter</code> you'll change the order of the files. You can order them by name, last update, size or the extension of the file. And the quick help can show you keymaps for some common tasks.<p>After the banner we have our directories and files. <code>../</code> is the parent directory and <code>./</code> is the current directory. Lastly, we have our files sorted perfectly.<h2 id=usage>Usage</h2><p>Now that we now how Netrw looks like let's cover some of its basic features.<h3 id=how-to-call-it>How to call it</h3><p>Our first stop is the <code>:Explore</code> command. Using it with no arguments will show the directory of the file we are editing. If we don't want that we could give it the path to the directory we want. Depending on your vim config, specifically the <code>hidden</code> option, it will do things differently. If <code>hidden</code> is disabled (this is the default) and there are no unsaved changes in the current file, <code>:Explore</code> will make Netrw occupy the entire window. If we do have unsaved changes in a file it will create a horizontal split and have Netrw in the upper window.<p><img alt="netrw taking half the screen" src=https://res.cloudinary.com/vonheikemen/image/upload/v1609951259/devlog/using-vim-netrw/netrw-half-screen_2021-01-06_12-39-50.png><blockquote><p>If we wanted a vertical split we would use the <code>:Explore!</code> command.</blockquote><p>If <code>hidden</code> is enabled Netrw will always occupy the whole window.<p>Now let's talk about some <code>:Explore</code> variants we have available.<ul><li><p>Hexplore: Will create a horizontal split and show the directory in the lower window. The variant with an <code>!</code> will show the directory in the opposite side.</p><li><p>Vexplore: Will create a vertical split and show the directory on the left side. The variant with an <code>!</code> will show the directory in the opposite side.</p><li><p>Sexplore: Will create a horizontal split and show the directory in the upper window. The variant with an <code>!</code> will create a vertical split and show the directory on the left side.</p><li><p>Texplore: Will create a new tabpage to show the directory.</p><li><p>Lexplore: It works almost like <code>Vexplore</code>, but <code>Lexplore</code> will open a file on the window where we called the command. It will also work as way to toggle a Netrw window. You can watch it in action in this demo.</p></ul><p><script async data-preload=false data-size=small id=asciicast-Fa9y0AieDUImMHZjUbjKzjlwn src=https://asciinema.org/a/Fa9y0AieDUImMHZjUbjKzjlwn.js></script><blockquote><p>See in <a href=https://asciinema.org/a/Fa9y0AieDUImMHZjUbjKzjlwn rel=noopener target=_blank>asciinema</a>.</blockquote><h3 id=navigation>Navigation</h3><p>If we want to move between directories and files these are the keymaps we need to know:<ul><li><code>Enter</code>: Opens a directory or a file.<li><code>-</code>: Go up to the parent directory.<li><code>u</code>: Go back to the previous directory in the history.<li><code>gb</code>: Jump to the most recent directory saved on the "Bookmarks". To create a bookmark we use <code>mb</code>.</ul><p>Let's recap. If we want to "go down a directory" we use <code>Enter</code>. To "go up" we use <code>-</code>. To go back, <code>u</code>. And if we want to "jump" quickly to a directory of our choosing we should first add it to the bookmarks (using <code>mb</code>) and then we can use <code>gb</code> to go there.<h3 id=file-operations>File operations</h3><p>We know how to move, now let's see how can we perform some of the most common task on our files.<ul><li><p><code>p</code>: Opens a preview window.</p><li><p><code>&LTC-w>z</code>: <code>Ctrl + w</code> and then <code>z</code>. Closes the preview window.</p><li><p><code>gh</code>: Toggles the hidden files.</p><li><p><code>%</code>: Creates a file. Well... it actually doesn't, it just gives you the opportunity to create one. When you press <code>%</code> vim will ask the name you want to give the file and then it lets you edit it. After entering the name you have to save the file (using <code>:write</code>) to create it.</p><li><p><code>R</code>: Renames a file</p><li><p><code>mt</code>: Assign the "target directory" used by the move and copy commands.</p><li><p><code>mf</code>: Marks a file or directory. Any action that can be performed on multiple files depend on these marks. So if you want to copy, move or delete files, you need to mark them.</p><li><p><code>mc</code>: Copy the marked files in the target directory.</p><li><p><code>mm</code>: Move the marked files to the target directory.</p><li><p><code>mx</code>: Runs an external command on the marked files.</p><li><p><code>D</code>: Deletes a file or an empty directory. vim will not let us delete a non-empty directory. I'll show how to bypass this later on.</p><li><p><code>d</code>: Creates a directory.</p></ul><h3 id=perform-an-action-on-multiple-files>Perform an action on multiple files</h3><p>After reading about those keymaps I bet you're wondering how does one copy or move a file. I'll do an example moving some files around.<p>This will be a three step process:<ul><li><p>Assign the target directory.</p><li><p>Mark the files we want to move.</p><li><p>Run the appropriate command, in our case <code>mm</code>.</p></ul><p><script async data-preload=false data-size=small id=asciicast-YkvegGilPQpSbABrOcFZYhN7W src=https://asciinema.org/a/YkvegGilPQpSbABrOcFZYhN7W.js></script><blockquote><p>See in <a href=https://asciinema.org/a/YkvegGilPQpSbABrOcFZYhN7W rel=noopener target=_blank>asciinema</a>.</blockquote><p>This is what happens in the demo:<ul><li><p><em>00:00-00:17</em> I use <code>:Explore</code> to open Netrw. Then check the content of <code>test dir</code>.</p><li><p><em>00:18</em> I assign <code>test dir</code> as the target directory. Notice how the banner updates to show us the target directory. This line gets added.</p></ul><pre style=background:#2b2c2f;color:#cccece><code><span>"   Copy/Move Tgt: /tmp/vim/test dir/ (local)
</span></code></pre><ul><li><p><em>00:20-00:25</em> I mark the files <code>a-file.txt</code> and <code>another-file.txt</code>. To indicate they are marked vim shows us the name of the files in bold.</p><li><p><em>00:25-00:27</em> I press <code>mm</code> to move the files, and these disappear from the current window.</p><li><p><em>00:29</em> Now I check if the files are inside <code>test dir</code> (they are).</p></ul><p>And this is it, to copy and delete this is the process. To run external commands and delete files is the same thing, except we don't need a target directory.<h2 id=netrw-s-limitations>Netrw's limitations</h2><ul><li>When moving files.</ul><p>This happens on linux and maybe macOS is the same. In our previous example we moved <code>a-file.txt</code> to <code>test dir</code>, and that worked great, but if you try to move back <code>a-file.txt</code> to the parent directory you'll get this error.<pre style=background:#2b2c2f;color:#cccece><code><span>**error** (netrw) tried using g:netrw_localmovecmd&LTmv>; it doesn't work!
</span></code></pre><blockquote><p>This doesn't happen when you try to copy.</blockquote><p>As far as I know this happens when the current directory (in the buffer) and the directory we are browsing don't match. To fix this you can set the global variable <code>g:netrw_keepdir</code> to zero.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_keepdir = </span><span style=color:#f99157>0
</span></code></pre><ul><li>When performing an action on marked files.</ul><p>When you try to do something on marked files, the action only applies to the files that are listed in the current buffer.<p>Let's say we have this file structure.<pre style=background:#2b2c2f;color:#cccece><code><span>vim
</span><span>├── mini-plugins
</span><span>│   ├── better-netrw.vim
</span><span>│   ├── guess-indentation.vim
</span><span>│   └── project-buffers.vim
</span><span>├── test dir
</span><span>│   ├── a-file.txt *
</span><span>│   ├── another-file.txt *
</span><span>│   └── text.txt
</span><span>├── custom-commands.vim
</span><span>└── init.vim *
</span></code></pre><p>The files with an <code>*</code> are the ones we have marked. If we are in the <code>vim</code> directory and we try to move the files to <code>mini plugins</code> only <code>init.vim</code> will be in the target directory. In theory this is a good thing, because we will always have in sight the files we are operating on.<ul><li>Netrw can't delete non-empty directories using <code>D</code>.</ul><p>And of course the answer to this is: use an external command. If you paid attention on previous sections you'll know that the <code>mx</code> keymap can help us do just that. Here it is in action.<p><script async data-preload=false data-size=small id=asciicast-YbscBomZSa752kXnEASUnaxlx src=https://asciinema.org/a/YbscBomZSa752kXnEASUnaxlx.js></script><blockquote><p>See in <a href=https://asciinema.org/a/YbscBomZSa752kXnEASUnaxlx rel=noopener target=_blank>asciinema</a>.</blockquote><p>So just in case. The solution: mark the directories with <code>mf</code>, use <code>mx</code> and type the command you need (<code>rm -r</code> in the demo). That's it. But can we make this more convenient? Yes we can, and we are going to that in the next section.<h2 id=customization>Customization</h2><p>If you decided to give Netrw a chance you might want to make some tweaks to make it nicer.<h3 id=recommended-config>Recommended config</h3><p>Keep the current directory and the browsing directory synced. This helps you avoid the move files error.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_keepdir = </span><span style=color:#f99157>0
</span></code></pre><p>Change the size of the Netrw window when it creates a split. I think 30% is fine.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_winsize = </span><span style=color:#f99157>30
</span></code></pre><p>Hide the banner (if you want). To show it temporarily you can use <code>I</code> inside Netrw.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_banner = </span><span style=color:#f99157>0
</span></code></pre><p>Hide dotfiles on load.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_list_hide = </span><span style=color:#99c794>'\(^\|\s\s\)\zs\.\S\+'
</span></code></pre><p>Change the copy command. Mostly to enable recursive copy of directories.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>let </span><span>g:netrw_localcopydircmd = </span><span style=color:#99c794>'cp -r'
</span></code></pre><p>Highlight marked files in the same way search matches are.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>hi! link netrwMarkFile Search
</span></code></pre><blockquote><p>This is the easiest way I could think of to highlight marks. This may cause some confusion if you begin a search in Netrw and have marked files. If you wish to apply other colors search information about the <code>highlight</code> command.</blockquote><h3 id=keymaps>Keymaps</h3><p>Now that Netrw looks better-ish, let's make it easier to use.<h4 id=better-call-netrw>Better call Netrw</h4><p>We begin by changing the way we call Netrw. We bind <code>:Lexplore</code> to a shortcut so we can toggle it whenever we want.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nnoremap </span><span style=color:#fac863>&LTleader></span><span>dd :Lexplore %:p</span><span style=color:#c594c5>:</span><span>h</span><span style=color:#fac863>&LTCR>
</span><span style=color:#6699cc>nnoremap </span><span style=color:#fac863>&LTLeader></span><span style=color:#6699cc>da</span><span> :Lexplore</span><span style=color:#fac863>&LTCR>
</span></code></pre><ul><li><code>Leader dd</code>: Will open Netrw in the directory of the current file.<li><code>Leader da</code>: Will open Netrw in the current working directory.</ul><h4 id=navigation-1>Navigation</h4><p>Unfortunately we don't have a direct way to assign a keymap in Netrw. We can still have them but it does requires a few steps.<p>Netrw is a plugin that defines its own filetype, so we are going to use that to our advantage. What we are going to do is place our keymaps inside a function and create an <code>autocommand</code> that calls it everytime vim opens a filetype <code>netrw</code>.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>function! </span><span style=color:#6699cc>NetrwMapping</span><span style=color:#5fb3b3>(</span><span>)
</span><span>endfunction
</span><span>
</span><span style=color:#c594c5>augroup</span><span> netrw_mapping
</span><span>  </span><span style=color:#6699cc>autocmd</span><span>!
</span><span>  </span><span style=color:#6699cc>autocmd filetype</span><span> netrw call </span><span style=color:#6699cc>NetrwMapping</span><span>()
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><p>With this in our config all we have to do now is place the keymaps inside <code>NetrwMapping</code>. Like this.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>function! </span><span style=color:#6699cc>NetrwMapping</span><span style=color:#5fb3b3>(</span><span>)
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> H u
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> h -^
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> l </span><span style=color:#fac863>&LTCR>
</span><span>
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer> </span><span>. gh
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> P </span><span style=color:#fac863>&LTC-w></span><span>z
</span><span>
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> L </span><span style=color:#fac863>&LTCR></span><span>:Lexplore</span><span style=color:#fac863>&LTCR>
</span><span>  </span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer> &LTLeader></span><span>dd :Lexplore</span><span style=color:#fac863>&LTCR>
</span><span>endfunction
</span></code></pre><p>Since we don't have access to the functions Netrw uses internally (at least not all of them), we use <code>nmap</code> to make our keymaps. For example, <code>H</code> will be the same thing as pressing <code>u</code>, and <code>u</code> will trigger the command we want to execute. So this is what we have:<ul><li><code>H</code>: Will "go back" in history.<li><code>h</code>: Will "go up" a directory.<li><code>l</code>: Will open a directory or a file.<li><code>.</code>: Will toggle the dotfiles.<li><code>P</code>: Will close the preview window.<li><code>L</code>: Will open a file and close Netrw.<li><code>Leader dd</code>: Will just close Netrw.</ul><p>With these (plus the recommended config) Netrw can become a decent file explorer. But wait, we can still do more.<h4 id=marks>Marks</h4><p>Let's find a better way to manage the marks on files. I suggest using <code>&LTTab></code>.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer> &LTTAB></span><span> mf
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer> &LTS-TAB></span><span> mF
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer> &LTLeader>&LTTAB></span><span> mu
</span></code></pre><ul><li><code>Tab</code>: Toggles the mark on a file or directory.<li><code>Shift Tab</code>: Will unmark all the files in the current buffer.<li><code>Leader Tab</code>: Will remove all the marks on all files.</ul><h4 id=file-managing>File managing</h4><p>Since there are quite a few commands related to files we are going to use the <code>f</code> key as a prefix to group these together.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> ff %:w</span><span style=color:#fac863>&LTCR></span><span>:buffer #</span><span style=color:#fac863>&LTCR>
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fe R
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fc mc
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fC mtmc
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fx mm
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fX mtmm
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> f; mx
</span></code></pre><ul><li><code>ff</code>: Will create a file. But like create it for real. This time, after doing <code>%</code> we use <code>:w&LTCR></code> to save the empty file and <code>:buffer #&LTCR></code> to go back to Netrw.<li><code>fe</code>: Will rename a file.<li><code>fc</code>: Will copy the marked files.<li><code>fC</code>: We will use this to "skip" a step. After you mark your files you can put the cursor in a directory and this will assign the target directory and copy in one step.<li><code>fx</code>: Will move marked files.<li><code>fX</code>: Same thing as <code>fC</code> but for moving files.<li><code>f;</code>: Will be for running external commands on the marked files.</ul><p>We can still do a couple of things, if you don't mind using some of Netrw's internal variables.<p>Show a list of marked files.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fl :</span><span style=color:#6699cc>echo join</span><span>(</span><span style=color:#6699cc>netrw#Expose</span><span>(</span><span style=color:#99c794>"netrwmarkfilelist"</span><span>), </span><span style=color:#99c794>"\n"</span><span>)</span><span style=color:#fac863>&LTCR>
</span></code></pre><p>Show the target directory, just in case we want to avoid the banner.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fq :</span><span style=color:#6699cc>echo </span><span style=color:#99c794>'Target:' </span><span>. </span><span style=color:#6699cc>netrw#Expose</span><span>(</span><span style=color:#99c794>"netrwmftgt"</span><span>)</span><span style=color:#fac863>&LTCR>
</span></code></pre><p>Now we can use that along side <code>mt</code>.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> fd mtfq
</span></code></pre><p>Again, this is only useful if you really, really want to avoid showing the banner.<h4 id=bookmarks>Bookmarks</h4><p>In the same way we grouped the file related actions, we do it for bookmarks.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> bb mb
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> bd mB
</span><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> bl gb
</span></code></pre><ul><li><code>bb</code>: To create a bookmark.<li><code>bd</code>: To remove the most recent bookmark.<li><code>bl</code>: To jump to the most recent bookmark.</ul><h4 id=remove-files-recursively>Remove files recursively</h4><p>Last thing we will do is "automate" that process we did to remove non empty directories. For this we will need a function.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span>function! </span><span style=color:#6699cc>NetrwRemoveRecursive</span><span style=color:#5fb3b3>(</span><span>)
</span><span>  </span><span style=color:#c594c5>if </span><span>&filetype ==# </span><span style=color:#99c794>'netrw'
</span><span>    </span><span style=color:#6699cc>cnoremap </span><span style=color:#fac863>&LTbuffer> &LTCR></span><span> rm -r</span><span style=color:#fac863>&LTCR>
</span><span>    normal mu
</span><span>    normal mf
</span><span>    
</span><span>    </span><span style=color:#c594c5>try
</span><span>      normal mx
</span><span>    </span><span style=color:#c594c5>catch
</span><span>      </span><span style=color:#6699cc>echo </span><span style=color:#99c794>"Canceled"
</span><span>    </span><span style=color:#c594c5>endtry
</span><span>
</span><span>    </span><span style=color:#6699cc>cunmap </span><span style=color:#fac863>&LTbuffer> &LTCR>
</span><span>  </span><span style=color:#c594c5>endif
</span><span>endfunction
</span></code></pre><p>First thing we do in this function is check if we are in a buffer controlled by Netrw. Then we prepare the remove command. We take advantage of the fact that vim makes us drop to command mode and create a keymap (<code>&LTCR></code>) that will write the command for us. Next, we use <code>normal mu</code> to clear all the marks, 'cause we don't want to remove anything by accident. We then mark the directory under the cursor with <code>normal mf</code>. Here comes the funny part, <code>normal mx</code> will ask us what command we want to execute, and is at this point when we can abort the process using <code>ctrl + c</code> or press <code>Enter</code> which will trigger the command <code>rm -r</code>. Lastly, we undo the keymap we created in the beginning of the function, because it will be terrible to have it permanently.<p>And how do we use it?<p>Creating a keymap inside <code>NetrwMapping</code>, of course.<pre class=language-vim data-lang=vim style=background:#2b2c2f;color:#cccece><code class=language-vim data-lang=vim><span style=color:#6699cc>nmap </span><span style=color:#fac863>&LTbuffer></span><span> FF :call </span><span style=color:#6699cc>NetrwRemoveRecursive</span><span>()</span><span style=color:#fac863>&LTCR>
</span></code></pre><p>You can find every option and function in this article <a href=https://gist.github.com/VonHeikemen/fa6f7c7f114bc36326cda2c964cb52c7 rel=noopener target=_blank>here</a>.<h2 id=conclusion>Conclusion</h2><p>Netrw might not be the best file manager in the vim ecosystem but with a little effort we can turn it into an intuitive file explorer. Even if you don't adopt in Netrw in your workflow, knowing how to use it can be handy in some situations. You never know when you're going to be stuck in a remote server without your favorite vim plugins at hand.<h2 id=source>Source</h2><p><a href=https://vimhelp.org/pi_netrw.txt.html rel=noopener target=_blank>:help netrw</a><hr><p>Have any question? Feel free to leave a comment in one of these platform where I have shared this:<ul><li><a href=https://dev.to/vonheikemen/using-netrw-vim-s-builtin-file-explorer-16mb rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/using-netrw-vims-builtin-file-explorer rel=noopener target=_blank>Hashnode</a></ul><p>You can reach out to me on social media:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png style=height:60px!important;width:217px!important> </a></div></div>