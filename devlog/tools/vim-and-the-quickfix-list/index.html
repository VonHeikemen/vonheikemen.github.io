<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  vim and the quickfix list: jump to a location, search and replace in multiple files, and other shenanigans | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://vonheikemen.github.io/devlog/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="vim, shell, software, coding, development" name=keywords><meta content="The quickfix list and its use cases" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2025 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>vim and the quickfix list: jump to a location, search and replace in multiple files, and other shenanigans</h1><span class=post-date>2021-06-13 | 18 min read | <a href=https://vonheikemen.github.io/devlog/es/tools/vim-and-the-quickfix-list/> Leer en español </a> </span><p>We are going to learn about an avanced feature of vim, the quickfix list. We're going to figure out how to use it to search (and replace) a pattern in multiple files, and also how can we jump to the location of an error thrown by an external command.<h2 id=quickfix-list>Quickfix list</h2><p>Is a special mode where vim show us a list of positions, meaning line and column numbers in a file. This list was made to save the position of the errors we see in the error message of a compiler. This way we could jump quickly to this location, fix the bug and then go to the next or try to compile the code again.<p>My description can make it sound like a feature with a very minimal scope, but fear not, there is more to it than that. For starters the quickfix list can be created in different ways. We can create it with commands like <code>:make</code>, <code>:vimgrep</code> and <code>:grep</code>. And can also be created programatically with the help of the <code>setqflist</code> function, so we do have a great deal of flexibility.<p>I feel the need to tell you that when I say quickfix list I literally mean the list of positions. There are two ways we can see this list, we have the <code>quickfix window</code> and the <code>location list</code>. Both of these are "windows" in which the quickfix list is shown. The quickfix window is global, we can only have one in the current active vim session. Meanwhile, we can have many location lists in the current active vim session<h2 id=jump-to-a-location>Jump to a location</h2><p>So, our journey throught the wonderful quickfix list begins with the <code>:make</code> command, this is one of vim's native way of calling a compiler. But does the name <code>make</code> sound familiar to you? If so, I can assure you it is not a coincidence. vim does assume we have <a href=https://www.gnu.org/software/make/ rel=noopener target=_blank>make</a> installed on our system. How can you be sure? Well, let's make a test. Create a file called <code>Makefile</code> with the following content:<pre class=language-make data-lang=make style=color:#cccece;background-color:#2b2c2f><code class=language-make data-lang=make><span style=color:#69c>.PHONY</span><span style=color:#5fb3b3>: </span><span style=color:#99c794>test another
</span><span>
</span><span style=color:#69c>test</span><span style=color:#5fb3b3>:
</span><span>  </span><span style=color:#f99157>@</span><span style=color:#69c>echo </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'
</span><span>
</span><span style=color:#69c>another</span><span style=color:#5fb3b3>:
</span><span>  </span><span style=color:#f99157>@</span><span style=color:#69c>echo </span><span style=color:#5fb3b3>'</span><span style=color:#99c794>another</span><span style=color:#5fb3b3>'
</span></code></pre><blockquote><p>In this post I will not tell you how to use <code>make</code> but if you want to know how you can use it like a regular task runner you can <a href=https://vinta.ws/code/use-makefile-as-the-task-runner-for-arbitrary-projects.html rel=noopener target=_blank>read this one</a>.</blockquote><p>When you call the <code>:make</code> command you should get something like this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>hello
</span><span>
</span><span>(1 de 1): hello
</span></code></pre><p><code>make</code>'s default behaviour is to execute the first "task" it sees in our <code>Makefile</code>. Cool, but then how do we get it to execute <code>another</code>? We just provide more arguments to our command, like this: <code>:make [argument]</code>. If you try to execute <code>:make another</code> you should get this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>another
</span><span>
</span><span>(1 de 1): another
</span></code></pre><p>That's fine, but those commands don't output any error. After showing the messages nothing happens.<p>This is the perfect time for our first contrived example. Since vim knows how to "read" the errors <code>gcc</code> gives let me show you an example using C.<h3 id=an-example-in-c>An example in C</h3><p>So let's create a file <code>hello.c</code> with this.<pre class=language-c data-lang=c style=color:#cccece;background-color:#2b2c2f><code class=language-c data-lang=c><span style=color:#c594c5>#include </span><span style=color:#5fb3b3>&lt;</span><span style=color:#99c794>stdio.h</span><span style=color:#5fb3b3>>
</span><span>
</span><span style=color:#c594c5>int </span><span style=color:#69c>main</span><span style=color:#5fb3b3>() {
</span><span>   </span><span style=color:#69c>printf</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>Hello, World!</span><span style=color:#5fb3b3>\n");
</span><span>   </span><span style=color:#c594c5>return </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Notice that there is nothing wrong here. We can compile this thing easily using <code>make</code>. So our next step will be to create a <code>Makefile</code>.<pre class=language-make data-lang=make style=color:#cccece;background-color:#2b2c2f><code class=language-make data-lang=make><span style=color:#69c>.PHONY</span><span style=color:#5fb3b3>: </span><span style=color:#99c794>run-hello
</span><span>
</span><span style=color:#69c>run-hello</span><span style=color:#5fb3b3>:
</span><span>  </span><span style=color:#69c>gcc</span><span style=color:#5fb3b3> -</span><span style=color:#f99157>Wall</span><span style=color:#5fb3b3> -</span><span style=color:#f99157>o</span><span style=color:#69c> hello hello.c
</span><span>  </span><span style=color:#69c>./hello
</span><span>  </span><span style=color:#69c>rm ./hello 
</span></code></pre><p>With everything in place, we can run <code>:make --silent run-hello</code>. If we did everything right we should have our <code>hello world</code>.<pre style=color:#cccece;background-color:#2b2c2f><code><span>Hello, World!
</span><span>
</span><span>(1 de 1): Hello, World!
</span></code></pre><p>If we introduce an error, like say delete a semicolon, this is what we should get.<pre style=color:#cccece;background-color:#2b2c2f><code><span>hello.c: In function ‘main’:
</span><span>hello.c:4:28: error: expected ‘;’ before ‘return’
</span><span>    printf("Hello, World!\n")
</span><span>                            ^
</span><span>                            ;
</span><span>    return 0;
</span><span>    ~~~~~~
</span><span>make: *** [Makefile:7: run-hello] Error 1
</span><span>
</span><span>(2 de 8): error: expected ‘;’ before ‘return’
</span></code></pre><p>After showing this message you'll notice that vim took you to the location of the error (how cool is that?). If you want to check the content of the quickfix list you'll need to open the quickfix window using the <code>:copen</code> command. You should have something like this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>|| hello.c: In function ‘main’:
</span><span>hello.c|4 col 28| error: expected ‘;’ before ‘return’                  
</span><span>||     printf("Hello, World!\n")
</span><span>||                             ^
</span><span>||                             ;
</span><span>||     return 0;
</span><span>||     ~~~~~~
</span><span>make: *** [Makefile|7| run-hello] Error 1
</span></code></pre><blockquote><p>To close the quickfix window we use the <code>:cclose</code> command.</blockquote><p>Now pay attention to this line.<pre style=color:#cccece;background-color:#2b2c2f><code><span>hello.c|4 col 28| error: expected ‘;’ before ‘return’
</span></code></pre><p>In here vim is telling us where is the error, it's showing the file name, the line and the column. Right now what we should do is fix the bug and try to compile again. For the most part this is the workflow that we want. But if you do have more than one item in the quickfix list you could navigate between them using the commands <code>:cnext</code> and <code>:cprev</code>, to go forward and backwards in the quickfix list.<p>This is nice and all but what happens if we don't use <code>gcc</code>? What if we use <code>nodejs</code>? Could vim handle it? Yes, with some help.<h3 id=errorformat>errorformat</h3><p>If you start using other compilers or interpreters you'll notice that vim can't read properly all the error messages they give you. To overcome this vim offers an option called <code>errorformat</code>, a variable that can store the "shape" of an error message, this way vim can recognize it when they appear in the quickfix list.<p>To test this thing let's try make vim read the errors <code>node</code> shows us. Start by creating a file called <code>greeting.js</code> and make a simple "hello world" that has an error.<pre class=language-js data-lang=js style=color:#cccece;background-color:#2b2c2f><code class=language-js data-lang=js><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>(greeting)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>greeting </span><span style=color:#5fb3b3>= '</span><span style=color:#99c794>Hello, World!</span><span style=color:#5fb3b3>';
</span></code></pre><p>Now in our <code>Makefile</code> let's add another task.<pre class=language-make data-lang=make style=color:#cccece;background-color:#2b2c2f><code class=language-make data-lang=make><span style=color:#69c>run-greeting</span><span style=color:#5fb3b3>:
</span><span>  </span><span style=color:#69c>node ./greeting.js
</span></code></pre><p>If we try to run <code>:make --silent run-greeting</code> we'll get this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>console.log(greeting);
</span><span>            ^
</span><span>
</span><span>ReferenceError: Cannot access 'greeting' before initialization
</span><span>    at Object.&lt;anonymous> (/tmp/test/greeting.js:1:13)
</span><span>    at Module._compile (internal/modules/cjs/loader.js:1063:30)
</span><span>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
</span><span>    at Module.load (internal/modules/cjs/loader.js:928:32)
</span><span>    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
</span><span>    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
</span><span>    at internal/main/run_main_module.js:17:47
</span><span>make: *** [Makefile:4: run-greeting] Error 1
</span></code></pre><p>vim will try to take us to the location of the error but it is not likely to succeed. In my case, it tried to take me to a file it doesn't exists.<p>To fix this we need to tell vim how to read these messages. I'm going to show one way of doing it.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat=%E%.%#ReferenceError:\ %m,%Z%.%#%at\ Object.</span><span style=color:#fac863>&lt;anonymous></span><span>\ (%f:%l:%c)
</span></code></pre><p>In here we specify the "shape" of each line in the error message or at least the ones we care about. Each line has its own format and must be separated by a coma. That means...<pre style=color:#cccece;background-color:#2b2c2f><code><span>%E%.%#ReferenceError:\ %m
</span></code></pre><p>And<pre style=color:#cccece;background-color:#2b2c2f><code><span>%Z%.%#%at\ Object.&lt;anonymous>\ (%f:%l:%c)
</span></code></pre><p>Are two expressions that tell vim how to read the error message. We are telling vim where it can find the type of the error (<code>ReferenceError</code>) and where is the location data of the error. In our example those two things are in separate lines so we must have these expressions separated by a coma.<p>If we want to improve readability we could also try to write it this way.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat=%E%.%#ReferenceError:\ %m
</span><span style=color:#69c>set</span><span> errorformat+=%Z%.%#%at\ Object.</span><span style=color:#fac863>&lt;anonymous></span><span>\ (%f:%l:%c)
</span></code></pre><p>When we do it this way we don't need to put the coma at the end. But we still need a <code>\</code> before each special character (like a blank space) so there is no conflict between vim's syntax and the error format. If you find that annoying you could try another way.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>&errorformat = 
</span><span>  \ </span><span style=color:#99c794>'%E%.%#ReferenceError: %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%Z%.%#at Object.&lt;anonymous> (%f:%l:%c)'
</span></code></pre><p>When we use <code>let</code> we have the oportunity to use strings to write our formats, avoiding any sort of conflict between vim's syntax and the <code>errorformat</code>. To further improve readability I have every expression in its own line, taking advantage of the <code>.</code> operator to concat these strings.<p>Now if we try to run <code>:make --silent run-greeting</code> vim will take us to the right place, which is where <code>node</code> says the error is. The quickfix should show us this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>|| /tmp/test/greeting.js:1
</span><span>|| console.log(greeting);
</span><span>||             ^
</span><span>|| 
</span><span>greeting.js|1 col 13 error| Cannot access 'greeting' before initialization
</span><span>||     at Module._compile (internal/modules/cjs/loader.js:1063:30)
</span><span>||     at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
</span><span>||     at Module.load (internal/modules/cjs/loader.js:928:32)
</span><span>||     at Function.Module._load (internal/modules/cjs/loader.js:769:14)
</span><span>||     at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
</span><span>||     at internal/main/run_main_module.js:17:47
</span><span>|| make: *** [Makefile:4: run-greeting] Error 1
</span></code></pre><p>Now the <code>ReferenceError</code> is no longer on the quickfix list, neither the line that was below. Those has been replaced with this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>greeting.js|1 col 13 error| Cannot access 'greeting' before initialization
</span></code></pre><p>If vim shows that, it means the <code>errorformat</code> worked.<p>We have a bit of an issue, those two expressions will only work with a <code>ReferenceError</code> type. You probably need more than that in your day to day workflow. We should really have something like this.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>&errorformat = 
</span><span>  \ </span><span style=color:#99c794>'%E%.%#AssertionError %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%E%.%#TypeError: %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%E%.%#ReferenceError: %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%E%.%#SyntaxError: %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%E%.%#RangeError: %m,' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%Z%.%#at Object.&lt;anonymous> (%f:%l:%c),' </span><span>.
</span><span>  \ </span><span style=color:#99c794>'%-G%.%#'
</span></code></pre><h4 id=special-tokens>Special tokens</h4><p>That's a lot weird stuff, stuff you might want to know about. Let's dive a little bit into the syntax I use in that last example.<ul><li><p><code>%f</code>: Is the filepath where the error was found.</p><li><p><code>%l</code>: Is the line number where the error was found.</p><li><p><code>%c</code>: Is the column number where the error was found.</p><li><p><code>%m</code>: Is the error message. In our example we use it to capture the text that's right after the type of the error.</p><li><p><code>%E</code>: Tells vim this is the beginning of a multi-line error message. The letter <code>E</code> means this is an error. There other types of messages like warnings (<code>%W</code>), informative (<code>%I</code>) or general purpose (<code>%G</code>).</p><li><p><code>%Z</code>: Means is the end of the message. Specifically, that is the last line of the message.</p><li><p><code>%.%#</code>: This one is a wildcard, one that matches everything. So, you could read <code>%Z%.%#at Object.&lt;anonymous> (%f:%l:%c)</code> like this: The last line of this message (<code>%Z</code>) can start with anything (<code>%.%#</code>) followed by <code>at Object.&lt;anonymous></code> and in parenthesis you'll find the filepath (<code>%f</code>), the line number (<code>%l</code>) and the column (<code>%c</code>) where the error was found.</p><li><p><code>%-</code>: Tells vim it should exclude this piece from the quickfix window. <code>%-G</code> could be read like "don't include this message." In our example we use <code>%-G%.%#</code> which means "ignore everything else." Now, since <code>%.%#</code> matches everything, we put this expression last.</p></ul><p>If you want to know more about the special tokens the <code>errorformat</code> can have run the command <code>:help errorformat</code>.<h3 id=makeprg>makeprg</h3><p>By now you know you can make vim read any type of error but the current configuration is still tied to <code>make</code>. It doesn't have to be like that. We can change the command vim calls when we run <code>:make</code>.<p>Let's say we want to use <code>node</code>, just <code>node</code>, to achieve this we need to change the option <code>makeprg</code>.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> makeprg=node
</span></code></pre><p>Or we can do.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>let </span><span>&makeprg = </span><span style=color:#99c794>'node'
</span></code></pre><p>Now instead of using <code>:make --silet run-greeting</code> we can run <code>:make ./greeting.js</code> or <code>:make %</code> if we are already editing <code>greeting.js</code>.<h2 id=search>Search</h2><p>Jumping to an error is not the only feature of the quickfix list, we can also use it to explore the code we are working on. For this vim has commands like <code>:grep</code> and <code>:vimgrep</code>, they create a quickfix list with the results of a search.<h3 id=vimgrep>vimgrep</h3><p>With this command we can take advantage of the built-in search engine that comes with vim. It is very much like the good old <a href=https://linux.die.net/man/1/grep rel=noopener target=_blank>grep</a>, but the <code>:vimgrep</code> command uses vim's regex engine. Basically <code>:vimgrep</code> is what we'll use when we want to search a pattern (a regular expression) in multiple files. This is how you use it.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:vimgrep </span><span style=color:#5fb3b3>/&lt;pattern>/ </span><span style=color:#fac863>&lt;files>
</span></code></pre><p>The <code>/</code> in the pattern are not mandatory, but they are useful when your pattern has characters that cause a conflict with vim's syntax. Like in this example.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:vimgrep </span><span style=color:#5fb3b3>/create table/</span><span> db</span><span style=color:#5fb3b3>/**/</span><span>*.sql
</span></code></pre><p>Here we are searching the pattern <code>create table</code> in a folder called <code>db</code>. And we are searching only in the files that end with <code>.sql</code> extension<p>These delimeters we use in the search pattern don't have to be <code>/</code>. They could be anything that vim doesn't consider to be an "identifier". Find out more about identifiers in the documentation, using the command <code>:help isident</code>. This is specially useful when our search pattern already has a <code>/</code>. Imagine we are searching for a path in our code, we could write our search like this.<pre style=color:#cccece;background-color:#2b2c2f><code><span>:vimgrep #/home/user/code# scripts/*.sh
</span></code></pre><p>But what happens when we want to ignore a whole directory in our search? There are several solutions. For starters we could set the option <code>wildignore</code>. Say we want to ignore a <code>cache</code> and <code>tmp</code> directories, we could set <code>wildignore</code> to something like this.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:</span><span style=color:#69c>set</span><span> wildignore=*</span><span style=color:#5fb3b3>/cache/</span><span>*,*</span><span style=color:#5fb3b3>/tmp/</span><span>*
</span></code></pre><p>As far as I can tell <code>wildignore</code> tells vim the paths that should be excluded when doing a path expansion. For example, if we use this pattern <code>**/*.js</code> vim will exclude any directory that has <code>/cache/</code> or <code>/tmp/</code> anywhere in its path. So <code>:vimgrep</code> will not search these directories because it will never receive them as arguments. This means <code>wildignore</code> can affect other commands, and not just <code>:vimgrep</code>.<p>Some <em>stackoverflow</em> questions suggest this method may not work all the time. In that case we can try to create the argument list with a backtick expression, these will let you call an external command with your shell. We could for example search only on files tracked by git, like this.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:vimgrep </span><span style=color:#5fb3b3>/function/</span><span> `git ls-files`
</span></code></pre><p>In this case <code>git ls-files</code> will give us a list file path which will then be processed by <code>:vimgrep</code>. Isn't that cool? The best part is that as long as <code>:vimgrep</code> gets a valid a file list everything will work as expected.<h3 id=grep>grep</h3><p>And then there is the <code>:grep</code> command. This is vim's way of integrating with the search utility <code>grep</code>. This command works almost like <code>:vimgrep</code> but this time we need to use a "syntax" that is compatible with <code>grep</code>. Take this example.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:grep -r </span><span style=color:#99c794>"create table"</span><span> db</span><span style=color:#5fb3b3>/**/</span><span>*.sql
</span></code></pre><p>Notice I'm not using <code>/</code> as delimeters, also I'm adding the <code>-r</code> flag (to enable a recursive search), this is because vim calls <code>grep</code> in a non-interactive shell and gives all the arguments to <code>grep</code> as is.<p>But now the question is "when should we use <code>:grep</code> instead of <code>:vimgrep</code>?" Turns out <code>:grep</code> is much faster and efficient than <code>:vimgrep</code>. So, <code>:grep</code> would be the better choice if your search involves lots of files.<p>Okay, that's fine. What about the opposite? What advantage <code>:vimgrep</code> has over <code>:grep</code>? Not much I'd say. If you're more familiar with vim's regular expressions maybe that would be a reason to choose <code>:vimgrep</code>. <code>:vimgrep</code> also works fine on all platforms, since it's all done inside vim.<p>Cross-platform support. That's a problem with <code>:grep</code>, how does vim solve it? Well, in the same way <code>:make</code> does. We can configure the external command vim calls with the variable <code>grepprg</code>. Say that instead of using <code>grep</code> we want to use <a href=https://github.com/BurntSushi/ripgrep rel=noopener target=_blank>ripgrep</a>, in order to do that we add this to our config.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> grepprg=rg\ --vimgrep\ --smart-case\ --follow
</span></code></pre><p>With that in place vim will use <code>rg</code> with all those arguments included when we invoke <code>:grep</code>.<h3 id=special-guess-fzf>Special guess: FZF</h3><p>The last external search tool I'll mention is <a href=https://github.com/junegunn/fzf.vim rel=noopener target=_blank>fzf.vim</a>. This is a plugin that provides an interface where we can execute an interactive search. I won't get into any details here. Just going to tell you something I found out long after I started using it.<p>Turns out we can populate the quickfix list using FZF, specifically with the results of commands like <code>:Rg</code> or <code>:Ag</code>. After doing a search you'll have all the matches inside a list ready to be filtered, it's here when you can select an item using <code>tab</code> or select all using <code>Alt + a</code>, then press <code>enter</code>. After this the quickfix list will have every item you selected. This little feature is very useful when you want to execute a certain command only on specific parts of your code using <code>:cdo</code>.<h2 id=replace>Replace</h2><p>Speaking of <code>:cdo</code>, let me show you one cool thing we can do with it: search and replace in multiple files. If you ever wondered how to do this in vim, the answer is the quickfix list and the <code>:cdo</code> command.<p>In a simple case where all we want to do is replace a known pattern this is what we do:<ul><li>Step 1:</ul><p>Use our favorite search command <code>:grep</code>, <code>:vimgrep</code> or anything that can populate the quickfix list.<ul><li>Step 2 (optional):</ul><p>Open the quickfix window using <code>:copen</code><ul><li>Step 3:</ul><p>Use <code>:cdo</code> to execute a command on every item in the quickfix list. In our case what we want to do is replace the pattern, which we can do using this syntax <code>s/{pattern}/{replacement}</code>.<p>Say that our quickfix list is filled with the results of this search.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:vimgrep node **/*.js
</span></code></pre><p>Once that is done we can replace the word <code>node</code> with <code>deno</code> using this command.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:cdo s</span><span style=color:#5fb3b3>/node/</span><span>deno/ | update
</span></code></pre><p>With it vim will run the command <code>s/node/deno | update</code> on every item in the quickfix list. We take advantage of the fact <code>:cdo</code> can execute any valid vim command and actually do two things, we replace the pattern <code>node</code> and save the changes to the file.<h3 id=a-more-advanced-use-case>A more advanced use case</h3><p>Now let's take it one step further, suppose we want to replace some pattern but before doing anything we want filter the results so we only change some parts of our code. Basically we don't want to replace all the matches of a search. How do we do it? One way would be changing the quickfix list so it only has the items we want to replace.<p>This process will take a bit of effort. First, we need to tell vim how to read its own quickfix list, so we can create modified versions of other quickfix lists. To achieve our goal we need to add a pattern to the <code>errorformat</code> option. So in your <code>.vimrc</code> you should have something like this.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>set</span><span> errorformat+=%f\|%l\ col\ %c\|%m
</span></code></pre><p>We are one step closer but it's still not enough, vim will not let us change the quickfix list. For this we need to be able to write to the buffer where the quickfix list is. We need to run this command.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:</span><span style=color:#69c>set</span><span> modifiable
</span></code></pre><p>Once we do that we can delete the items we want, but we can't run <code>:cdo</code> just yet. We need to save the changes we've made with this command.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:cgetbuffer
</span></code></pre><p>Next, just to be on the safe side, make sure you're going to perform the actions on the correct version of the quickfix list. Run, <code>:cclose</code> and <code>:copen</code>.<p>Finally you can execute the substitute command.<p>Here is a demo of the whole process.<p><script async data-preload=false data-size=small id=asciicast-385145 src=https://asciinema.org/a/385145.js></script><blockquote><p>See in <a href=https://asciinema.org/a/385145 rel=noopener target=_blank>asciinema</a>.</blockquote><h2 id=improving-the-experience>Improving the experience</h2><p>As you might have noticed the quickfix list is not the most intuitive thing in the world. But we can make it better. I can give you a few suggestions you can add to your <code>.vimrc</code>.<ul><li>A better grep.</ul><p>First thing you might want to do is make vim open the quickfix window after doing a search. Lucky for us the official documentation offers something we can use:<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>command</span><span>! </span><span style=color:#fac863>-nargs=</span><span>+ Grep </span><span style=color:#69c>execute </span><span style=color:#99c794>'silent grep! &lt;args>'</span><span> | copen
</span></code></pre><p>I think in this case you could change <code>grep</code> with <code>vimgrep</code> if you wanted to. The important thing is, with this now you could use <code>:Grep</code> (with capital <code>G</code>) to make your search.<ul><li>Navigating throught the results.</ul><p>We could "navigate" throught every item in the quickfix list without even opening the quickfix window with this shortcuts.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#5f6364>" Go to the previous location
</span><span style=color:#69c>nnoremap</span><span> [q :cprev</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>" Go to the next location
</span><span style=color:#69c>nnoremap</span><span> ]q :cnext</span><span style=color:#fac863>&lt;CR>
</span></code></pre><ul><li>Manage your window.</ul><p>If your going to use the quickfix window you better have some keybindings to show and hide it easily.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#5f6364>" Show the quickfix window
</span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader></span><span>co :copen</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>" Hide the quickfix window
</span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader></span><span>cc :cclose</span><span style=color:#fac863>&lt;CR>
</span></code></pre><ul><li>The errorformat.</ul><p>Let's make sure vim can always read the format on the quickfix list when we want to update it.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#c594c5>augroup</span><span> quickfix_group
</span><span>  </span><span style=color:#69c>autocmd</span><span>!
</span><span>  </span><span style=color:#69c>autocmd filetype</span><span> qf </span><span style=color:#69c>setlocal</span><span> errorformat+=%f\|%l\ col\ %c\|%m
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><ul><li>Keybindings</ul><p>We'll also need some keybindings that only work on the quickfix window. You know, so the "advance use case" won't be so tedious.<pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>function! </span><span style=color:#69c>QuickfixMapping</span><span style=color:#5fb3b3>(</span><span>)
</span><span style=color:#5f6364>  " Go to the previous location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer></span><span> K :cprev</span><span style=color:#fac863>&lt;CR></span><span>zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>
</span><span style=color:#5f6364>  " Go to the next location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer></span><span> J :cnext</span><span style=color:#fac863>&lt;CR></span><span>zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>
</span><span style=color:#5f6364>  " Make the quickfix list modifiable
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>u :</span><span style=color:#69c>set</span><span> modifiable</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>  " Save the changes in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>w :cgetbuffer</span><span style=color:#fac863>&lt;CR></span><span>:cclose</span><span style=color:#fac863>&lt;CR></span><span>:copen</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>  " Begin the search and replace
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>r :cdo s</span><span style=color:#5fb3b3>//</span><span>/ \| update</span><span style=color:#fac863>&lt;C-Left>&lt;C-Left>&lt;Left>&lt;Left>&lt;Left>
</span><span>endfunction
</span><span>
</span><span style=color:#c594c5>augroup</span><span> quickfix_group
</span><span>    </span><span style=color:#69c>autocmd</span><span>!
</span><span>    </span><span style=color:#69c>autocmd filetype</span><span> qf call </span><span style=color:#69c>QuickfixMapping</span><span>()
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><ul><li>Now everything put together.</ul><pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#5f6364>" :Grep - search and then open the window
</span><span style=color:#69c>command</span><span>! </span><span style=color:#fac863>-nargs=</span><span>+ Grep </span><span style=color:#69c>execute </span><span style=color:#99c794>'silent grep! &lt;args>'</span><span> | copen
</span><span>
</span><span style=color:#5f6364>" Go to the previous location
</span><span style=color:#69c>nnoremap</span><span> [q :cprev</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>" Go to the next location
</span><span style=color:#69c>nnoremap</span><span> ]q :cnext</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>" Show the quickfix window
</span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader></span><span>co :copen</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>" Hide the quickfix window
</span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;Leader></span><span>cc :cclose</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span>function! </span><span style=color:#69c>QuickfixMapping</span><span style=color:#5fb3b3>(</span><span>)
</span><span style=color:#5f6364>  " Go to the previous location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer></span><span> K :cprev</span><span style=color:#fac863>&lt;CR></span><span>zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>
</span><span style=color:#5f6364>  " Go to the next location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer></span><span> J :cnext</span><span style=color:#fac863>&lt;CR></span><span>zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>
</span><span style=color:#5f6364>  " Make the quickfix list modifiable
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>u :</span><span style=color:#69c>set</span><span> modifiable</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>  " Save the changes in the quickfix window
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>w :cgetbuffer</span><span style=color:#fac863>&lt;CR></span><span>:cclose</span><span style=color:#fac863>&lt;CR></span><span>:copen</span><span style=color:#fac863>&lt;CR>
</span><span>
</span><span style=color:#5f6364>  " Begin the search and replace
</span><span>  </span><span style=color:#69c>nnoremap </span><span style=color:#fac863>&lt;buffer> &lt;leader></span><span>r :cdo s</span><span style=color:#5fb3b3>//</span><span>/ \| update</span><span style=color:#fac863>&lt;C-Left>&lt;C-Left>&lt;Left>&lt;Left>&lt;Left>
</span><span>endfunction
</span><span>
</span><span style=color:#c594c5>augroup</span><span> quickfix_group
</span><span>  </span><span style=color:#69c>autocmd</span><span>!
</span><span>  
</span><span style=color:#5f6364>  " Use custom keybindings
</span><span>  </span><span style=color:#69c>autocmd filetype</span><span> qf call </span><span style=color:#69c>QuickfixMapping</span><span>()
</span><span>  
</span><span style=color:#5f6364>  " Add the errorformat to be able to update the quickfix list
</span><span>  </span><span style=color:#69c>autocmd filetype</span><span> qf </span><span style=color:#69c>setlocal</span><span> errorformat+=%f\|%l\ col\ %c\|%m
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><h3 id=plugins>Plugins</h3><p>If you know how and you're willing to install some plugins I'd recommend these:<ul><li><a href=https://github.com/romainl/vim-qf rel=noopener target=_blank>vim-qf</a></ul><p>This one sets some sane defaults to the behaviour of the quickfix window. For example, it can open the quickfix window after calling <code>:grep</code>, <code>:vimgrep</code> and even <code>:vimgrep</code> without having to create new commands. Things don't end there, it also offers some functions we can bind.<ul><li>Toggle the quickfix window.</ul><pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#69c>nmap </span><span style=color:#fac863>&lt;Leader></span><span>cc </span><span style=color:#fac863>&lt;Plug></span><span>(qf_qf_toggle)
</span></code></pre><ul><li>Navigating throught results</ul><pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span style=color:#5f6364>" Go to previous location
</span><span style=color:#69c>nmap</span><span> [q </span><span style=color:#fac863>&lt;Plug></span><span>(qf_qf_previous)zz
</span><span>
</span><span style=color:#5f6364>" Go to next location
</span><span style=color:#69c>nmap</span><span> ]q </span><span style=color:#fac863>&lt;Plug></span><span>(qf_qf_next)zz
</span><span>
</span><span>function! </span><span style=color:#69c>QuickfixMapping</span><span style=color:#5fb3b3>(</span><span>)
</span><span style=color:#5f6364>  " Go to the previous location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nmap </span><span style=color:#fac863>&lt;buffer></span><span> K </span><span style=color:#fac863>&lt;Plug></span><span>(qf_qf_previous)zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>
</span><span style=color:#5f6364>  " Go to the next location and stay in the quickfix window
</span><span>  </span><span style=color:#69c>nmap </span><span style=color:#fac863>&lt;buffer></span><span> J </span><span style=color:#fac863>&lt;Plug></span><span>(qf_qf_next)zz</span><span style=color:#fac863>&lt;C-w></span><span>w
</span><span>endfunction
</span><span>
</span><span style=color:#c594c5>augroup</span><span> quickfix_group
</span><span>    </span><span style=color:#69c>autocmd</span><span>!
</span><span>    </span><span style=color:#69c>autocmd filetype</span><span> qf call </span><span style=color:#69c>QuickfixMapping</span><span>()
</span><span style=color:#c594c5>augroup</span><span> END
</span></code></pre><p>The difference between these command and the built-in vim commands is, the plugin commands will not throw an error when we reach the end of the list. Meaning that if we are on last location of the list pressing <code>]q</code> will take us to the first item in the quickfix list.<ul><li><a href=https://github.com/stefandtw/quickfix-reflector.vim rel=noopener target=_blank>quickfix-reflector</a></ul><p>This plugin makes everything I told you in the "advanced use case" section be useless. Once is installed the buffer in the quickfix window acts like a normal buffer. On top of that, every change we make is "reflected" on the actual file.<p>Remember the example I showed in the demo. Say we have this on the quickfix list.<pre style=color:#cccece;background-color:#2b2c2f><code><span>./test dir/a-file.txt|1 col 11| nnoremap &lt;leader>f :FZF
</span><span>./test dir/a-file.txt|2 col 11| nnoremap &lt;leader>ff :FZF&lt;CR>
</span><span>./test dir/a-file.txt|3 col 11| nnoremap &lt;leader>fh :History&lt;CR>
</span><span>./test dir 2/another-file.txt|1 col 11| nnoremap &lt;leader>? :Maps&lt;CR>
</span><span>./test dir 2/another-file.txt|2 col 11| nnoremap &lt;leader>bb :Buffers&lt;CR>
</span></code></pre><p>Now say I modify the list, delete the first and fourth item using <code>dd</code>.<pre class=language-diff data-lang=diff style=color:#cccece;background-color:#2b2c2f><code class=language-diff data-lang=diff><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> ./test dir/a-file.txt|1 col 11| nnoremap &lt;leader>f :FZF
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> ./test dir/a-file.txt|1 col 11| nnoremap &lt;AAA>f :FZF
</span><span>  ./test dir/a-file.txt|2 col 11| nnoremap &lt;leader>ff :FZF&lt;CR>
</span><span>  ./test dir/a-file.txt|3 col 11| nnoremap &lt;leader>fh :History&lt;CR>
</span><span style=color:#5fb3b3>-</span><span style=color:#ec5f67> ./test dir 2/another-file.txt|1 col 11| nnoremap &lt;leader>? :Maps&lt;CR>
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794> ./test dir 2/another-file.txt|1 col 11| nnoremap &lt;BBB>? :Maps&lt;CR>
</span><span>  ./test dir 2/another-file.txt|2 col 11| nnoremap &lt;leader>bb :Buffers&lt;CR>
</span></code></pre><p>If I save these changes with the <code>:write</code> command (or the short version <code>:w</code>) they will take effect on their respective files. This gives us great power and flexibility because now the changes we can make are only limited by our knowledge of vim.<p>Any trick you can think that can modify chunks of code should work flawlessly with this plugin. For example if we want to make the same thing I did in the demo we would do it like this:<ul><li>Delete the lines we don't want to change</ul><pre style=color:#cccece;background-color:#2b2c2f><code><span>./test dir/a-file.txt|1 col 11| nnoremap &lt;leader>f :FZF
</span><span>./test dir/a-file.txt|3 col 11| nnoremap &lt;leader>fh :History&lt;CR>
</span><span>./test dir 2/another-file.txt|1 col 11| nnoremap &lt;leader>? :Maps&lt;CR>
</span></code></pre><ul><li>Use the "regular" substitution command.</ul><pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:%s</span><span style=color:#5fb3b3>/leader/</span><span>localleader/g
</span></code></pre><p>After that quickfix list should be on this state.<pre style=color:#cccece;background-color:#2b2c2f><code><span>./test dir/a-file.txt|1 col 11| nnoremap &lt;localleader>f :FZF
</span><span>./test dir/a-file.txt|3 col 11| nnoremap &lt;localleader>fh :History&lt;CR>
</span><span>./test dir 2/another-file.txt|1 col 11| nnoremap &lt;localleader>? :Maps&lt;CR>
</span></code></pre><ul><li>Save the changes.</ul><pre class=language-vim data-lang=vim style=color:#cccece;background-color:#2b2c2f><code class=language-vim data-lang=vim><span>:write
</span></code></pre><p>And that's it.<h2 id=conclusion>Conclusion</h2><p>We got to know what is the quickfix list and its most common use cases.<p>Now we know we can use <code>:make</code> to call any compiler or external command that can run our code and give us error messages. We also have the tools to "teach" vim how to read an error message and put all the information we need in the quickfix list.<p>We learned that we can use <code>:vimgrep</code> and <code>:grep</code> to search patterns in multiple files in our project. We had the chance to explore a few methods to search and replace text, with some simple cases and another one slightly more complex. With these examples we learned how to replace text with and without plugins.<p>Lastly we learned about some options and commands we can use in our <code>.vimrc</code> to improve the user experience when we use the quickfix list.<h2 id=sources>Sources</h2><ul><li><a href=https://vimhelp.org/quickfix.txt.html rel=noopener target=_blank>:help quickfix</a><li><a href=https://www.reddit.com/r/vim/comments/7dv9as/how_to_edit_the_vim_quickfix_list/ rel=noopener target=_blank>How to edit the vim quickfix list</a></ul><hr><p>Have any question? Feel free to leave a comment in one of these platform where I have shared this:<ul><li><a href=https://dev.to/vonheikemen/vim-and-the-quickfix-list-jump-to-a-location-search-and-replace-in-multiple-files-and-other-shenanigans-3ki8 rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/vim-and-the-quickfix-list rel=noopener target=_blank>Hashnode</a></ul><p>You can reach out to me on social media:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Bluesky <a rel="noopener me" href=https://bsky.app/profile/vonheikemen.bsky.social target=_blank> @vonheikemen.bsky.social </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://ko-fi.com/vonheikemen style=justify-content:center;display:flex target=_blank> <img alt="Buy Me A Coffee" src="https://storage.ko-fi.com/cdn/kofi2.png?v=3" style=width:217px!important;height:60px!important> </a></div></div>