<!doctype html><html lang=en><meta http-equiv=x-ua-compatible content="IE=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"><meta http-equiv=permissions-policy content="interest-cohort=()"><title>Tagged unions and Fantasy Land | Devlog</title><link rel=stylesheet href=https://vonheikemen.github.io/devlog/print.css media=print><link rel=stylesheet href=https://vonheikemen.github.io/devlog/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><meta name=keywords content="javascript,functional-programming,software,coding,development"><meta name=monetization content="$ilp.uphold.com/dFQbFZ49nJdQ"><meta name=description content="Let's use tagged unions to explore the Fantasy Land specification"><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a></ul>© 2020-2021 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>Tagged unions and Fantasy Land</h1><span class=post-date>2020-06-12
| 24 min read
| <a href=https://vonheikemen.github.io/devlog/es/web-development/tagged-unions-and-fantasy-land/>Leer en español</a></span><p>Let's do something fun, let's explore one branch of the <a rel=noopener target=_blank href=https://github.com/fantasyland/fantasy-land>Fantasy Land</a> specification using tagged unions. In order to keep this as short as possible I'll mostly focus on how things work and leave out a lot of details. So, what we'll do is create a data structure and see if we can follow the rules on the specification.<h2 id=tagged-unions>Tagged Unions</h2><p>Also known as <em>variants</em>, is a data structure that can represent different states of a single type. At any given time it can only be in one of those states. Other important features include the ability to carry information about themselves as well as an extra "payload" that can hold anything.<p>It sounds cool until we realize we don't have those things in javascript. If we want to use them we'll have to recreate them. Fortunately for us we don't need a bulletproof implementation. We just need to deal with a couple of things, the type of the variant and the payload they should carry. We can handle that.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>Union</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>types</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>target </span><span style=color:#5fb3b3>= {};
</span><span>  
</span><span>  </span><span style=color:#c594c5>for</span><span>(</span><span style=color:#c594c5>const </span><span>type </span><span style=color:#5fb3b3>of </span><span>types) </span><span style=color:#5fb3b3>{
</span><span>    target[type] </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>(</span><span style=color:#5fb3b3>{ </span><span>type</span><span style=color:#5fb3b3>, </span><span>data </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>target</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>What do we have here? You can think of <code>Union</code> as a factory of constructor functions. It takes a list of variants and for each it will create a constructor. It looks better in an example. Let's say we want to model the states of a task, using <code>Union</code> we could create this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Status </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Union</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Success</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>Failed</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>Pending</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span></code></pre><p>Now we can create our <code>Status</code> variants.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Status</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Success</span><span>(</span><span style=color:#5fb3b3>{ </span><span>some</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>stuff</span><span style=color:#5fb3b3>&#39; }</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Success&quot;, &quot;data&quot;: { &quot;some&quot;: &quot;stuff&quot; } }
</span></code></pre><p>As you can see here we have a function that returns a plain object. In this object we have a <code>type</code> key where we store the name of our variant. The <code>data</code> key will hold anything we can think of. You might think that storing just the name of the variant isn't enough, because it may cause collisions with other variants of different types and you would be right. Since we are only going to create one data type this is not an issue for us.<p>If you find this pattern useful and want to use it, you'll need something reliable, consider using a library like <a rel=noopener target=_blank href=https://www.npmjs.com/package/tagmeme>tagmeme</a> or <a rel=noopener target=_blank href=https://www.npmjs.com/package/daggy>daggy</a> or something else.<h2 id=fantasy-land>Fantasy Land</h2><p>The github description says the following.<blockquote><p>Specification for interoperability of common algebraic structures in JavaScript</blockquote><p>Algebraic structures? What? I know. The wikipedia definition for that doesn't help much either. Best I can offer is a vague sentence that leaves you with the least amount of questions, here I go: A set of values that have some operations associated with them that follow certain rules.<p>In our case, you can think the variants as our "set of values" and the functions that we create will be the "operations," as far as the rules goes we follow the Fantasy Land specification.<h2 id=the-link>The Link</h2><p>So, we know about tagged unions and we have a vague idea about this Fantasy Land thing but know the question remains, how do we connect those two? The answer is <em>pattern matching</em>. Those familiar with the term also know that we don't have that in javascript. Sadly, in this case we can only mimic certain features.<p>How do we start? Let's just describe what we need. We need to evaluate a variant, be able to determine which type we have and execute a block of code. We already have the <code>type</code> key which is a <code>String</code>, with that we could just use a <code>switch/case</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>switch</span><span>(status</span><span style=color:#5fb3b3>.</span><span>type) </span><span style=color:#5fb3b3>{
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Success</span><span style=color:#5fb3b3>&#39;:
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Everything went well
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Failed</span><span style=color:#5fb3b3>&#39;:
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Something went wrong
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>case </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Pending</span><span style=color:#5fb3b3>&#39;:
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Waiting...
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>default</span><span style=color:#5fb3b3>:
</span><span style=color:#5fb3b3>    </span><span style=color:#5f6364>// Should never happen
</span><span>    </span><span style=color:#c594c5>break</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This actually gets pretty close to what we want but there is a problem, it doesn't return anything. We want to do the same this <code>switch/case</code> does but inside an expression, something that yields a result. To recreate this behavior in the way we want we'll use objects and functions.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>match</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>patterns</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#5fb3b3>{ </span><span>type </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>null </span><span style=color:#5fb3b3>} = </span><span>value </span><span style=color:#5fb3b3>|| {};
</span><span>  </span><span style=color:#c594c5>const </span><span>_match </span><span style=color:#5fb3b3>= </span><span>patterns[type]</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>if </span><span>(</span><span style=color:#5fb3b3>typeof </span><span>_match </span><span style=color:#5fb3b3>== &#39;</span><span style=color:#99c794>function</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>_match</span><span>(value</span><span style=color:#5fb3b3>.</span><span>data)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else if </span><span>(</span><span style=color:#5fb3b3>typeof </span><span>patterns</span><span style=color:#5fb3b3>.</span><span>_ </span><span style=color:#5fb3b3>== &#39;</span><span style=color:#99c794>function</span><span style=color:#5fb3b3>&#39;</span><span>) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>patterns</span><span style=color:#5fb3b3>.</span><span style=color:#69c>_</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#f99157>null</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Once again we take advantage of the fact that <code>type</code> is a <code>String</code> and use it to "choose" the pattern that we want. This time around our patterns are inside an object. Now, each "pattern" will be associated with a method on the <code>patterns</code> object and our function <code>match</code> will return what the chosen pattern returns. If it can't find the pattern it will try to call a method with the name <code>_</code>, this will mimic the <code>default</code> keyword on the <code>switch/case</code> and if that fails it just returns <code>null</code>. With this we can have the behavior we want.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>match</span><span>(status</span><span style=color:#5fb3b3>, {
</span><span>  </span><span style=color:#69c>Success</span><span style=color:#5fb3b3>: ({ </span><span style=color:#f99157>some </span><span style=color:#5fb3b3>}) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>Some: </span><span style=color:#5fb3b3>${</span><span>some</span><span style=color:#5fb3b3>}`,
</span><span>  </span><span style=color:#69c>Failed</span><span style=color:#5fb3b3>:  () </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Oops something went wrong</span><span style=color:#5fb3b3>&#39;,
</span><span>  </span><span style=color:#69c>Pending</span><span style=color:#5fb3b3>: () </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Wait for it</span><span style=color:#5fb3b3>&#39;,
</span><span>  </span><span style=color:#69c>_</span><span style=color:#5fb3b3>:       () </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>AAAAHHHH</span><span style=color:#5fb3b3>&#39;
</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// &quot;Some: stuff&quot;
</span></code></pre><p>With this function at our disposal we can now move on.<h2 id=the-data-structure>The Data Structure</h2><p>This is the part where we create the thing we're going to work with. We are going to model a fairly popular concept, an action that might fail. To do this we'll create a union with two variants <code>Ok</code> and <code>Err</code>, we will call it <code>Result</code>. The idea is simple, <code>Ok</code> will represent a success and we'll use it to carry the "expected" value, all our operations will be based on this variant. On the other hand if we get a variant of type <code>Err</code> all we want to do is propagate the error, this means that we'll ignore any kind of transformation on this variant.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Result </span><span style=color:#5fb3b3>= </span><span style=color:#69c>Union</span><span>([</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Ok</span><span style=color:#5fb3b3>&#39;, &#39;</span><span style=color:#99c794>Err</span><span style=color:#5fb3b3>&#39;</span><span>])</span><span style=color:#5fb3b3>;
</span></code></pre><h2 id=the-operations>The Operations</h2><p>Before we move on let's just do one more thing, let's create a <code>match</code> function specific to our data type.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>match </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>ok</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#69c>match</span><span>(data</span><span style=color:#5fb3b3>, {</span><span>Ok</span><span style=color:#5fb3b3>: </span><span>ok</span><span style=color:#5fb3b3>, </span><span>Err</span><span style=color:#5fb3b3>: </span><span>err</span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>Okay, now everything is in place. So like I said before, we will focus on just one branch of the Fantasy Land specification and that will be the one that goes from <code>Functor</code> to <code>Monad</code>. For each operation we will implement a static method in our <code>Result</code> object and I'll try to explain how does it work and why is useful.<p>Logic dictates that we start with Functor but we are going to take another road.<h3 id=chain>Chain</h3><p>The <code>chain</code> operation lets us interact with the value that's inside our structure and apply a transformation. Sounds easy, right? We do that all the time, but this time we have rules. I present to you the first law of the day.<ul><li>Associativity</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Fx)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Gx)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>Fx</span><span>(v)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Gx))</span><span style=color:#5fb3b3>;
</span></code></pre><blockquote><p>Notice that the comment says "equivalent to" although in most cases it should have identical results, this doesn't necessarily means that it should be read like equality, it is more like "it has the same effect as."</blockquote><p>This law is about the order of the operations. In the first statement notice that it reads like a sequence, it goes one after the other. In the second statement it's like one operation wraps around the other. And this part is interesting, <code>Fx(value).chain(Gx)</code>. That second <code>chain</code> comes directly from <code>Fx</code>. We can tell that <code>Fx</code> and <code>Gx</code> are functions that return a data type that also follows this law.<p>Let's see this in practice with another data type everyone is familiar with, arrays. It turns out that arrays follow this law (sorta). I know there is no <code>chain</code> in the <code>Array</code> prototype but there is a <code>flatMap</code> which behaves just like it.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#69c>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>exclaim      </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>str </span><span style=color:#5fb3b3>+ &#39;</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>&#39;;
</span><span>
</span><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>Uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>[</span><span style=color:#69c>to_uppercase</span><span>(str)]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>Exclaim   </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>[</span><span style=color:#69c>exclaim</span><span>(str)]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(Uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(Exclaim)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>Uppercase</span><span>(v)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatMap</span><span>(Exclaim))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>length</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>one[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>two[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>So <code>flatMap</code> let us interact with the <code>String</code> inside the array and transform it using a function and it didn't mattered that the second <code>flatMap</code> was inside or outside of the first, we got the same result.<p>Now let's do the same with our data type. Our implementation will be a static method (just for fun), so our examples will look a tiny bit different. This is how we do it.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>chain </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>match</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span>Err)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Thanks to the power of convenience <code>Result.match</code> has all the logic we need, the only thing we need to do is provide a value for the <code>err</code> parameter and just like that we achieve the effect we want. So <code>Result.chain</code> is a function that expects the <code>ok</code> and the <code>data</code> parameters. If the variant is of type <code>err</code> the error will just be wrapped again in a variant of the same type, like nothing happened. If the variant is of type <code>Ok</code> it will call the function we pass in the first argument.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>Uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#69c>to_uppercase</span><span>(str))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>Exclaim   </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#69c>exclaim</span><span>(str))</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span style=color:#69c>Uppercase</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>type </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>type</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>one</span><span style=color:#5fb3b3>.</span><span>data </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>.</span><span>data</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Since our function follows law we now have a way to compose functions that return other values of the same type. This is specially useful when creating a function composition where arguments of a function are the result of a previous function call.<p><code>Result.chain</code> can also be use to create other utility functions. Let's start by creating one that allows us to "extract" a value from the wrapper structure.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>identity </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>arg</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span>join </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>chain</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>identity)</span><span style=color:#5fb3b3>;
</span></code></pre><p>So with this we get <code>Result.join</code> a function that only waits for the <code>data</code> parameter (this is the power of <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/partial-application/>partial application</a>). Let's see it in action.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>good_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(good_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// &quot;Hello&quot;
</span><span>
</span><span style=color:#c594c5>const </span><span>bad_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span>(</span><span style=color:#5fb3b3>{ </span><span>message</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>Ooh noes</span><span style=color:#5fb3b3>&#39; }</span><span>)</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(bad_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Err&quot;, &quot;data&quot;: { &quot;message&quot;: &quot;Ooh noes&quot; } }
</span></code></pre><p>We called <code>join</code> because we should only use it to "flatten" a nested structure. Like in this case.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>nested_data </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Hello</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(nested_data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: &quot;Hello&quot; }
</span></code></pre><p>I'm going to abuse the nature of this function in future tests, to compare the content inside our structures. To make my intentions clear I'm going to create an "alias."<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>unwrap </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>join</span><span style=color:#5fb3b3>;
</span></code></pre><h3 id=functor>Functor</h3><p>If you've been reading other articles about functional programming in javascript that name may sound familiar. Even if you don't recognize it you've probably use it before. This part of the specification is the one that introduces our old friend <code>.map</code>. Let's see what makes it so special.<ul><li>Identity</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>v)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>It might not look interesting but it is. Pay attention to that function on the first statement, <code>v => v</code>, you know this one, right? We've used it before, it is known as the <code>identity</code> function. So, in math an identity element is a neutral value that has no effect on the result of the operation and this is exactly what this function does (nothing). But the interesting part is not on the surface, is what we can't see. If the first statement has the same effect as the second, then it means that <code>.map(v => v)</code> returns another value of the same type, it does that even if we give it the most useless function we could possibly imagine. Let's show this again using arrays as an example.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>identity </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>arg</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Id  </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(identity)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>isArray</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span style=color:#fac863>Array</span><span style=color:#5fb3b3>.</span><span style=color:#69c>isArray</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>Val</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>=== </span><span>Id</span><span style=color:#5fb3b3>.</span><span>length</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span>Val[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>Id[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>That's nice but how does that help us? The important part to understand here is that <code>.map</code> should "preserve the shape" of our structure. In this case with arrays, if we call it with an array with one item we get back another array with one item, if we call it with an array with one hundred items we get back another array with one hundred items. Knowing that the result will always have the same type allows us to do stuff like this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(fx)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(gx)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(hx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>I know what you're thinking, using <code>.map</code> like that way with arrays can have a big impact on performance. Shall not be worried, the second law has that covered.<ul><li>Composition</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(</span><span style=color:#69c>gx</span><span>(v)))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(gx)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(fx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>This law tells us that we can replace several calls to <code>.map</code> if we compose directly the functions we use as arguments. Let's try it.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>to_uppercase</span><span>(v)))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(to_uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one[</span><span style=color:#f99157>0</span><span>] </span><span style=color:#5fb3b3>=== </span><span>two[</span><span style=color:#f99157>0</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>So <code>.map</code> gave us the ability to combine those functions in different ways, this gives us the opportunity to optimize for speed or readability. Function composition is a very complex subject and I would like to say more but we don't have time for that right now. If you're curious about it you can read this: <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/composition-techniques/>composition techniques</a>.<p>Now is the time to implement the famous <code>.map</code> in our structure. You might have notice that this method is very similar to <code>.chain</code>, it has almost the same behavior except for one thing, with <code>.map</code> we should the guarantee that the result should be a value of the same type.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) { 
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#69c>fn</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>If you remember the behavior of <code>.chain</code> it only executes the callback function if <code>data</code> is a variant of type <code>Ok</code>, so the only thing we need to do to keep our structure is wrap the result from <code>fn</code> with <code>Result.Ok</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Identity
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(identity</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span><span>
</span><span style=color:#5f6364>// Composition
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>to_uppercase</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(to_uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><h3 id=apply>Apply</h3><p>This is a tough one, I better try to explain after I show you the law.<ul><li>Composition</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Gx</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Fx</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>fx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(</span><span style=color:#69c>gx</span><span>(v)))))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Gx)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Fx)</span><span style=color:#5fb3b3>;
</span></code></pre><p>"Whaaat?"<p>Yes, my thoughts exactly. That first statement is the most confusing thing we've seen so far. This time it looks like <code>Fx</code> and <code>Gx</code> are not functions, they are data structures. <code>Gx</code> has an <code>.ap</code> method so it must be the same type as <code>Val</code>. And if go further we can tell that <code>Fx</code> has a <code>map</code> method, that means is a Functor. So for this to work <code>Val</code>, <code>Fx</code> and <code>Gx</code> must implement the Functor and Apply specification. The last piece of the puzzle is this <code>Fx.map(fx => ... fx(...))</code>, there are functions involve but they are inside a data structure.<p>The name of this law and that second statement suggest this is about function composition. I'm thinking that this should behave just like <code>.map</code> but with a plot twist, the callback we get it's trapped inside a Functor. With this we have enough information to make our method.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>res</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(v)</span><span style=color:#5fb3b3>, </span><span>res)</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>What's going on in here? Well, let me explain. First we get the value inside <code>data</code> if everything goes well.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>..., </span><span>data)</span><span style=color:#5fb3b3>;
</span></code></pre><p>At this point we have problem, <code>.chain</code> doesn't give us any guarantee about the result, it can return anything. But we know that <code>res</code> is a Functor, so we can use <code>.map</code> to save the day.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>..., </span><span>res)</span><span style=color:#5fb3b3>;
</span></code></pre><p>In here <code>.map</code> has two jobs, it give us access to the function inside <code>res</code> and helps us preserve the shape of our structure. So, <code>.chain</code> will return anything that <code>.map</code> gives it, with this in place we can now have the confidence to call <code>.ap</code> multiple times.<p>The last stop in our trip is this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#69c>fn</span><span>(v)</span><span style=color:#5fb3b3>;
</span></code></pre><p>That is what we actually want from <code>.ap</code>. Thanks to <code>.map</code> the result of that expression gets wrapped inside another variant which in turn goes back to the outside world thanks to <code>.chain</code>. We can test it now.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>composition </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(</span><span style=color:#69c>gx</span><span>(arg))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Uppercase   </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(to_uppercase)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Exclaim     </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Uppercase</span><span style=color:#5fb3b3>, </span><span>Val))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Fine, but what is it good for? Putting a function inside a <code>Result.Ok</code> doesn't seem like common thing, why would somebody do that? All fair questions. I believe this is all confusing because <code>.ap</code> is only half of the story.<p><code>.ap</code> can be used to create a helper function called <code>liftA2</code>, the goal of this function is to make another function work with values that are wrapped in a structure. Something like this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Title </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Dr. </span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Name  </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>two</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#69c>concat</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA2</span><span>(concat</span><span style=color:#5fb3b3>, </span><span>Title</span><span style=color:#5fb3b3>, </span><span>Name)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: &quot;Dr. Acula&quot; }
</span></code></pre><p>You can think of it as the extended version of <code>.map</code>. While <code>.map</code> is meant to work with callbacks that take one argument, <code>liftA2</code> is designed to work with a function that takes two arguments. Now the question is how does it work? The answer is in this piece of code.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>composition </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>fx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(</span><span style=color:#69c>gx</span><span>(arg))</span><span style=color:#5fb3b3>;
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Let's see what happens here. It all begins with <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(composition</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>;
</span></code></pre><p>In this expression we extract the function inside <code>Exclaim</code> and we apply it to <code>composition</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#f99157>fx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(</span><span style=color:#69c>gx</span><span>(arg))
</span><span style=color:#5f6364>// becomes
</span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>gx</span><span>(arg))
</span></code></pre><p>That second statement gets wrapped inside an <code>Ok</code> variant which is exactly what <code>.ap</code> expects as the first argument. So, after <code>.map</code> gets evaluated we get this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#f99157>gx </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>gx</span><span>(arg)))</span><span style=color:#5fb3b3>, </span><span>Uppercase)</span><span style=color:#5fb3b3>;
</span></code></pre><p>And now that we have a function inside a variant <code>.ap</code> has all it needs to continue. In here we basically have more of the same, the function inside the second argument is applied to the function in the first. So we get this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>to_uppercase</span><span>(arg)))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Notice the pattern now? We have yet another function inside a variant, and this is exactly what our last <code>.ap</code> gets.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#f99157>arg </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#69c>to_uppercase</span><span>(arg)))</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span></code></pre><p>The cycle repeats again and finally we get.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>HELLO!!</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>This is basically the pattern that <code>liftA2</code> follows, the only difference is that instead of taking functions to a value, we take values to a function. You'll see.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA2 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R2</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>b </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1)</span><span style=color:#5fb3b3>, </span><span>R2)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>We test again.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>two</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#69c>concat</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA2</span><span>(concat</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Dr. </span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: &quot;Dr. Acula&quot; }
</span></code></pre><p>And what if you want to make a <code>liftA3</code>? You know what to do.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftA3 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R2</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R3</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>b </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>c </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b</span><span style=color:#5fb3b3>, </span><span>c)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1)</span><span style=color:#5fb3b3>, </span><span>R2)</span><span style=color:#5fb3b3>, </span><span>R3)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>And now that is the law of composition acting in our favor. As long a s <code>Result.ap</code> follows the law we can keep adding arguments with little effort. Now just for fun let's create a <code>liftN</code> function that can take any number of arguments. This time we will need a little help.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>curry</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arity</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>args</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>if</span><span>(arity </span><span style=color:#5fb3b3>&lt;= </span><span>args</span><span style=color:#5fb3b3>.</span><span>length) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#69c>fn</span><span>(</span><span style=color:#5fb3b3>...</span><span>args)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span>curry</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>arity</span><span style=color:#5fb3b3>, </span><span>fn</span><span style=color:#5fb3b3>, ...</span><span>args)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>const </span><span style=color:#69c>apply </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(arg)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#69c>pipe  </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>fns</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>arg</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>fns</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduce</span><span>(apply</span><span style=color:#5fb3b3>, </span><span>arg)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftN </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>R1</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>RN</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span>arity   </span><span style=color:#5fb3b3>= </span><span>RN</span><span style=color:#5fb3b3>.</span><span>length </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>const </span><span>curried </span><span style=color:#5fb3b3>= </span><span style=color:#69c>curry</span><span>(arity</span><span style=color:#5fb3b3>, </span><span>fn)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#69c>flipped </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>data </span><span style=color:#c594c5>=&gt; </span><span style=color:#f99157>R </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(R</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>const </span><span>ap      </span><span style=color:#5fb3b3>= </span><span style=color:#69c>pipe</span><span>(RN</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(flipped))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>R1))</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>That is the "automated" version of <code>liftA3</code>. Now we can use all kinds of functions.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#69c>concat </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>one</span><span style=color:#5fb3b3>, ...</span><span style=color:#f99157>rest</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span>one</span><span style=color:#5fb3b3>.</span><span style=color:#69c>concat</span><span>(</span><span style=color:#5fb3b3>...</span><span>rest)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>liftN</span><span>(
</span><span>  concat</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Hello, </span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Dr</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>. </span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>Acula</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>,
</span><span>  Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>&#39;</span><span>)
</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: &quot;Hello, Dr. Acula!!&quot; }
</span></code></pre><h3 id=applicative>Applicative</h3><p>You might have notice that everything we have built is some sort of extension of the previous methods, this will not be the exception. In order for our data structure to be an applicative it must first implement the Apply specification and then it must add one tiny detail.<p>The new contribution will be a method that can help us take a value and convert it into the simplest unit of our data structure. It's kinda like a constructor method in a class, the idea is to take any regular value and take to the "context" of our structure so we can start making any kind of operation.<p>You've probably used something like this before. With the <code>Promise</code> class we can do this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(to_uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &lt;state&gt;: &quot;pending&quot; }
</span><span style=color:#5f6364>// HELLO
</span></code></pre><p>After we call <code>Promise.resolve</code> our <code>'hello'</code> is "inside" a promise and we can immediately call methods like <code>then</code> or <code>catch</code>. If we wanted to do the same using the constructor we would have to do this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>promise </span><span style=color:#5fb3b3>= new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>reject</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=&gt; </span><span style=color:#5fb3b3>{ </span><span style=color:#69c>resolve</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>; }</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>promise</span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(to_uppercase)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#69c>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#69c>log</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &lt;state&gt;: &quot;pending&quot; }
</span><span style=color:#5f6364>// HELLO
</span></code></pre><p>All that extra effort doesn't look very clean, right? This is why a "shortcut" is useful, we can make a "simple" unit of our data structure without extra steps. It's time to make this for <code>Result</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>of </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>Ok</span><span style=color:#5fb3b3>;
</span></code></pre><p>I can assure you that is a coincidence, it's not always this easy. But really this is everything we need and we can prove that if we check the laws.<ul><li>Identity</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>v))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>Our old friend "identity" comes back to remind us that <code>.ap</code> really does behave like <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(identity)</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><ul><li>Homomorphism</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(val)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(fx))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#69c>fx</span><span>(val))</span><span style=color:#5fb3b3>;
</span></code></pre><p>Okay, so here we have a new concept we should learn. As far as I can tell an Homomorphism is some kind of transformation where we keep some of the "abilities" of the original value. I think this law tells us that <code>.of</code> doesn't have any effect when you "apply" a function to a value.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>value </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(exclaim)</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#69c>exclaim</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>To recap, in the first statement we apply <code>exclaim</code> to <code>value</code> while both of them are wrapped inside a variant. In the second statement we apply <code>exclaim</code> to <code>value</code> directly. In both cases we get the same result. With this we prove that there is nothing special about <code>.of</code>, it's just there to create a unit of our data structure.<ul><li>Interchange</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(y)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(U)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>U</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#f99157>fx </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fx</span><span>(y)))</span><span style=color:#5fb3b3>;
</span></code></pre><p>This is a tough one. Honestly, I'm not sure I understand what's trying to prove here. If I had to guess I would say that it doesn't matter which side of <code>.ap</code> we have the <code>.of</code> method, if can treat its content as a constant the result will be the same.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>value   </span><span style=color:#5fb3b3>= &#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;;
</span><span style=color:#c594c5>const </span><span>Exclaim </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>ap</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=&gt; </span><span style=color:#69c>fn</span><span>(value))</span><span style=color:#5fb3b3>, </span><span>Exclaim)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(one) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(two)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><h3 id=monad>Monad</h3><p>To create a Monad we must implement the Applicative and Chain specifications. So, what we have to do now is... nothing. Really, there is nothing left to do. You have created a Monad, congrats! Want to read some laws?<ul><li>Identity - left side</ul><pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>M</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(a)</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(f)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span style=color:#69c>f</span><span>(a)</span><span style=color:#5fb3b3>;
</span></code></pre><p>We check.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(exclaim</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span style=color:#69c>exclaim</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>At this point you may be wondering, couldn't we have done this after implementing <code>.chain</code> (since<code> .of</code> is an alias for <code>Ok</code>)? The answer is yes, but that wouldn't be fun.<p>So, what problems does this solve? What do we gain? This solves a very specific problem, one that could happen very often if we use Functors and that is nested structures.<p>Say we want to retrieve a <code>config</code> object that we have in <code>localStorage</code>. We know this action can fail that's why we created a function that uses our <code>Result</code> variant.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>get_config</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>const </span><span>config </span><span style=color:#5fb3b3>= </span><span>localStorage</span><span style=color:#5fb3b3>.</span><span style=color:#69c>getItem</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>config</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>  </span><span style=color:#c594c5>if</span><span>(config) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(config)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span>    
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span>(</span><span style=color:#5fb3b3>{ </span><span>message</span><span style=color:#5fb3b3>: &#39;</span><span style=color:#99c794>Config not found</span><span style=color:#5fb3b3>&#39; }</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This works wonders. Now the problem is <code>localStorage.getItem</code> doesn't return an object, the data we want is in a <code>String</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>{&quot;dark-mode&quot;:true}</span><span style=color:#5fb3b3>&#39;
</span></code></pre><p>We anticipated this so we created a function that can transform this into an object.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#69c>safe_parse</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>try </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#f99157>JSON</span><span style=color:#5fb3b3>.</span><span style=color:#69c>parse</span><span>(data))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>catch</span><span>(e) </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Err</span><span>(e)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>We know that <code>JSON.parse</code> can also fail, that's why we figure we could wrap it in a "safe function" that also uses our variant. Now try to use those two together using <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_config</span><span>())</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: { &quot;dark-mode&quot;: true } } }
</span></code></pre><p>Is that what you expected? If we close our eyes and pretend that <code>get_config</code> is always successful we could replace it with this.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>{&quot;dark-mode&quot;:true}</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: &quot;{\&quot;dark-mode\&quot;:true}&quot; }
</span></code></pre><p>This law tells me that if I use <code>.chain</code> to apply the function to a structure it's the same as applying that function to the data inside the structure. Let's use that, we have the perfect function for this situation.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>one </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(identity</span><span style=color:#5fb3b3>, </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>{&quot;dark-mode&quot;:true}</span><span style=color:#5fb3b3>&#39;</span><span>))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>two </span><span style=color:#5fb3b3>= </span><span style=color:#69c>identity</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>{&quot;dark-mode&quot;:true}</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>one </span><span style=color:#5fb3b3>=== </span><span>two</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>I hope by now you know what I'm going to do. You've seen it before.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span>join </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span>chain</span><span style=color:#5fb3b3>.</span><span style=color:#69c>bind</span><span>(</span><span style=color:#f99157>null</span><span style=color:#5fb3b3>, </span><span>identity)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Yes, it's <code>.join</code>. This is starting to look like a prequel. Let's open our eyes now and go back to our problem with <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span>(Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_config</span><span>()))</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: { &quot;dark-mode&quot;: true } }
</span></code></pre><p>We solved our problem. Now here comes the funny thing, in theory we could implement <code>.chain</code> using <code>.join</code> and <code>.map</code>. Using <code>.join</code> and <code>.map</code> together is so common that <code>.chain</code> was created (also, that's why some people call it <code>.flatMap</code>). Let's use it.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(safe_parse</span><span style=color:#5fb3b3>, </span><span style=color:#69c>get_config</span><span>())</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// { &quot;type&quot;: &quot;Ok&quot;, &quot;data&quot;: { &quot;dark-mode&quot;: true } }
</span></code></pre><p>Isn't it great when everything is wrap in a nice cycle? But don't get up your seats just yet, we still have a post-credit scene.<ul><li>Identity - right side</ul><p>So predictable. Alright, what does it say?<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Val</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(M</span><span style=color:#5fb3b3>.</span><span>of)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// is equivalent to
</span><span>Val</span><span style=color:#5fb3b3>;
</span></code></pre><p>We know we can do this but let's check anyway.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Val </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>Ok</span><span>(</span><span style=color:#5fb3b3>&#39;</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>&#39;</span><span>)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>const </span><span>Id </span><span style=color:#5fb3b3>= </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(Result</span><span style=color:#5fb3b3>.</span><span>of</span><span style=color:#5fb3b3>, </span><span>Val)</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Val) </span><span style=color:#5fb3b3>=== </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span>(Id)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// true
</span></code></pre><p>Nice, what can we do with this? Well, the only thing I can think of right now is making a more generic version of <code>.map</code>.<pre data-lang=js style=background-color:#2b2c2f;color:#cccece class=language-js><code class=language-js data-lang=js><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>map </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chain</span><span>(</span><span style=color:#f99157>v </span><span style=color:#c594c5>=&gt; </span><span>Result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>of</span><span>(</span><span style=color:#69c>fn</span><span>(v))</span><span style=color:#5fb3b3>, </span><span>data)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>It may not look like much because <code>.of</code> and <code>Ok</code> are the same thing, but if our constructor was a bit more complex (like <code>Promise</code>) this could be a nice way to simplify the implementation of <code>.map</code>.<p>And with this we close the cycle and end our journey through Fantasy Land.<h2 id=conclusion>Conclusion</h2><p>If you read all of this but couldn't understand all of it, don't worry you can blame me, maybe I didn't explain as well as I thought. It took me like two year to gather the knowledge to write this. Even if it takes you like a month to get it, you are already doing better than me.<p>A nice way to try understand how this methods work is to follow the specification using regular class instances, that should be easier.<p>I hope you enjoyed the reading and I hope I didn't cause you a headache. Until next time.<h2 id=sources>Sources</h2><ul><li><a rel=noopener target=_blank href=https://github.com/fantasyland/fantasy-land>Fantasy Land</a><li><a rel=noopener target=_blank href=http://www.tomharding.me/fantasy-land/>Fantas, Eel, and Specification</a><li><a rel=noopener target=_blank href=https://dev.to/macsikora/algebraic-structures-explained-part-1-base-definitions-2576>Algebraic Structures Explained - Part 1 - Base Definitions</a></ul><hr><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></div></div>