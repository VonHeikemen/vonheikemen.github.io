<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1,viewport-fit=cover" name=viewport><meta content="interest-cohort=()" http-equiv=Permissions-Policy><title>
  What are these applicative functors you speak of? | Devlog
</title><link href=https://vonheikemen.github.io/devlog/print.css media=print rel=stylesheet><link href=https://vonheikemen.github.io/devlog/styles.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel=stylesheet><link href=https://vonheikemen.github.io/devlog/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://hachyderm.io/@vonheikemen rel=me><link href=https://twitter.com/VonHeikemen_ rel=me><meta content="javascript, functional-programming, software, coding, development" name=keywords><meta content="let's use javascript to learn some applicatives for a greater good" name=description><body class=theme-base-custom><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://vonheikemen.github.io/devlog/><h1>Devlog</h1></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>whoami</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/tags/>Explore tags</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/es/>Devlog en español</a><li class=sidebar-nav-item><a href=https://vonheikemen.github.io/devlog/atom.xml>RSS</a></ul> © 2020-2024 Heiker Curiel</div></div><div class="content container"><div class=post><h1 class=post-title>What are these applicative functors you speak of?</h1><span class=post-date>2020-08-11 | 12 min read | <a href=https://vonheikemen.github.io/devlog/es/web-development/learn-fp/applicative-functors/> Leer en español </a> </span><p>What are they indeed. Our goal for today will be to learn about applicative functors using javascript. Yes, javascript. Don't judge me, it's what I know. We'll cover things like how to create them, how you can spot them in the wild and a somewhat useful use case.<p>Okay, let's start from the beginning.<h2 id=what-is-a-functor>What is a functor?</h2><p>From a "technical" point of view you can think of them as containers of some sort. You see, the simplest way to implement a functor is by wrapping a value inside a data structure, then provide a method to interact with that value. This method is usually called <code>map</code>, its only purpose is to give us access to the value so we can transform it and then put the result back into the wrapper structure.<p>Let's see <code>map</code> in action. To make this less scary we'll look at a data type that we use all the time in javascript, arrays.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>numbers </span><span style=color:#5fb3b3>= </span><span>[</span><span style=color:#f99157>1</span><span>]</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span>numbers</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// [ 2 ]
</span></code></pre><p>What happens here?<p>We have a number wrapped in an array, we use <code>map</code> to gain access to it and transform it using a callback function, and then the new value of the number gets wrapped in another array. That's it. That's basically the behaviour you want in a functor.<p>Now, arrays are not the only ones that have this behaviour, there is another data type that acts like this, <code>Promise</code>. In a <code>Promise</code> we don't have a <code>map</code> but we have a <code>then</code> which is close enough.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>number </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#f99157>1</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span>number</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// Promise { &LTstate>: "pending" }
</span><span style=color:#5f6364>// 2
</span></code></pre><p>Same thing happens here, we have a value in a structure (here a <code>Promise</code>), a method gives us access through a callback (that's <code>then</code>) and the new value gets wrapped in another instance of the same structure.<p>And that's the pattern. We covered what we needed to know about functors for now. If you want to know more about them check out this article: <a href=https://vonheikemen.github.io/devlog/web-development/learn-fp/the-power-of-map/>The Power of Map</a>.<p>Ready to move on?<h2 id=applicatives>Applicatives</h2><p>Applicatives are just functors with extra features. They give you the ability to merge two functors together. Specifically, they allow you to apply a function inside a functor to a value that's also inside a functor.<p>Wait... What? A functor that has function inside?<p>Yes. Putting a function inside a functor, like doing this.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>plus_one </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>number</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>number </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// And then you put it in a box
</span><span>
</span><span>[plus_one]</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>// Or
</span><span>
</span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>resolve</span><span>(plus_one)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Why would someone do that?<p>Good question. The answer is, you wouldn't. I mean in the context of javascript is not a common thing to do. Doesn't mean applicatives are useless to us.<p>Back to our definition. Normally if you have a function and a value you would be able to apply the function using this syntax: <code>some_function(some_value)</code>. That doesn't work if both are inside another structure. To "fix" this, applicatives have a method called <code>ap</code> (short for apply) which takes care of unwrapping each functor and applying the function to the value.<p>At this point I would love to show an example of a built-in data type that follows the rules of applicatives but I don't know of any. But do not fear, let's take this as an opportunity to do something else.<h2 id=building-an-applicative-from-scratch>Building an Applicative from scratch</h2><p>In order to keep this simple we are just going to make a thin wrapper around the <code>Promise</code> class. We are going to make <code>Promise</code> feel more functor-y and applicative-ish. Where do we start?<ul><li>The goal</ul><p>We want to make a "lazy promise". Usually a <code>Promise</code> executes the "task" we give it immediately but we don't want that now, this time we want to control when the task gets called. To achieve our goal we are going to create a method called <code>fork</code>, this will be the one that actually builds the <code>Promise</code> and sets the callbacks for success and failure.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>Task</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>proc</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#6699cc>fork</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>success</span><span style=color:#5fb3b3>) {
</span><span>      </span><span style=color:#c594c5>const </span><span>promise </span><span style=color:#5fb3b3>= new </span><span>Promise(proc)</span><span style=color:#5fb3b3>;
</span><span>      </span><span style=color:#c594c5>return </span><span>promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(success)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>catch</span><span>(err)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Awesome. Now let's compare this we a normal <code>Promise</code>.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>let </span><span>number </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>procedure </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>reject</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#6699cc>look_ma </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(</span><span style=color:#5fb3b3>`</span><span style=color:#99c794>IT WORKED </span><span style=color:#5fb3b3>${++</span><span>number</span><span style=color:#5fb3b3>}</span><span style=color:#99c794> times</span><span style=color:#5fb3b3>`</span><span>)</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#6699cc>resolve</span><span>()</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>};
</span><span>
</span><span>  </span><span style=color:#6699cc>setTimeout</span><span>(look_ma</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span><span>
</span><span style=color:#5fb3b3>new </span><span>Promise(procedure)</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// This one is already running
</span><span>
</span><span style=color:#6699cc>Task</span><span>(procedure)</span><span style=color:#5fb3b3>; </span><span style=color:#5f6364>// This one doesn't do anything
</span><span style=color:#6699cc>Task</span><span>(procedure)  </span><span style=color:#5f6364>// This does
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>fork</span><span>(
</span><span>    </span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>error</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>AAHHH!</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5fb3b3>() </span><span style=color:#c594c5>=> </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>AWW</span><span style=color:#5fb3b3>'</span><span>)
</span><span>  )</span><span style=color:#5fb3b3>;
</span></code></pre><p>If you run that you should get these messages after 1 second.<pre style=background:#2b2c2f;color:#cccece><code><span>IT WORKED 1 times
</span><span>IT WORKED 2 times
</span><span>AWW
</span></code></pre><p>Now that we have what we want, let's go to the next step.<ul><li>Make it functor</ul><p>As you know applicatives are functors, it means that now we need a <code>map</code>.<p>Let's go over one more time. What is the expected behaviour of <code>map</code>?<ol><li>It should give us access to the inner value through a callback function.<li>It should return a new container of the same type. In our case it should return another <code>Task</code>.</ol><pre class=language-diff data-lang=diff style=background:#2b2c2f;color:#cccece><code class=language-diff data-lang=diff><span>  function Task(proc) {
</span><span>    return {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     map(fn) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return Task(function(resolve, reject) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const promise = new Promise(proc);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         promise.then(fn).then(resolve).catch(reject);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       });
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>      fork(err, success) {
</span><span>        const promise = new Promise(proc);
</span><span>        return promise.then(success).catch(err);
</span><span>      }
</span><span>    }
</span><span>  }
</span></code></pre><p>What happens there? Well, first we receive an <code>fn</code> argument that's our callback. Then, we return a new <code>Task</code>. Inside that new <code>Task</code> we build the promise, just like in fork but this time it's "safer" because it doesn't run immediately. After that we just chain functions to the <code>promise</code> in their respective order, first the <code>fn</code> callback to transform the value, then the <code>resolve</code> function that will "end" the current task and finally the <code>catch</code> gets the <code>reject</code> function from the current task.<p>We can test this now.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>';
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>ohh </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>OOHH</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>, </span><span>value)</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#6699cc>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(exclaim)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(ohh)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>fork</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>error</span><span style=color:#5fb3b3>, </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>If you run it as is you should get this.<pre style=background:#2b2c2f;color:#cccece><code><span>OOHH
</span><span>hello!!
</span></code></pre><p>But if you remove the <code>fork</code> you should get this.<pre style=background:#2b2c2f;color:#cccece><code></code></pre><p>Yes, a whole lot of nothing. Now we are done with the functory stuff.<ul><li>Let's Apply</ul><p>We are half way there now. We have our functor pattern going on, now we need to make <code>ap</code> happen.<p>The way I see it <code>ap</code> is just like <code>map</code> but with a plot twist: the function we want to apply it's trapped inside another <code>Task</code> [<em>dramatic music plays in the background</em>].<p>With that idea in our minds we can write <code>ap</code>.<pre class=language-diff data-lang=diff style=background:#2b2c2f;color:#cccece><code class=language-diff data-lang=diff><span>  function Task(proc) {
</span><span>    return {
</span><span>      map(fn) {
</span><span>        return Task(function(resolve, reject) {
</span><span>          const promise = new Promise(proc);
</span><span>          promise.then(fn).then(resolve).catch(reject);
</span><span>        });
</span><span>      },
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     ap(Fn) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       return Task(function(resolve, reject) {
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const promise = new Promise(proc);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         const success = fn => promise.then(fn);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>         Fn.fork(reject, success).then(resolve);
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>       });
</span><span style=color:#5fb3b3>+</span><span style=color:#99c794>     },
</span><span>      fork(err, success) {
</span><span>        const promise = new Promise(proc);
</span><span>        return promise.then(success).catch(err);
</span><span>      }
</span><span>    }
</span><span>  }
</span></code></pre><p>Spot the difference? Don't worry I'll tell you anyway, the difference is that in order to get the callback function we use the <code>fork</code> of <code>Fn</code> instead of a raw <code>Promise</code>. That's it. Now see if it works.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span style=color:#6699cc>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>';
</span><span>
</span><span style=color:#c594c5>const </span><span>Uppercase </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(to_uppercase))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Exclaim </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(exclaim))</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>Hello </span><span style=color:#5fb3b3>= </span><span style=color:#6699cc>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Hello</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Uppercase)</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Exclaim)
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>fork</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>error</span><span style=color:#5fb3b3>, </span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>We made it! Now we can merge values and functions inside applicatives! But we can't enter the applicative functors club just yet, we still need something more.<ul><li>The forgotten ingredient</ul><p>Applicatives must be able to put any value into the most simple unit of your structure.<p>The <code>Promise</code> class actually has something like that. Instead of doing this.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))</span><span style=color:#5fb3b3>;
</span></code></pre><p>We usually do this.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>And after we use <code>Promise.resolve</code> we can immediately start calling methods like <code>then</code> and <code>catch</code>. That's what our <code>Task</code> is missing.<p>For this new "feature", we will need a static method. This one has different names in the wild, some call it "pure" others call it "unit" and the lazy ones call it "of".<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#6699cc>Task</span><span>(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(value))</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>We can finally say we have an applicative functor.<h2 id=something-you-can-use-in-your-day-to-day-coding>Something you can use in your day to day coding</h2><p>Been able to create your own data type is nice, but wouldn't it be better if could just apply these patterns to existing types?<p>I have a good news and bad news. The good news is that we totally can. The bad news is that it will be a bit awkward.<p>Let's keep going with the <code>Task</code> theme we got going on. Let's say that we want to use <code>map</code> and <code>ap</code> with a <code>Promise</code> but we don't want create a new data type. What do we do? Some good old functions will do.<p>If you know the patterns and behaviours you should be looking for, writing some static functions in an object will be enough. This what our <code>Task</code> would look like as static functions (minus the "lazy" part).<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span>Task </span><span style=color:#5fb3b3>= {
</span><span>  </span><span style=color:#6699cc>of</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>resolve</span><span>(value)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#6699cc>map</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(fn)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>},
</span><span>  </span><span style=color:#6699cc>ap</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>Fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>data</span><span style=color:#5fb3b3>) {
</span><span>    </span><span style=color:#c594c5>return </span><span>Fn</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#f99157>fn </span><span style=color:#c594c5>=> </span><span>data</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#f99157>value </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(value)))</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>};
</span></code></pre><p>If you want to <code>map</code> you'll do something like this.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>to_uppercase </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>toUpperCase</span><span>()</span><span style=color:#5fb3b3>;
</span><span>
</span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(to_uppercase</span><span style=color:#5fb3b3>, </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p><code>ap</code> also works in the same way.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>const </span><span style=color:#6699cc>exclaim </span><span style=color:#5fb3b3>= (</span><span style=color:#f99157>str</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span>str </span><span style=color:#5fb3b3>+ '</span><span style=color:#99c794>!!</span><span style=color:#5fb3b3>';
</span><span>
</span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(exclaim)</span><span style=color:#5fb3b3>, </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>of</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>hello</span><span style=color:#5fb3b3>'</span><span>))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>I can feel your scepticism from here. Be patient, this will be good. Now, <code>map</code> looks kinda useful but <code>ap</code> not so much, right? Don't worry, we can still use <code>ap</code> for a greater good. What if I told you we can have like an "enhanced" version of <code>map</code>? Our <code>map</code> just works with functions that receive one argument and that's good but sometimes we need more.<p>Say that we have a function that needs two arguments but every time we use it those arguments come from two different promises. In our imaginary situation we have these functions.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#c594c5>function </span><span style=color:#6699cc>get_username</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#6699cc>fetch_data </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>john doe</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>; 
</span><span>    </span><span style=color:#6699cc>setTimeout</span><span>(fetch_data</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>1000</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>get_location</span><span style=color:#5fb3b3>() {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>new </span><span>Promise(</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>resolve</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>=> </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>const </span><span style=color:#6699cc>fetch_data </span><span style=color:#5fb3b3>= () </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>resolve</span><span>(</span><span style=color:#5fb3b3>'</span><span style=color:#99c794>some place</span><span style=color:#5fb3b3>'</span><span>)</span><span style=color:#5fb3b3>; 
</span><span>    </span><span style=color:#6699cc>setTimeout</span><span>(fetch_data</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>500</span><span>)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>function </span><span style=color:#6699cc>format_message</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>name</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>place</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>return </span><span style=color:#5fb3b3>`</span><span style=color:#99c794>name: </span><span style=color:#5fb3b3>${</span><span>name</span><span style=color:#5fb3b3>}</span><span style=color:#99c794> | place: </span><span style=color:#5fb3b3>${</span><span>place</span><span style=color:#5fb3b3>}`;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>When we use <code>format_message</code> its arguments almost every time come from those other functions <code>get_username</code> and <code>get_location</code>. They are asynchronous, so you might be tempted to use <code>Async/await</code> but that wouldn't be the best idea. Those two don't depend on each other, we will be wasting time if we make them run sequentially when they could be running concurrently. One solution can be found in the form of <code>Promise.all</code>, and it looks like this.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span style=color:#fac863>Promise</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>all</span><span>([</span><span style=color:#6699cc>get_username</span><span>()</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_location</span><span>()])
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#5fb3b3>([</span><span style=color:#f99157>name</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>place</span><span style=color:#5fb3b3>]) </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>format_message</span><span>(name</span><span style=color:#5fb3b3>, </span><span>place))
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>There you go. That works. But we can do better because we have applicatives on our side. Besides, we already wrote that <code>Task</code> object with all those functions. Let's add one more static function to <code>Task</code> that does the same thing <code>Promise.all</code> is doing for us here.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA2 </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>function</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>fn</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>A1</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>A2</span><span style=color:#5fb3b3>) {
</span><span>  </span><span style=color:#c594c5>const </span><span style=color:#6699cc>curried </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>a </span><span style=color:#c594c5>=> </span><span style=color:#f99157>b </span><span style=color:#c594c5>=> </span><span style=color:#6699cc>fn</span><span>(a</span><span style=color:#5fb3b3>, </span><span>b)</span><span style=color:#5fb3b3>;
</span><span>  </span><span style=color:#c594c5>return </span><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>ap</span><span>(Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>map</span><span>(curried</span><span style=color:#5fb3b3>, </span><span>A1)</span><span style=color:#5fb3b3>, </span><span>A2)</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>};
</span></code></pre><p>I'll explain the name later. Now let's see it action.<pre class=language-js data-lang=js style=background:#2b2c2f;color:#cccece><code class=language-js data-lang=js><span>Task</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>liftA2</span><span>(format_message</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_username</span><span>()</span><span style=color:#5fb3b3>, </span><span style=color:#6699cc>get_location</span><span>())
</span><span>  </span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>then</span><span>(</span><span style=color:#fac863>console</span><span style=color:#5fb3b3>.</span><span style=color:#6699cc>log</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>Isn't this just slightly better?<p>And yes, several arguments could be made against this particular implementation of <code>liftA2</code> and the <code>Task</code> itself, but all the patterns I've shown would work just fine with most of the applicative you can find in the wild.<p>As a fun exercise you can try to implement <code>map</code> and <code>ap</code> for <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set rel=noopener target=_blank>Set</a>s. See what kind of funny things you discover in the process.<p>Anyway, about that name <code>liftA2</code>. In functional programming when you take a function and make it work with container types like functors it is said that you're "lifting" the function to the "context" of that container. What do I mean by context? Okay, in the world of arrays when you use <code>Array.map</code> your function gets applied multiple times, in the context of a <code>Promise</code> your function runs only when the <code>Promise</code> is resolved. See what I mean? Good. The <code>A2</code> part? Well, you know, it only works with binary functions so... that's why.<p>There is still one more trick you can do with applicatives but I still don't fully understand how it works, so maybe next time I'll show you that.<h2 id=conclusion>Conclusion</h2><p>What did we learn today, class?<ul><li>We learned about functors: <ul><li>What they do.<li>What pattern they should follow.</ul><li>We learned about applicatives: <ul><li>What they are.<li>What they do.<li>How to make one from scratch.<li>How to make an <code>ap</code> even if the data type doesn't have a built-in method to support the applicative pattern.<li>And that <code>liftA2</code> thingy that looks kinda of cool.</ul></ul><p>Y'all learned all that? My goodness. You're the best.<p>Okay, I guess my job here is done.<h2 id=sources>Sources</h2><ul><li><a href=https://github.com/fantasyland/fantasy-land rel=noopener target=_blank>Fantasy Land</a><li><a href=https://github.com/fantasyland/static-land rel=noopener target=_blank>Static Land</a><li><a href=http://www.tomharding.me/2017/04/10/fantas-eel-and-specification-8/ rel=noopener target=_blank>Fantas, Eel, and Specification 8: Apply</a><li><a href=http://www.tomharding.me/2017/04/17/fantas-eel-and-specification-9/ rel=noopener target=_blank>Fantas, Eel, and Specification 9: Applicative</a><li><a href=https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch10.html rel=noopener target=_blank>Professor Frisby's Mostly Adecuate Guide to Functional Programming. Chapter 10: Applicative Functors</a><li><a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors rel=noopener target=_blank>Learn you a Haskell: Functors, Applicative Functors and Monoids</a></ul><hr><p>Have any question? Feel free to leave a comment in one of these platform where I have shared this:<ul><li><a href=https://dev.to/vonheikemen/what-are-these-applicative-functors-you-speak-of-4j6f rel=noopener target=_blank>dev.to</a><li><a href=https://vonheikemen.hashnode.dev/applicative-functors rel=noopener target=_blank>Hashnode</a></ul><p>You can reach out to me on social media:<ul><li>Twitter <a rel="noopener me" href=https://twitter.com/VonHeikemen_ target=_blank> @VonHeikemen_ </a><li>Mastodon <a rel="noopener me" href=https://hachyderm.io/@vonheikemen target=_blank> @vonheikemen@hachyderm.io </a></ul><p>Thank you for reading. If you find this article useful and want to support my efforts, buy me a coffee ☕</p><a href=https://www.buymeacoffee.com/vonheikemen style=display:flex;justify-content:center target=_blank> <img alt="Buy Me A Coffee" src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png style=height:60px!important;width:217px!important> </a></div></div>